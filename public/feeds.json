[
  {
    "name": "ㅍㅍㅅㅅ",
    "category": "큐레이팅",
    "posts": []
  },
  {
    "name": "C++ Team Blog",
    "category": "기업",
    "posts": [
      {
        "creator": "Sy Brand",
        "title": "Pure Virtual C++ 2025: Full Schedule",
        "link": "https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2025-full-schedule/",
        "pubDate": "Tue, 15 Apr 2025 12:15:38 +0000",
        "content:encodedSnippet": "Pure Virtual C++ is our free, one-day, virtual conference for the whole C++ community. This year, it is running on the 30th April. We’re pleased to announce the schedule of live talks:\n14:00 UTC: Welcome to v1.0 of the meta::[[verse]]! with Inbal Levi\n14:30 UTC: Proxy: Next Generation Polymorphism with Mingxin Wang\n15:00 UTC: Making unfamiliar C++ code familiar with GitHub Copilot with Sinem Akinci\n15:30 UTC: C++ Modules Myth Busting with Cameron DaCamara\n16:00 UTC: constexpr everything?! with Hana Dusíková\nYou can find abstracts for all the talks and register for the conference with the button below.\nKeep an eye out for on-demand pre-conference content coming soon on YouTube.\nRegister for Free\n\nThe post Pure Virtual C++ 2025: Full Schedule appeared first on C++ Team Blog.",
        "dc:creator": "Sy Brand",
        "comments": "https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2025-full-schedule/#respond",
        "content": "<p>Pure Virtual C++ is our free, one-day, virtual conference for the whole C++ community. This year, it is running on the 30th April. We&#8217;re pleased to announce the schedule of live talks: 14:00 UTC: Welcome to v1.0 of the meta::[[verse]]! with Inbal Levi 14:30 UTC: Proxy: Next Generation Polymorphism with Mingxin Wang 15:00 UTC: Making [&#8230;]</p>\n<p>The post <a href=\"https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2025-full-schedule/\">Pure Virtual C++ 2025: Full Schedule</a> appeared first on <a href=\"https://devblogs.microsoft.com/cppblog\">C++ Team Blog</a>.</p>\n",
        "contentSnippet": "Pure Virtual C++ is our free, one-day, virtual conference for the whole C++ community. This year, it is running on the 30th April. We’re pleased to announce the schedule of live talks: 14:00 UTC: Welcome to v1.0 of the meta::[[verse]]! with Inbal Levi 14:30 UTC: Proxy: Next Generation Polymorphism with Mingxin Wang 15:00 UTC: Making […]\nThe post Pure Virtual C++ 2025: Full Schedule appeared first on C++ Team Blog.",
        "guid": "https://devblogs.microsoft.com/cppblog/?p=35386",
        "categories": [
          "C++"
        ],
        "isoDate": "2025-04-15T12:15:38.000Z"
      }
    ]
  },
  {
    "name": "Facebook Engineering",
    "category": "기업",
    "posts": []
  },
  {
    "name": "eBay Tech Blog",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Twitter Blog",
    "category": "기업",
    "posts": []
  },
  {
    "name": "JetBrains: Developer Tools for Professionals and Teams – Company Blog | JetBrains",
    "category": "기업",
    "posts": [
      {
        "creator": "Vaclav Pech",
        "title": "MPS 2025.1 Release Candidate Is Here!",
        "link": "https://blog.jetbrains.com/mps/2025/04/the-mps-2025-1-rc-ready/",
        "pubDate": "Thu, 17 Apr 2025 15:57:02 +0000",
        "content:encodedSnippet": "We’re excited to announce that the Release Candidate for MPS 2025.1 is now available! Download it today and be among the first to try out the latest features and improvements.\nDOWNLOAD MPS 2025.1 RC\nCurious about what’s new? Check out this blog post for a deep dive into all the updates.\nThe full list of fixed issues can be found here.\nYour JetBrains MPS team",
        "dc:creator": "Vaclav Pech",
        "content": "We’re excited to announce that the Release Candidate for MPS 2025.1 is now available! Download it today and be among the first to try out the latest features and improvements. DOWNLOAD MPS 2025.1 RC Curious about what’s new? Check out this blog post for a deep dive into all the updates. The full list of [&#8230;]",
        "contentSnippet": "We’re excited to announce that the Release Candidate for MPS 2025.1 is now available! Download it today and be among the first to try out the latest features and improvements. DOWNLOAD MPS 2025.1 RC Curious about what’s new? Check out this blog post for a deep dive into all the updates. The full list of […]",
        "guid": "https://blog.jetbrains.com/?post_type=mps&p=561535",
        "categories": [
          "releases",
          "eap",
          "release"
        ],
        "isoDate": "2025-04-17T15:57:02.000Z"
      },
      {
        "creator": "Ivan Tiutiundzhi",
        "title": "Datalore 2025.2 Is Out With Report Tabs, Extended DuckDB Support, and Snowflake Key Pair Authentication",
        "link": "https://blog.jetbrains.com/datalore/2025/04/17/datalore-2025-2-is-out-with-report-tabs-extended-duckdb-support-and-snowflake-key-pair-authentication/",
        "pubDate": "Thu, 17 Apr 2025 13:30:57 +0000",
        "content:encodedSnippet": "Datalore 2025.2 introduces several new features, including report tabs, DuckDB as a data source for SQL cells, Snowflake key pair authentication, and the possibility to use a custom JDBC driver for the Datalore server, which is particularly relevant for the On-Premises version.\nDatalore Cloud users have already received the new updates automatically, and Datalore On-Premises users can upgrade by following these instructions.\nBefore diving into this release’s features, please take note of an important upcoming change:\nStarting with the next major update (Datalore 2025.3), the default Python interpreter will be upgraded to Python 3.11. This means that new notebooks will be created using Python 3.11, while existing notebooks will need to be updated manually. If no action is taken, existing notebooks will remain on Python 3.8, but they will no longer run.\nFor On-Premises users, we’re not planning to update previous baseline images with Python 3.8 or any previously custom-released images (Python 3.10). If you need another runtime version or if you’d like to install a third-party library to your standard environment, consider building a custom agent image.\nReport tabs\n\n\n\n\nReport tabs are the sections within a report that allow you to organize content into multiple views. Similar to sheets in Excel or pages in Power BI, tabs help structure complex reports by grouping related information. You can add tabs and assign selected cells and outputs to one or more of them. Each element can appear in only one tab at a time. Report viewers can navigate through the report using these tabs for a more structured and intuitive experience.\nLearn more about how to build a report.\nDuckDB as a data source for SQL cells\n\n\n\n\nDatalore now supports DuckDB as a data source for SQL cells. With this addition, you can seamlessly query local files (CSV, Parquet, or any format supported by DuckDB) and leverage the full extent of DuckDB’s capabilities.\nSnowflake key pair authentication\n\n\n\n\nFollowing a recent announcement from Snowflake, Datalore’s Snowflake connector now supports key pair authentication, allowing you to securely connect to Snowflake without using passwords. This authentication method leverages public-private key cryptography for enhanced security.\nAnother noteworthy improvement to Datalore On-Premises\nCustom JDBC drivers can now be used not only for data sources but also for the Datalore server itself. In certain cases, a custom PostgreSQL driver may be required to connect to the PostgreSQL database used internally by Datalore, for example, when using Amazon RDS with IAM authentication. Learn more.\n      \n      Upgrade to 2025.2",
        "dc:creator": "Ivan Tiutiundzhi",
        "content": "Datalore 2025.2 introduces several new features, including report tabs, DuckDB as a data source for SQL cells, Snowflake key pair authentication, and the possibility to use a custom JDBC driver for the Datalore server, which is particularly relevant for the On-Premises version. Datalore Cloud users have already received the new updates automatically, and Datalore On-Premises [&#8230;]",
        "contentSnippet": "Datalore 2025.2 introduces several new features, including report tabs, DuckDB as a data source for SQL cells, Snowflake key pair authentication, and the possibility to use a custom JDBC driver for the Datalore server, which is particularly relevant for the On-Premises version. Datalore Cloud users have already received the new updates automatically, and Datalore On-Premises […]",
        "guid": "https://blog.jetbrains.com/?post_type=datalore&p=562165",
        "categories": [
          "releases"
        ],
        "isoDate": "2025-04-17T13:30:57.000Z"
      },
      {
        "creator": "Oksana Mandryka",
        "title": "Google Gemini 2.5 Pro arrives in JetBrains AI Assistant",
        "link": "https://blog.jetbrains.com/ai/2025/04/google-gemini-2-5-pro-arrives-in-jetbrains-ai-assistant/",
        "pubDate": "Thu, 17 Apr 2025 12:53:15 +0000",
        "content:encodedSnippet": "JetBrains AI Assistant now supports Google’s latest and most intelligent AI model, Gemini 2.5 Pro. This integration makes your JetBrains IDE even smarter, providing enhanced accuracy and deep reasoning capabilities to streamline your coding experience.\nAt JetBrains, we aim to equip developers with AI tools that simplify complex tasks and make everyday coding more productive and enjoyable. By continually integrating cutting-edge AI models – such as our own LLM Mellum for code completion, as well as third-party LLMs – we’re committed to improving your workflow and helping you tackle every task. \nGoogle Gemini 2.5 Pro is currently available in AI Assistant in experimental mode.\nWhat’s special about Gemini 2.5 Pro \nGoogle Gemini 2.5 Pro, the first “thinking” model from Google DeepMind, is currently listed as a top performer across several key industry benchmarks for coding tasks, as well as mathematics and science challenges, and it ranks highly on the community-driven LMArena Leaderboard. With this top-performing model integrated directly into your JetBrains IDE, you’ll be able to:\nSolve complex problems: Use Gemini 2.5 Pro’s advanced reasoning to complete intricate coding tasks.\nImprove code quality: Experience greater precision and contextual understanding, streamlining your coding process.\nEnhance your productivity: Receive accurate, context-aware suggestions directly in your IDE for more efficiency.\n\n\n\n\nGemini 2.5 Pro simplifies your workflow, as it minimizes guesswork, boosts code quality, and significantly reduces debugging time.\n“We are excited to closely partner with JetBrains AI to deliver a state-of-the-art experience with Gemini 2.5. To achieve this we focused on advancing our models’ reasoning abilities and code generation quality.\n\r\nFor JetBrains AI users, this means higher quality code suggestions and a richer understanding of project context by the AI. We are excited to see what the JetBrains AI community builds and we are looking forward to collaborating on future projects like AI-powered developer assistance capabilities and agents.”\n\n            \nJason Gelman\n                                                                Product Director for Google Gemini and AI Agents\n                                    \nTechnical details and considerations\nTo help you get the most out of Gemini 2.5 Pro, here are a few technical points to be aware of:\nSupported context window: We currently support a 200,000 token context window for this model and are actively working to enable the full 1 million token input context as soon as possible. \nUsage cost: As with other highly performant models, users should monitor credit usage.\nRate of requests: Gemini 2.5 Pro is still a Preview model, so you may experience a lower available rate of requests to it. \nFeature support: We recommend carefully reviewing Google’s official documentation to determine whether specific features are applicable to your use case.\n\n\n\n\nNeed help finding the perfect model for your needs? Check out this blog post for some helpful tips. If you’re interested in integrating JetBrains’ latest models and datasets into your automated evaluation process, take a look at our card on Hugging Face.\nHow to try it\nTo use the latest model, simply select Gemini 2.5 Pro (Experimental) from the AI chat’s drop-down menu in your JetBrains IDE.\nThe integration is available starting from version 2025.1 of JetBrains IDEs. \nIf you’re already using JetBrains AI Assistant, simply update your IDE to the latest version to explore the new features. If you haven’t yet given JetBrains AI Assistant a try, we invite you to get started today. It’s free. \nTry AI Assistant",
        "dc:creator": "Oksana Mandryka",
        "content": "JetBrains AI Assistant now supports Google&#8217;s latest and most intelligent AI model, Gemini 2.5 Pro. This integration makes your JetBrains IDE even smarter, providing enhanced accuracy and deep reasoning capabilities to streamline your coding experience. At JetBrains, we aim to equip developers with AI tools that simplify complex tasks and make everyday coding more productive [&#8230;]",
        "contentSnippet": "JetBrains AI Assistant now supports Google’s latest and most intelligent AI model, Gemini 2.5 Pro. This integration makes your JetBrains IDE even smarter, providing enhanced accuracy and deep reasoning capabilities to streamline your coding experience. At JetBrains, we aim to equip developers with AI tools that simplify complex tasks and make everyday coding more productive […]",
        "guid": "https://blog.jetbrains.com/?post_type=ai&p=561931",
        "categories": [
          "news",
          "ai-assistant"
        ],
        "isoDate": "2025-04-17T12:53:15.000Z"
      },
      {
        "creator": "Alyona Chernyaeva",
        "title": "Smarter Kotlin Development With JetBrains AI: Junie and AI Assistant in IntelliJ IDEA",
        "link": "https://blog.jetbrains.com/kotlin/2025/04/smarter-kotlin-development-with-jetbrains-ai-junie-and-ai-assistant-in-your-ide/",
        "pubDate": "Thu, 17 Apr 2025 12:32:26 +0000",
        "content:encodedSnippet": "JetBrains AI is now a lot more useful for Kotlin developers. With the public release of Junie and a major update to AI Assistant, two powerful AI tools are now deeply integrated with JetBrains IDEs – and ready to help you move faster with less overhead.\nWhether you’re starting a new feature or cleaning up existing code, these tools are built to provide support where you already work.\nJunie: The coding agent that speaks Kotlin\nImagine that you need to start a project from scratch or add a new module or feature to an existing project, or maybe you need to perform a small and repetitive – yet still significant – task. \nJunie can help you in all of these scenarios!\nIt doesn’t just autocomplete lines or chat about your code – Junie can actually take on whole tasks. Just describe what you want to achieve in plain language, and Junie will write the code, iterate on it, and handle any follow-ups. You stay in control, but Junie takes care of the repetitive work!\nWhat you can do with Junie\nJunie can handle a wide range of Kotlin development tasks. Whether you’re working with server-side Kotlin, Ktor, KMP, or Android, you can rely on Junie for practical help with common tasks like:\nStarting a new project from scratch.\nPrototyping. \nImplementing entire modules based on descriptions.\nEnd-to-end feature development.\nIntegrating third-party services.\nGenerating basic UIs from specifications.\nYou can also customize how Junie works by adding a .junie/guidelines.md file to your project. There, you can define project-specific rules – like what database to use or how tests should be structured – and Junie will take that into account when generating code.\n\n\n🎥 Watch how Junie handles full-stack Kotlin tasks\n\n\n\nJetBrains AI Assistant: Smarter help every day\nIf Junie is your project collaborator, AI Assistant is your day-to-day companion. It adds context-aware intelligence throughout the development workflow: writing code, generating tests, explaining errors, and even managing version control tasks.\nKotlin support is a key part of AI Assistant’s design. Completion suggestions are powered by JetBrains’ own LLM, Mellum, which is tuned specifically for development tasks, with refinements for Kotlin. You can also choose between local and cloud models, depending on your preferences.\nFor Kotlin developers, it’s especially useful when:\nConverting Java code to Kotlin.\nModifying Gradle build files.\nFilling in missing functions or classes.\nWriting multiplatform boilerplate.\n\n\n🎥 See AI Assistant in action for Kotlin development\n\n\n\nKotlin and AI: A good match\nAI tools tend to perform better with languages that offer structure and clarity. Kotlin is a prime example of such a language. It’s concise, expressive, and statically typed.\nHere’s why Kotlin is perfectly suited to work with JetBrains AI:\nMore reliable results: Kotlin code quality is one of the key metrics we track, and AI-generated Kotlin consistently performs well in tests.\nCleaner input: Kotlin’s compact syntax keeps prompts short and easy for models to process.\nBetter context: Static typing and clear structure help AI make more accurate suggestions.\nActively supported: Kotlin is part of JetBrains’ own AI test suite, so the tools are continuously validated against real Kotlin projects.\nThe result? AI that’s not just compatible with Kotlin but also produces reliable and efficient results. \nTry it out\nJunie and AI Assistant are available in IntelliJ IDEA Ultimate and other JetBrains IDEs.\nJust enable the JetBrains AI plugin, open the tool windows, and start exploring. You can work with either local or cloud-based models.\nJetBrains AI Assistant is supported in Android Studio, but Junie is not available there yet. We’re working on expanding support in the future.\nTo use Junie and AI Assistant, you’ll need a JetBrains IDE with an active subscription.\nJetBrains AI is now available in Free, Pro, and Ultimate tiers, with different monthly credit quotas. All new users start with a 30-day AI Pro trial.\nHere’s what you get with an active subscription:\nUnlimited local code completions\nAccess to local models\nMonthly cloud credits for AI Assistant and Junie (amount depends on tier)\n\n\n\n\n\nFor more details, see the JetBrains AI page.\nWhat else to read and watch\nJetBrains IDEs Go AI: Coding Agent, Smarter Assistance, Free Tier\nAI-Friendly Programming Languages: the Kotlin Story\nOpenAI vs. DeepSeek: Which AI Understands Kotlin Better?\nBuilding MCP with Kotlin: Claude Desktop Controls My Smart Home Lights!",
        "dc:creator": "Alyona Chernyaeva",
        "content": "JetBrains AI is now a lot more useful for Kotlin developers. With the public release of Junie and a major update to AI Assistant, two powerful AI tools are now deeply integrated with JetBrains IDEs – and ready to help you move faster with less overhead. Whether you&#8217;re starting a new feature or cleaning up [&#8230;]",
        "contentSnippet": "JetBrains AI is now a lot more useful for Kotlin developers. With the public release of Junie and a major update to AI Assistant, two powerful AI tools are now deeply integrated with JetBrains IDEs – and ready to help you move faster with less overhead. Whether you’re starting a new feature or cleaning up […]",
        "guid": "https://blog.jetbrains.com/?post_type=kotlin&p=562126",
        "isoDate": "2025-04-17T12:32:26.000Z"
      },
      {
        "creator": "Olga Bedrina",
        "title": "TeamCity Pipelines Pulse: Enhanced Notification Options",
        "link": "https://blog.jetbrains.com/teamcity/2025/04/teamcity-pipelines-pulse-enhanced-notification-options/",
        "pubDate": "Thu, 17 Apr 2025 10:42:45 +0000",
        "content:encodedSnippet": "In this TeamCity Pipelines release, we’re focusing on improving the user experience with more flexible notification options.\nYou can now choose which specific email notifications you want to receive from the system. You can select between default or custom notification options or unsubscribe from everything.\n\n\n\n\nThe following options are available for custom notifications:\nOnly get notified when a pipeline with your changes runs.\nGet notified when a pipeline fails, is successful, has started, or has failed to start.\nTo change your notification options, click the Subscribe button in the pipeline that you’d like to stay informed about. Then choose the necessary notification options.\n\n\n\n\nYou can also unsubscribe from any notifications for a specific pipeline and stay up to date on only what’s important to you.\nBug fixes and improvements\nIn addition to the new features, we’ve also fixed some bugs and made a few other improvements in TeamCity Pipelines. \nError messages in TeamCity Pipelines are now written in clear, natural language, making them easier to understand.\nThe appearance of the agent overview page has been improved with proper spacing between paragraphs.\nThat’s it for now! As always, feel free to reach out to us by leaving a comment to this post. We’ll be happy to hear from you.",
        "dc:creator": "Olga Bedrina",
        "content": "In this TeamCity Pipelines release, we’re focusing on improving the user experience with more flexible notification options. You can now choose which specific email notifications you want to receive from the system. You can select between default or custom notification options or unsubscribe from everything. The following options are available for custom notifications: To change [&#8230;]",
        "contentSnippet": "In this TeamCity Pipelines release, we’re focusing on improving the user experience with more flexible notification options. You can now choose which specific email notifications you want to receive from the system. You can select between default or custom notification options or unsubscribe from everything. The following options are available for custom notifications: To change […]",
        "guid": "https://blog.jetbrains.com/?post_type=teamcity&p=562063",
        "categories": [
          "news",
          "releases",
          "release",
          "teamcity-pipelines",
          "teamcity-pipelines-pulse"
        ],
        "isoDate": "2025-04-17T10:42:45.000Z"
      },
      {
        "creator": "Kerry Beetge",
        "title": "Big News! JetBrains Qodana’s Code Quality Plugin Is Now Available for Visual Studio",
        "link": "https://blog.jetbrains.com/qodana/2025/04/visual-studio-plugin/",
        "pubDate": "Wed, 16 Apr 2025 15:24:15 +0000",
        "content:encodedSnippet": "It’s no secret that Qodana is a team tool that JetBrains designed to integrate seamlessly with its suite of IDEs, but every team and tech stack is different. One common question remains: “What about other members of our team who still use VS Code or Visual Studio?” To help with this problem, we decided to provide a more integrated offering that can truly bolster code quality for the average development team.\nWe already have a VS Code extension, so it was time to get to work on a Visual Studio version. The team has now completed this task, and you can now download Qodana’s code quality plugin for Visual Studio via the Resharper Installer. \nReSharper Installer\n\n\n\n\nPlug in and play – Why Try The Visual Studio Plugin for Quality?\n✓ Identify code issues, bugs, and vulnerabilities.\n✓ Run code analysis in your CI pipeline.\n✓ See issues in Visual Studio while you work.\n\n\n\n\nJoin the Qodana Community\nReach out to qodana-support@jetbrains.com or follow us on X and LinkedIn for code quality updates. You can also view the documentation for more information on the extension, what Qodana is capable of, and how static code analysis works.\nReSharper Installer",
        "dc:creator": "Kerry Beetge",
        "content": "It’s no secret that Qodana is a team tool that JetBrains designed to integrate seamlessly with its suite of IDEs, but every team and tech stack is different. One common question remains: “What about other members of our team who still use VS Code or Visual Studio?” To help with this problem, we decided to [&#8230;]",
        "contentSnippet": "It’s no secret that Qodana is a team tool that JetBrains designed to integrate seamlessly with its suite of IDEs, but every team and tech stack is different. One common question remains: “What about other members of our team who still use VS Code or Visual Studio?” To help with this problem, we decided to […]",
        "guid": "https://blog.jetbrains.com/?post_type=qodana&p=550905",
        "categories": [
          "plugin-highlights",
          "plugins",
          "qodana",
          "release",
          "visual-studio"
        ],
        "isoDate": "2025-04-16T15:24:15.000Z"
      },
      {
        "creator": "Dmitrii Korovin",
        "title": "TeamCity 2025.03.1 Bug Fix Is Now Available!",
        "link": "https://blog.jetbrains.com/teamcity/2025/04/teamcity-2025-03-1-bug-fix/",
        "pubDate": "Wed, 16 Apr 2025 14:00:08 +0000",
        "content:encodedSnippet": "The first bug-fix update for version 2025.03, TeamCity On-Premises 2025.03.1, is out and ready to be installed on your servers! This update ships around 30 bug fixes, performance enhancements, and security patches. We highly recommend upgrading to keep your system secure and optimized. The list of resolved issues includes:\nInfinite scrolling in custom reports;\nIssues related to Git LFS;\nMissing “Docker Info” tab;\nFlicking project pages, and more.\nSee TeamCity 2025.03.1 Upgrade Notes for the complete list.\nWhy update?\nStaying up to date with minor releases ensures your TeamCity instance benefits from the following:\nPerformance improvements.\nBetter compatibility with integrations.\nFaster, more stable builds.\nEnhanced security for your workflows.\nCompatibility\nTeamCity 2025.03.1 shares the same data format as all 2025.03.x releases. You can upgrade or downgrade within this series without the need for backup and restoration.\nHow to upgrade\nUse the automatic update feature in your current TeamCity version.\nDownload the latest version directly from the JetBrains website.\nPull the updated TeamCity Docker image.\nNeed help?\nThank you for reporting issues and providing feedback! If you have questions or run into any problems, please let us know via the TeamCity Forum or Issue Tracker.\nHappy building!",
        "dc:creator": "Dmitrii Korovin",
        "content": "The first bug-fix update for version 2025.03, TeamCity On-Premises 2025.03.1, is out and ready to be installed on your servers! This update ships around 30 bug fixes, performance enhancements, and security patches. We highly recommend upgrading to keep your system secure and optimized. The list of resolved issues includes: See TeamCity 2025.03.1 Upgrade Notes for [&#8230;]",
        "contentSnippet": "The first bug-fix update for version 2025.03, TeamCity On-Premises 2025.03.1, is out and ready to be installed on your servers! This update ships around 30 bug fixes, performance enhancements, and security patches. We highly recommend upgrading to keep your system secure and optimized. The list of resolved issues includes: See TeamCity 2025.03.1 Upgrade Notes for […]",
        "guid": "https://blog.jetbrains.com/?post_type=teamcity&p=560679",
        "categories": [
          "bug-fix"
        ],
        "isoDate": "2025-04-16T14:00:08.000Z"
      },
      {
        "creator": "Evgenia Verbina",
        "title": "PyCharm 2025.1: Unified PyCharm, Free AI Tier, Junie Release, and More!",
        "link": "https://blog.jetbrains.com/pycharm/2025/04/pycharm-2025-1/",
        "pubDate": "Wed, 16 Apr 2025 13:58:00 +0000",
        "content:encodedSnippet": "PyCharm 2025.1 brings major updates to improve your development experience.\nPyCharm is now a unified product, combining PyCharm Professional and Community Edition. Version 2025.1 also brings a free AI tier, the public release of Junie, the launch of Cadence, significant Jupyter enhancements, support for Hatch, Data Wrangler, and many other improvements.\nGet the latest version from our download page or update through our free Toolbox App. \nDownload now\n                                                    \nRead this blog post to learn more about the updates. \nPrefer video? Get an overview of the major news and improvements in this video:\n\n\n\n\n\n\nPyCharm is now one powerful, unified product!\nPyCharm is now one powerful, unified product! Its core functionality, including Jupyter Notebook support, will be free, and a Pro subscription with additional features will be available. \nStarting with the 2025.1 release, every user will get instant access to a free one-month Pro trial, so you’ll be able to access all of PyCharm’s advanced features right away. After the trial, you can choose whether to continue with a Pro subscription or keep using the core features for free. Learn more about the change in this blog post.\nJunie – your personal coding agent Pro\nJunie, the coding agent by JetBrains, is now available in PyCharm via JetBrains AI. Junie autonomously plans, writes, refines, and tests code to make your development experience smooth, efficient, and enjoyable. It handles tedious tasks like restructuring code, creating tests, and implementing refinements, so you can focus on bigger challenges and innovation. \n\n\n\n\nPyCharm goes AI\nJetBrains AI has received a major upgrade, bringing both AI Assistant and the coding agent Junie under a single subscription. With this release, all JetBrains AI features are accessible for free in PyCharm Pro, with unlimited use for some, such as code completion and local model support, and limited credit-based access to others. \n\n\n\n\nWe’re also introducing a new subscription system that makes it easy to scale up as needed with the AI Pro and AI Ultimate tiers. Other highlights of this release include smarter completion, advanced context awareness, and support for Claude 3.7 Sonnet and Gemini 2.0 Flash. Head to the What’s New page to learn more about the latest AI features.\nCadence – effortless cloud execution for ML workflows Pro\nWe’re introducing Cadence. You can now run your machine learning code on powerful cloud hardware directly from PyCharm in minutes – no complex setup or cloud expertise is required. The Cadence plugin simplifies ML workflows, allowing you to focus on your code while leveraging scalable computing resources. \n\n\n\n\n\n\nData Wrangler Pro\nWe’ve implemented Data Wrangler, a powerful tool to help Python data professionals streamline data manipulation and focus on higher-level analysis. Use the interactive UI to perform common dataframe transformations – like filtering, cleaning, handling outliers, and more – without writing repetitive code. \nYou can view and explore column statistics, generate Python code for transformations automatically, track the history of changes, export data easily, and insert transformations as new cells in your notebook.\n\n\n\n\nSQL cells in notebooks Pro\nPyCharm 2025.1 introduces SQL cells. This new cell type allows you to query databases, dataframes, and attached CSV files in Jupyter notebooks and automatically save query results to pandas DataFrames.\n\n\n\n\nWe’ve also introduced many other improvements to enhance the Jupyter notebook experience. Learn more about them in the What’s New.\nSupport for Hatch\nWe’re introducing support for Hatch, a modern and extensible Python project manager from the Python Packaging Authority (PyPA). Hatch can automatically migrate setuptools configurations, create isolated environments, and run and publish builds, making Python package management more efficient. \n\n\n\n\nPyCharm also allows you to create new projects managed by Hatch. The IDE will automatically recognize Hatch projects when they are imported from a local machine or a remote source.\nDownload now\n                                                    \nLooking for more?\nVisit our What’s New page to learn about other 2025.1 features and the latest bug fixes.\nRead the release notes for the full breakdown of the changes.\nIf you encounter any problems, please report them via our issue tracker so we can address them promptly.\nWe’d love to hear your feedback on PyCharm 2025.1 – leave your comments below or connect with us on X.",
        "dc:creator": "Evgenia Verbina",
        "content": "PyCharm 2025.1 brings major updates to improve your development experience. PyCharm is now a unified product, combining PyCharm Professional and Community Edition. Version 2025.1 also brings a free AI tier, the public release of Junie, the launch of Cadence, significant Jupyter enhancements, support for Hatch, Data Wrangler, and many other improvements. Get the latest version [&#8230;]",
        "contentSnippet": "PyCharm 2025.1 brings major updates to improve your development experience. PyCharm is now a unified product, combining PyCharm Professional and Community Edition. Version 2025.1 also brings a free AI tier, the public release of Junie, the launch of Cadence, significant Jupyter enhancements, support for Hatch, Data Wrangler, and many other improvements. Get the latest version […]",
        "guid": "https://blog.jetbrains.com/?post_type=pycharm&p=559287",
        "isoDate": "2025-04-16T13:58:00.000Z"
      },
      {
        "creator": "Stanislav Garkusha",
        "title": "DataSpell 2025.1: JetBrains Data Wrangler AI Agent, No-Code Data Preparation Flow, AI Quick Charts, and More!",
        "link": "https://blog.jetbrains.com/dataspell/2025/04/dataspell-2025-1-jetbrains-data-wrangler-ai-agent-no-code-data-preparation-flow-ai-quick-charts-and-more/",
        "pubDate": "Wed, 16 Apr 2025 13:18:50 +0000",
        "content:encodedSnippet": "We’re thrilled to introduce DataSpell 2025.1, the first major release of 2025. This update focuses on making data cleaning and preparation more intuitive and efficient than ever before. \n\n\n\n\n\n\n\nDownload DataSpell 2025.1 \nJetBrains Data Wrangler AI agent\nWith Data Wrangler, you can choose between a no-code flow or full AI automation. Easily toggle between:\nAI chat interaction: Ask AI to analyze your data, and it will suggest transformations you can apply with a single click.\n\n\n\n\n\nNo-code UI: For those who prefer a hands-on approach, work with the Data tool window or table data viewer to start data transformations without writing a line of code.\n\n\n\n\n\nOnce your data is ready, export the transformations in various formats or as code for future use.\n\n\n\n\nNo-code flow for data preparation\nOur new Data tool window consolidates database connections, data warehouse links, and attached files so you can manage them all in one place. The Data Preview pane ensures you’re always working with exactly the data you need, while the no-code import cell makes it even easier to bring new files into your notebooks.\n\n\n\n\nEnhanced Jupyter notebooks features\nWe’ve upgraded the Jupyter experience with:\nImproved debugger: Includes Run to caret and automatic line-by-line debugging for cells without breakpoints.\n\n\n\n\nVisual enhancements: Drag and drop to reorder cells, easily commit notebooks without outputs, enjoy new color options for backgrounds, and get a clearer Markdown editing experience.\n\n\n\n\nKernel management: Shut down kernels right from the main toolbar.\n\n\n\n\nAI quick charts for tables Generate chart previews with a single click. AI Assistant uses dataframe metadata to suggest visualizations, which appear directly in the table’s widget. Accept a suggestion and instantly insert the chart code into your notebook.\nAI Assistant updates\nAI Assistant now also supports more cutting-edge LLMs.\n\n\n\n\n\nWeb search: Use the /web command in AI Assistant to fetch documentation and troubleshooting resources without leaving your IDE. \n\n\n\n\nIf you’re interested in upgrading to DataSpell 2025.1, or if you have any questions or suggestions, here are a few links you might find useful:\nDownload DataSpell 2025.1.\nVisit our What’s New page for the full list of improvements.\nContact us on X.\nReport any bugs to our issue tracker.\nWe hope you enjoy this release and look forward to hearing your feedback!\nThe DataSpell team",
        "dc:creator": "Stanislav Garkusha",
        "content": "We’re thrilled to introduce DataSpell 2025.1, the first major release of 2025. This update focuses on making data cleaning and preparation more intuitive and efficient than ever before. Download DataSpell 2025.1 JetBrains Data Wrangler AI agent With Data Wrangler, you can choose between a no-code flow or full AI automation. Easily toggle between: No-code flow [&#8230;]",
        "contentSnippet": "We’re thrilled to introduce DataSpell 2025.1, the first major release of 2025. This update focuses on making data cleaning and preparation more intuitive and efficient than ever before. Download DataSpell 2025.1 JetBrains Data Wrangler AI agent With Data Wrangler, you can choose between a no-code flow or full AI automation. Easily toggle between: No-code flow […]",
        "guid": "https://blog.jetbrains.com/?post_type=dataspell&p=559834",
        "isoDate": "2025-04-16T13:18:50.000Z"
      },
      {
        "creator": "Hanna Yakush",
        "title": "PhpStorm 2025.1 Is Now Available",
        "link": "https://blog.jetbrains.com/phpstorm/2025/04/phpstorm-2025-1-is-now-available/",
        "pubDate": "Wed, 16 Apr 2025 13:18:22 +0000",
        "content:encodedSnippet": "This release is a major update that includes improvements in PHPStan annotations, Xdebug, and WordPress  support, an AI Free tier and new subscription system for JetBrains AI, and more.\nDownload PhpStorm 2025.1\n\n\n\n\nPHP\nCode completion for @phpstan-type and @phpstan-import-type \nThis release improves PhpStorm’s PHPStan annotation support, introducing code completion for array shape aliases in @phpstan-type and @phpstan-import-type. Using the local type aliases defined in PHPDoc’s @phpstan-type annotation (or referenced in the @phpstan-import-type annotation), the IDE autocompletes array keys in class bodies.\n\n\n\n\nSupport for nested variables in .env files\nVersion 2025.1 extends PhpStorm’s .env file support to include nested variables syntax. Code completion, navigation between declarations and usages, inspections, and quick-fixes now also work for environment variables wrapped in ${…}.\n\n\n\n\nDebugging\nOption to install Xdebug from the CLI Interpreters window\nPhpStorm simplifies Xdebug setup in many ways, including by detecting when the debugger is not installed for the PHP interpreter that’s in use. If Xdebug is missing, in PhpStorm 2025.1, you can have it downloaded and installed automatically right from the CLI Interpreters dialog. \n\n\n\n\nXdebug Helper browser extension now maintained by JetBrains\nJetBrains has teamed up with Fraser Chapman to publish and maintain an official Xdebug toggler for Chrome and Firefox browsers. The Xdebug Helper by JetBrains extension is open source and developed by Fraser, but committing to its testing and release allows us to make sure you are provided with reliable tools for interruption-free debugging.\nWordPress\nWordPress support on project startup\nIn order to provide support for WordPress projects, PhpStorm needs to know the path to the WordPress core installation on your machine. While you were previously prompted to specify this path manually on project startup, starting with version 2025.1, PhpStorm attempts to discover the path and automatically enables support for the WordPress framework.\n\n\n\n\nIf it’s unable to detect the path, the IDE will open the PHP | Frameworks settings page so you can provide the required information.\nJetBrains AI\nAlongside PhpStorm, JetBrains AI Assistant has received a major update. Now, all JetBrains AI features are available for free in PhpStorm and other JetBrains IDEs, offering unlimited access to code completion and local model support, with credit-based limits for other features.\nWe’re also introducing a new subscription system that makes it easy to scale up as needed with the AI Pro and AI Ultimate tiers.\nLearn more\n\n\n\n\n\n\nExpanded selection of LLMs in chat\nThe AI model selection in the chat has just been expanded! Now, you can take full control of your AI experience by choosing from the latest and most advanced language models, including Claude 3.7 Sonnet and Gemini 2.0 Flash.\n\n\n\n\nAnd we’re not stopping here! JetBrains is committed to continuously integrating AI models to ensure you have access to the most up-to-date AI technologies.\nImproved context awareness in chat\nLocal and cloud LLMs can now leverage PhpStorm’s indexing data on the PHP methods used in your project. This allows AI Assistant to improve the quality and relevance of code snippets generated in the chat.\nOffline mode: Work with local models\nAI Assistant gives you the flexibility to work with local models offline or leverage cloud-based AI processing. With the new offline mode, you can now work without an internet connection while still benefiting from AI-powered coding assistance. Use local models via Ollama or LM Studio for chat, code generation, commit messages, inline documentation, and more.\n\n\n\n\nMulti-file changes in edit mode Beta\nEditing multiple files has never been easier! AI Assistant now supports multi-file edits in the chat, suggesting changes across your project while leveraging retrieval-augmented generation (RAG) to locate the most relevant files. Reduce repetitive tasks and implement modifications across multiple files with a single interaction.\n\n\n\n\nApply snippets from chat\nNow, when the AI chat suggests a code snippet, you can use the Apply button to automatically find the optimal place to insert the newly generated code – no more manual copy-pasting. This feature significantly streamlines your workflow.\n\n\n\n\nSmarter AI context awareness\nAI Assistant now understands your entire project better, using advanced RAG to surface the most relevant files, methods, and classes. In addition, the context now includes recently accessed files, making interactions even more relevant to your workflow. Because you can now also add or remove attachments sent as context, you maintain full control over the AI’s context.\nExclude files from AI context\nYou can further enhance your control over what AI Assistant sees by configuring an .aiignore file. This allows you to prevent JetBrains AI from accessing specific files or folders, ensuring that sensitive information is never processed.\n\n\n\n\nWeb search from chat\nWith the new /web command, AI Assistant can now fetch documentation, troubleshooting tips, and the latest technical resources directly from the web – right inside your chat window. No more switching tabs or searching manually!\n\n\n\n\nAttached schemas in the Explain with AI chat\nExplanations are more effective when they use all the relevant context. Now, when you ask AI Assistant to explain a query, the corresponding schema is automatically attached to the chat.\n\nTry AI Assistant\nFrontend\nImproved Vue and Nuxt support\nPhpStorm now makes it easier to start new Vue projects with Nuxt CLI (nuxi) integration in the New Project wizard, allowing for a smoother setup experience.\nWe’ve also improved support for Vue’s global properties by correctly resolving custom properties added through module augmentation. Additionally, issues with autocomplete and auto-import for packaged components declared with __VLS_WithTemplateSlots have been fixed, ensuring a more reliable development experience in Vue projects.\n\n\n\n\nBetter monorepo support\nWorking in a monorepo just got smoother! PhpStorm now respects Prettier configs per subproject, offers smarter auto-imports and path alias resolution via improved exports handling, and delivers faster code completion and navigation in large Nx workspaces. Enjoy a more consistent and efficient coding experience across all your projects.\n\n\n\n\nUser experience\nNew terminal architecture Beta\nThe 2025.1 release introduces a reworked terminal architecture, which is available in Beta. The terminal now runs on a stable, standards-compliant core and uses the IDE’s editor to render the UI. This change lets us introduce new features while preserving compatibility and performance across various platforms, whether local or remote. Get more details about our plans and progress in this blog post.\n\n\n\n\nSearch functionality in Markdown previews\nIn PhpStorm 2025.1, you can search within Markdown previews. Since README.md previews are often the first thing you see when opening or cloning a project, this update makes it easier to find key information instantly.\n\n\n\n\nNative OS file dialogs on Windows \nPhpStorm now defaults to using native Windows file dialogs instead of the IDE’s custom implementation. This gives you a more familiar experience when opening or saving files. If you prefer the previous behavior, you can restore it in Advanced Settings | User Interface.\n\n\n\n\n\n\n\n\nCommit experience updates\nWe are refining the non-modal commit workflow, the default built-in option, in response to the extensive feedback we received during the Early Access Program. The modal commit interface is becoming a plugin, which can be activated in Settings | Advanced Settings | Version Control. Git. In version 2025.1, the plugin will be bundled with the IDE, so you’ll be able to continue using the interface without having to install it manually.",
        "dc:creator": "Hanna Yakush",
        "content": "This release is a major update that includes improvements in PHPStan annotations, Xdebug, and WordPress support, an AI Free tier and new subscription system for JetBrains AI, and more. Download PhpStorm 2025.1 PHP Code completion for @phpstan-type and @phpstan-import-type&#160; This release improves PhpStorm’s PHPStan annotation support, introducing code completion for array shape aliases in @phpstan-type [&#8230;]",
        "contentSnippet": "This release is a major update that includes improvements in PHPStan annotations, Xdebug, and WordPress support, an AI Free tier and new subscription system for JetBrains AI, and more. Download PhpStorm 2025.1 PHP Code completion for @phpstan-type and @phpstan-import-type  This release improves PhpStorm’s PHPStan annotation support, introducing code completion for array shape aliases in @phpstan-type […]",
        "guid": "https://blog.jetbrains.com/?post_type=phpstorm&p=558008",
        "categories": [
          "2025-1",
          "release"
        ],
        "isoDate": "2025-04-16T13:18:22.000Z"
      },
      {
        "creator": "Maciej Gorywoda",
        "title": "IntelliJ Scala Plugin 2025.1 Is Out!",
        "link": "https://blog.jetbrains.com/scala/2025/04/16/intellij-scala-plugin-2025-1-is-out/",
        "pubDate": "Wed, 16 Apr 2025 13:05:20 +0000",
        "content:encodedSnippet": "Support for new features in Scala 3\nContext Bounds and Givens\nScala 3.6 introduced a new syntax for context bounds and givens. You can read more about it in SIP-64. In short, before Scala 3.6, it was impossible to name the context bound in the same place where it was defined. The way to do it was to introduce an implicit parameter, which resulted in awkward syntax, e.g. def reduce[A](xs: List[A])(using m: Monoid[A]): A introduced the context bound Monoid[A] as m. In the new syntax, it’s possible to simply write def reduce[A: Monoid as m](xs: List[A]): A and IntelliJ IDEA with the Scala plugin recognizes it and supports it.\nIn a similar vein, we now support the recent changes in the given syntax.\nThree old ways to declare and name a context bound vs the new syntax\n\n\n\nMultiple context bounds\n\n\n\nSolving an old issue of a forward declaration of a context bound\n\n\n\n\nNamed Tuples\nScala 3.7 brings the stabilization of Named Tuples and IntelliJ IDEA 2025.1 with the Scala Plugin already supporting them. In the new release, apart from simply recognizing the syntax for Named Tuples, we also support them in pattern matching, when you can both match against a given value of one of the tuple’s fields, and extract that value to a new reference. On top of that, Scala 3.7 comes with a new way to extract a field value from a case class or a class with a customized unapply method that returns a named tuple. Until now, we could either use the underscore to mark all the fields we were not interested in when calling the unapply, or we could assign a whole class instance to a reference and then access the field we wanted through that reference.  Now, it’s possible as well to simply name the fields we are interested in and assign their values to new references.\nYou can read more about Named Tuples in SIP-58.\n\n\n\n\n\nRefutable patterns in for-comprehensions\nSince Scala 3.4, refutable patterns (i.e., patterns that might not match) in for-comprehensions must be preceded by the case keyword, or an error is reported. The new syntax helps recognize those cases.\n\n\n\n\n\nOther Scala 3 improvements\nThe resolution of nested implicit definitions is now more precise, which means that now Scala Plugin reports some errors that weren’t caught before, while in other situations we no longer highlight code red where the code compiles just fine. The handling of intersection types used to define the “self” type was improved, and the support for named tuples, that we introduced recently. Besides, the Scala 3 code is now correctly highlighted in code snippets in Markdown files displayed in IntelliJ IDEA.\n\n\n\n\nThe debugger\nWe fixed a bug in Scala 2.13.3 where the debugger didn’t stop on breakpoints inside lazy vals in try/catch blocks, and another, similar, when the debugger sometimes had trouble stopping at breakpoints inside lambdas in a trait.\n\n\n\n\n\nsbt\nWe made several improvements to the new separate production/test modules. A new “Generate sbt managed sources” action helps avoid situations when good code is red because it relies on sources generated during the project import. On top of that, the “New Project” wizard now suggests downloading the JDK for a new sbt project, and we don’t show anymore the banner “No Scala SDK in module” when at the same time we offer to simply load the sbt project, which will automatically setup SDK.\n\n\n\n\n\nCode highlighting and inlay hints\nIn the 2024.3 release, we introduced support for transparent inline methods in Scala 3. Now, as we continue to work on support for Scala macros, we offer support for Scala 2 macro types. Also, we improved type hints for variable patterns, generators, and literal parameters, as well as type info for underscore parameters and kind projector syntax. The X-Ray mode was enhanced as well: you can now enable parameter name hints for all parameters, not only literals, and see when the apply method is being used, instead of an ordinary constructor.\n\n\n\n\n\nOther changes\nCode completion can now provide partial results during indexing. Besides, when you use Code With Me for Scala projects, we fixed an issue when you would see that the auto-import quick-fix is offered only after code editing on the host.\n\n\n\n\nAs always, your feedback is very welcome. Please report any issues you find to YouTrack. If you have any questions, feel free to ask us on Discord.\nHappy developing!\nThe IntelliJ Scala Plugin team",
        "dc:creator": "Maciej Gorywoda",
        "content": "Support for new features in Scala 3 Context Bounds and Givens Scala 3.6 introduced a new syntax for context bounds and givens. You can read more about it in SIP-64. In short, before Scala 3.6, it was impossible to name the context bound in the same place where it was defined. The way to do [&#8230;]",
        "contentSnippet": "Support for new features in Scala 3 Context Bounds and Givens Scala 3.6 introduced a new syntax for context bounds and givens. You can read more about it in SIP-64. In short, before Scala 3.6, it was impossible to name the context bound in the same place where it was defined. The way to do […]",
        "guid": "https://blog.jetbrains.com/?post_type=scala&p=558039",
        "categories": [
          "news",
          "releases",
          "scala",
          "scala-programming",
          "intellij-idea"
        ],
        "isoDate": "2025-04-16T13:05:20.000Z"
      },
      {
        "creator": "Oleg Zinovyev",
        "title": "CLion 2025.1 Arrives With Support for Out-of-Project Files in CLion Nova, Qt Renderers, the ST-LINK Debug Server, and West Build Options",
        "link": "https://blog.jetbrains.com/clion/2025/04/clion-2025-1-release/",
        "pubDate": "Wed, 16 Apr 2025 12:36:35 +0000",
        "content:encodedSnippet": "CLion 2025.1 is now available. This latest version of the JetBrains IDE for C and C++ includes the following key features:\nSupport for out-of-project files when using the CLion Nova engine.\nQt renderers in the debugger.\nThe ST-LINK debug server designed for STM32 chips.\nwest build command options and sysbuild for Zephyr projects.\nA free tier and new features for AI Assistant.\n\n\n\n\nYou can download CLion 2025.1 from the link below, via the Toolbox App, as a snap package if you’re using Ubuntu, or via a patch update from version 2024.3.\nDOWNLOAD CLION 2025.1\nCLion Nova\nIn this release, CLion Nova has received some of the most requested features, including support for out-of-project files, multiple settings, actions, and smart keys, and basic Objective-C support.\nOut-of-project files\nCLion Nova now provides full code analysis and code assistance for header and source files that are not included in a project. For example, when you open an out-of-project .cpp file just to edit it, you get all of the essential features, such as code formatting, code completion, and typing assistance.\n\n                        \n\n\nThe current implementation covers most of the known use cases. However, there are some edge cases we plan to address after receiving feedback.\nBasic support for Objective-C\nYou can now get syntax highlighting, code completion suggestions, warnings, and other editor features when working with Objective-C source files. Header files, however, may not be handled correctly, and some features, including refactorings and smart keys, may not work.\n\n\n\n\nIf you need the same Objective-C support in CLion Nova that you get in CLion Classic, please follow or upvote CPP-37281.\nSettings, actions, and smart keys\nCLion Nova has gained several settings, actions, and smart keys that were previously exclusive to CLion Classic, making development with the new language engine even more convenient. Here are just a few examples:\nThe Auto import local files with quotes and Auto import on completion options. (You can learn more about configuring auto-import in the documentation.)\nMove to Code Block End and Move to Code Block Start – ⌘⌥] (macOS) or Ctrl+] (Windows or Linux) and ⌘⌥ [ (macOS) or Ctrl+[ (Windows or Linux), respectively.\nThe Surround selection on typing quote or brace and Unindent on Backspace smart keys – ⌫ (macOS) or Backspace (Windows or Linux).\n\n\n\n\nRead our documentation to learn more about all of the available actions and smart keys, as well as their shortcuts.\nGoogleTest and Catch2 support in Bazel projects\nCLion Nova now supports the GoogleTest and Catch2 testing frameworks in Bazel projects. However, there are still some limitations.\nTo learn more about the basics of unit testing and how to use testing tools in CLion, read our documentation.\nDebugger\nUpdates for the debugger include Qt renderers for user-friendly data representation when debugging Qt applications, support for custom LLDB debuggers and custom locations for .natvis files, and the ability to view two-channel OpenCV matrices as images.\nQt renderers\nQt renderers, also known as Qt pretty printers and Qt debugging helpers, allow you to view variables, such as QList, QString, or QByteArray, in a human-readable form. This simplifies the development and debugging of applications built using the Qt framework.\n\n\n\n\nThis feature is enabled by default, but to use it, you need to download the Qt renderers and specify the path to them:\nGo to Settings | Build, Execution, Deployment | Debugger | Data Views | C/C++ and find the Renderers section.\nClick Download… next to the Path to a directory with Qt renderers field. \nClick Download Qt Renderers in the window that appears. The path will be specified automatically.\n\n\n\n\nNote that Qt renderers don’t yet work with remote and WSL toolchains.\nSupport for custom LLDB debuggers\nIn addition to the bundled LLDB, which is currently v19.1.3, you can now use a custom LLDB when working on macOS or Linux. This allows you to choose the version best suited to the requirements of your project.\nYou can select a custom LLDB in Settings | Toolchains | Debugger. CLion will then automatically try to find the custom LLDB installed on your system. You can also manually specify its location.\n\n\n\n\nNote that custom LLDBs don’t yet work with WSL, Docker, or Remote Host toolchains and are not currently available for Windows.\nAbility to view two-channel OpenCV matrices as images\nWhen debugging an ML or computer vision application that uses OpenCV, you can now view two-channel matrices – such as cv::Mat m(2, 3, CV_8UC2) – as images.\n\n                        \n\n\nTo do this, select the Threads & Variables pane of the debugger when your program is suspended at a breakpoint, navigate to the two-channel matrix, and click View as image.\nCustom location for .natvis files\nNatvis renderers, also known as Natvis visualizers, allow you to define visualization rules for various data types when using the MSVC debugger. Previously, CLion’s functionality was limited to loading .natvis files solely from the project directory. This was a challenge in terms of flexibility, particularly when working with Git or other VCSs. The latest update introduces the ability to specify a custom location for your .natvis files, improving versatility and convenience.\nYou can add an additional directory with Natvis renderers in Settings | Build, Execution, Deployment | Debugger | Data Views | C/C++.\n\n\n\n\nEmbedded development\nEnhancements for embedded development include a new ST-LINK debug server configuration option, the updated STM32CubeMX New Project wizard, and improvements to the Serial Port Monitor plugin.\nST-LINK debug server experimental\nWhen debugging STM32 projects, you can now use the ST-LINK debug server template, which was designed specifically for STM32 chips. It includes only the essential settings, simplifying the configuration process.\nTo try the ST-LINK template, go to Settings | Build, Execution, Deployment | Debugger | Debug Servers and click +. Then, configure your GDB server, device, and debugger parameters in the corresponding tabs.\n\n\n\n\nNote that the ST-LINK configuration option currently only works with:\nThe ST-LINK GDB server shipped with STM32CubeCLT and STM32CubeIDE.\nSingle and dual-core MCUs.\nST-LINK/V2 and ST-LINK/V3 probes.\nSTM32CubeMX New Project wizard\nThe process of creating STM32CubeMX projects has been updated to improve usability and extend support to a broader range of STM32 chips and projects. CLion now uses the native STM32CubeMX approach to generate CMake files. This ensures that project creation is fully aligned with the official STM32CubeMX workflow and toolchain.\n\n                        \n\n\nWhen you open the New Project wizard and select STM32CubeMX, you’ll find detailed instructions on creating an STM32CubeMX project, including information about the actions you need to perform in STM32CubeMX.\nWe realize that the current approach to STM32CubeMX project creation is still not ideal, and we welcome your feedback as we continue to improve (CPP-42553).\nSerial Port Monitor plugin improvements\nYou can now view and manage the DTR, DSR, RTS, and CTS hardware control signals when working with the Serial Port Monitor plugin. This gives you more control over attached devices that use a serial port such as ESP32 and Arduino.\nTo enable hardware control signals:\nIn the Serial Connections tool window, navigate to the Connect tab.\nSelect the desired COM port.\nClick Show HW controls.\n\n\n\n\nThe control options and indicators will then appear in the COM port tab.\n\n\n\n\nIn the same tool window, you can also enable timestamps to view them in the monitor output. This option is handy for tracking message sequences in detail when troubleshooting.\n\n\n\n\nProject formats and build tools\nAs part of our efforts to improve Zephyr West support, this release introduces the ability to use the west build command options and sysbuild. We’ve also updated the bundled CMake to v3.31.4, which includes support for CMake Presets v10.\nwest build options and sysbuild support\nIf you’re working with Zephyr West projects, you can now use the west build command options, as well as sysbuild as your primary build system. This gives you more flexibility when it comes to configuring your projects, including those involving hardware.\nYou can pass the west build command options from Settings | Build, Execution, Deployment | Embedded Development | West | Advanced Settings.\nSysbuild is a build system that allows you to build multiple images for boards with multiple SoCs (systems on chip) or SoCs with multiple CPU cores. To enable it, pass –sysbuild along with any other options you want from the same Advanced Settings section.\n\n\n\n\nCMake Presets v10\nThe bundled CMake version has been updated to v3.31.4 and includes support for CMake Presets v10. Presets are stored as JSON files and are useful when you want to specify common configurations and build options for a CMake project, for example, to share them with your teammates.\nBazel plugin updates\nOur Bazel plugin has received two of its most requested features: \nSupport for Windows.\nSupport for custom toolchains, such as those based on GCC, LLVM, and MSVC.\n\n\n\n\nThese enhancements allow you to use different toolchain configurations across platforms, making it easier to develop a wide range of projects, including automotive and embedded ones.\nRead our blog post to learn how to configure your Windows machine for C/C++ development with Bazel, import a Bazel project into CLion, and set up a custom toolchain.\nFree tier and other AI Assistant updates\nAll AI Assistant features are now free in CLion and other JetBrains IDEs, which makes AI-powered development more accessible and efficient. New AI features include the ability to handle natural language prompts for C/C++ and a new edit mode for multi-file edits directly from the chat.\nFree tier\nAI Assistant features are now free. Some of them, such as unlimited code completion and local model support, are completely unlimited, while others have limited credit-based access. A new subscription system makes it easy to scale up as needed with the AI Pro and AI Ultimate tiers.\nNew cloud models and functionality\nAI Assistant has received enhancements that increase productivity and reduce repetitive tasks, such as support for new cloud models like Claude 3.7 Sonnet and Gemini 2.0 Flash, smarter code completion, and a new edit mode for multi-file edits directly from the chat.\nAI Assistant also has learned to understand natural language prompts for C/C++. After you write a prompt and press Tab, AI Assistant interprets it and translates it into code changes, taking your project’s context into consideration.\n\n                        \n\n\nTry CLion and give us your feedback\nWe invite you to give CLion 2025.1 a try. If you have an active subscription, you can update it right away. New to CLion? Start your free 30-day trial today and dive into all its features and improvements immediately.\nWe value your feedback! If you have anything to share or if you run into any problems, please let us know through our issue tracker.\nDOWNLOAD CLION 2025.1\nYour CLion team\nJetBrains\nThe Drive to Develop",
        "dc:creator": "Oleg Zinovyev",
        "content": "CLion 2025.1 is now available. This latest version of the JetBrains IDE for C and C++ includes the following key features: You can download CLion 2025.1 from the link below, via the Toolbox App, as a snap package if you’re using Ubuntu, or via a patch update from version 2024.3. DOWNLOAD CLION 2025.1 CLion Nova [&#8230;]",
        "contentSnippet": "CLion 2025.1 is now available. This latest version of the JetBrains IDE for C and C++ includes the following key features: You can download CLion 2025.1 from the link below, via the Toolbox App, as a snap package if you’re using Ubuntu, or via a patch update from version 2024.3. DOWNLOAD CLION 2025.1 CLion Nova […]",
        "guid": "https://blog.jetbrains.com/?post_type=clion&p=557748",
        "categories": [
          "news",
          "releases",
          "bazel",
          "clionnova",
          "embedded",
          "opencv",
          "qt",
          "release",
          "stm32",
          "zephyr-west"
        ],
        "isoDate": "2025-04-16T12:36:35.000Z"
      }
    ]
  },
  {
    "name": "Visual Studio Blog",
    "category": "기업",
    "posts": [
      {
        "creator": "Merrie McGaw, Shyam Gupta",
        "title": "Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer",
        "link": "https://devblogs.microsoft.com/visualstudio/toolbox-support-for-explicit-assembly-references-in-windows-forms-out-of-process-designer/",
        "pubDate": "Thu, 17 Apr 2025 14:45:27 +0000",
        "content:encodedSnippet": "Visual Studio 17.14 Preview 3 introduces a new feature that enhances the Windows Forms out-of-process designer experience for .NET Framework projects. This release brings Toolbox support for Explicit Assembly References, addressing a long-standing need in legacy application development and migration workflows.\n\nWhat Are Explicit Assembly References?\nExplicit Assembly References are stand-alone assemblies directly referenced in your project. They are not pulled in through NuGet packages, project references, or the Global Assembly Cache (GAC). These assemblies often represent legacy .NET Framework components, especially those compiled for 32-bit, which are not easily upgraded to modern .NET and may exist outside of package management.\nUntil now, the Toolbox in the Windows Forms designer only displayed controls sourced from NuGet packages or project references. This created a limitation for developers working with long-standing legacy codebases. Explicit Assembly References were invisible to the Toolbox, leading to a fragmented experience and reduced productivity, particularly during modernization efforts.\nWhy This Matters\nDevelopers relying on legacy Windows Forms controls often face challenges due to this limitation. The traditional approach of using the “Choose Items…” dialog in the Toolbox for in-process designer fails entirely for 32-bit assemblies as those assemblies cannot be loaded in 64-bit Visual Studio.\nIn response, we have extended Toolbox support to automatically fetch controls’ information from Explicit Assembly References. This allows developers to use their legacy controls within the modern out-of-process designer, removing a key blocker in migration and maintenance workflows.\nHow It Works\nWhen you launch the Windows Forms out-of-process designer for a .NET Framework project, the designer now automatically scans all references in the solution. It identifies Explicit Assembly References without loading them into Visual Studio itself. Leveraging the Roslyn APIs, the designer analyzes metadata to extract Toolbox item information from these assemblies.\nThis approach ensures that eligible controls appear in the Toolbox—ready for drag-and-drop just like those from NuGet or project references.\nImportant Caveats\nThe out-of-process designer uses a new extensibility model, which clearly separates design time and runtime assemblies. This separation is crucial for enabling advanced design time scenarios like custom CodeDomSerializer usage, specialized UITypeEditor implementations, and custom TypeConverter behaviors.\nExplicit Assembly References do not support this separation. As a result, all such assemblies are treated as runtime only, which limits their design time functionality. While basic Toolbox and control instantiation scenarios will work, advanced behaviors may not function as expected.\nFor the best experience, especially when working with custom design-time features, we strongly recommend using NuGet packages that follow the specified layout for runtime and design-time separation.\nConfiguring the Feature\nThis feature is enabled by default starting with Visual Studio 17.14 Preview 3 for .NET Framework projects. If needed, you can toggle this functionality via Visual Studio → Tools → Options → Preview Features\n\nWe’re currently rolling out this feature exclusively for .NET Framework projects, but we plan to extend this support to .NET projects in future Visual Studio releases.\nLooking Ahead\nToolbox support for Explicit Assembly References simplifies working with legacy controls and helps pave the way for smoother migration to .NET. Once this feature expands to .NET projects, it will serve as a powerful bridge during modernization efforts.\nWhile we are happy to offer this capability, we continue to emphasize that for the richest and most predictable design-time experience, the recommended path remains through well-structured NuGet packages aligned with the new extensibility model.\nReady to try it out? Download Visual Studio 17.14 Preview 3 and open your Windows Forms .NET Framework project in the out-of-process designer. Your legacy controls will now appear in the Toolbox, ready for use!\nCheck out the new Visual Studio Hub\nStay connected with everything Visual Studio in one place! Visit the Visual Studio Hub for the latest release notes, YouTube videos, social updates, and community discussions.\nAppreciation for your feedback\nYour feedback helps us improve Visual Studio, making it an even more powerful tool for developers. We are immensely grateful for your contributions and look forward to your continued support. By sharing your thoughts, ideas, and any issues you encounter through Developer Community, you help us improve and shape the future of Visual Studio.\nThe post Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer appeared first on Visual Studio Blog.",
        "dc:creator": "Merrie McGaw, Shyam Gupta",
        "comments": "https://devblogs.microsoft.com/visualstudio/toolbox-support-for-explicit-assembly-references-in-windows-forms-out-of-process-designer/#comments",
        "content": "<p>Visual Studio 17.14 Preview 3 introduces a new feature that enhances the Windows Forms out-of-process designer experience for .NET Framework projects. This release brings Toolbox support for Explicit Assembly References, addressing a long-standing need in legacy application development and migration workflows. What Are Explicit Assembly References? Explicit Assembly References are stand-alone assemblies directly referenced in [&#8230;]</p>\n<p>The post <a href=\"https://devblogs.microsoft.com/visualstudio/toolbox-support-for-explicit-assembly-references-in-windows-forms-out-of-process-designer/\">Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer</a> appeared first on <a href=\"https://devblogs.microsoft.com/visualstudio\">Visual Studio Blog</a>.</p>\n",
        "contentSnippet": "Visual Studio 17.14 Preview 3 introduces a new feature that enhances the Windows Forms out-of-process designer experience for .NET Framework projects. This release brings Toolbox support for Explicit Assembly References, addressing a long-standing need in legacy application development and migration workflows. What Are Explicit Assembly References? Explicit Assembly References are stand-alone assemblies directly referenced in […]\nThe post Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer appeared first on Visual Studio Blog.",
        "guid": "https://devblogs.microsoft.com/visualstudio/?p=253042",
        "categories": [
          "Visual Studio",
          "Windows Forms",
          "Assembly References",
          "designer",
          "out-of-process",
          "Toolbox",
          "WinForms"
        ],
        "isoDate": "2025-04-17T14:45:27.000Z"
      },
      {
        "creator": "Katie Savage",
        "title": "GitHub Copilot Highlights in Visual Studio 17.14 Preview 3 (Available Now)",
        "link": "https://devblogs.microsoft.com/visualstudio/github-copilot-highlights-in-visual-studio-17-14-preview-3-available-now/",
        "pubDate": "Wed, 16 Apr 2025 18:24:10 +0000",
        "content:encodedSnippet": "Visual Studio 17.14 Preview 3 is now available!\nDownload Visual Studio Preview\n\nThe GitHub Copilot experience in Visual Studio is continuously updated to provide the latest advancements in AI-assisted development. The following features and improvements have been recently released in Visual Studio version 17.14 Preview 3. (Remember, preview versions of Visual Studio can be run side by side with the main releases)\n\nA guided Walkthrough for getting started\nIf you’re new to GitHub Copilot in Visual Studio and are looking for a quick, guided way to get started, this feature is for you. Head to the GitHub Copilot badge dropdown and select GitHub Copilot Walkthrough. This will launch the walkthrough as a new tab in your workspace.\nThis five-step walkthrough will show you how to get Copilot for free, introduce you to AI-powered code completions, Copilot Chat, show you how to provide Copilot with specific context about your solution, and introduce you to the multi-file editing power of Copilot Edits. Once you complete these steps, you should be ready to start using and experimenting with Copilot.\ndocument.createElement('video');\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/WalkthroughP3.mp4\n\nImproved model access and Code Mapping\nIt’s also now easier than ever to access the latest models like Claude 3.7 from within Visual Studio. Instead of needing to adjust your settings, you can now enable any of the available models from github.com directly through Visual Studio. When you select your model within Copilot Chat, you will be prompted to enable your chosen model.\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/ModelApprovalP3.mp4\n\nHow and where Copilot inserts its code suggestions into your code in the right place has also gotten an upgrade in this release with improvements to what we call “Code Mapping”.\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/CodeMappingP3.mp4\n\nCopilot can suggest the next edit and fix pasted code automatically\nWe also have some exciting updates coming to the Code Completion experience that will allow Copilot to better understand your intention as you’re writing code and enhance its ability to assist you with editing your code. The feature is called Next Edit Suggestions, which helps developers by providing contextual suggestions for code edits based on previous changes.\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/NESP3.mp4\n\nAnother feature to watch out for is adaptive paste which automatically adjusts code you paste into Visual Studio to fit the context of your existing code, minimizing the need for manual modifications. This feature also supports scenarios such as minor error fixes, code styling, formatting, human and code language translation, and fill-in-the-blank or continue-the-pattern tasks.\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/AdaptivePasteP3.mp4\n\nLearn more about these features in the preview 3 release notes: Visual Studio 2022 Preview Release Notes | Microsoft Learn\nTry the latest Preview\nIf you’d like to see any of these features in action and stay up to date with the latest Copilot updates, try out the preview version of Visual Studio.\nCheck out the new Visual Studio Hub\nStay connected with everything Visual Studio in one place! Visit the Visual Studio Hub for the latest release notes, YouTube videos, social updates, and community discussions.\nAppreciation for your feedback\nYour feedback helps us improve Visual Studio, making it an even more powerful tool for developers. We are immensely grateful for your contributions and look forward to your continued support. By sharing your thoughts, ideas, and any issues you encounter through Developer Community, you help us improve and shape the future of Visual Studio.\nThe post GitHub Copilot Highlights in Visual Studio 17.14 Preview 3 (Available Now) appeared first on Visual Studio Blog.",
        "enclosure": {
          "url": "https://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/WalkthroughP3.mp4",
          "length": "9841988",
          "type": "video/mp4"
        },
        "dc:creator": "Katie Savage",
        "comments": "https://devblogs.microsoft.com/visualstudio/github-copilot-highlights-in-visual-studio-17-14-preview-3-available-now/#comments",
        "content": "<p>Visual Studio 17.14 Preview 3 is now available! The GitHub Copilot experience in Visual Studio is continuously updated to provide the latest advancements in AI-assisted development. The following features and improvements have been recently released in Visual Studio version 17.14 Preview 3. (Remember, preview versions of Visual Studio can be run side by side with [&#8230;]</p>\n<p>The post <a href=\"https://devblogs.microsoft.com/visualstudio/github-copilot-highlights-in-visual-studio-17-14-preview-3-available-now/\">GitHub Copilot Highlights in Visual Studio 17.14 Preview 3 (Available Now)</a> appeared first on <a href=\"https://devblogs.microsoft.com/visualstudio\">Visual Studio Blog</a>.</p>\n",
        "contentSnippet": "Visual Studio 17.14 Preview 3 is now available! The GitHub Copilot experience in Visual Studio is continuously updated to provide the latest advancements in AI-assisted development. The following features and improvements have been recently released in Visual Studio version 17.14 Preview 3. (Remember, preview versions of Visual Studio can be run side by side with […]\nThe post GitHub Copilot Highlights in Visual Studio 17.14 Preview 3 (Available Now) appeared first on Visual Studio Blog.",
        "guid": "https://devblogs.microsoft.com/visualstudio/?p=252998",
        "categories": [
          "Copilot",
          "Visual Studio"
        ],
        "isoDate": "2025-04-16T18:24:10.000Z"
      }
    ]
  },
  {
    "name": "Instagram Engineering",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Dropbox Tech Blog",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Joshua",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권재명",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김석기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김선영",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권진호",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강대명",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권정혁",
    "category": "개인",
    "posts": []
  },
  {
    "name": "줌구",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김수보",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김시은",
    "category": "개인",
    "posts": []
  },
  {
    "name": "곽민수",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김민서",
    "category": "개인",
    "posts": []
  },
  {
    "name": "I am not Okay",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권창현",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권기호",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김수민",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강태욱",
    "category": "개인",
    "posts": [
      {
        "title": "OpenAI 코딩 멀티 에이전트 Codex 오픈소스 도구 사용법",
        "link": "http://daddynkidsmakers.blogspot.com/2025/04/openai-codex.html",
        "pubDate": "2025-04-17T07:04:00.000Z",
        "author": "Daddy Maker",
        "content": "<div style=\"text-align: left;\">이 글은&nbsp;OpenAI가 개발한 코딩 멀티 에이전트 Codex 사용법을 간략히 소개한다.&nbsp;</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">현재 시점에서 14시간 전에 OpenAI o3, o4, codex 가 공개되었다. 모두 멀티 AI 에이전트 기능을 충실히 구현한 영상을 데모가 업로드되었고, 특히, 자동화 코딩을 지원하는 codex(코덱스) 가 로컬 컴퓨터에서 실행 가능한 형태로 공개된 점이 인상적이었다.&nbsp;</div><div class=\"separator\" style=\"clear: both; text-align: center;\"><iframe allowfullscreen=\"\" class=\"BLOG_video_class\" height=\"266\" src=\"https://www.youtube.com/embed/sq8GBPUb3rk\" width=\"320\" youtube-src-id=\"sq8GBPUb3rk\"></iframe></div><div class=\"separator\" style=\"clear: both; text-align: center;\">OpenAI o3, o4, codex 공개 영상</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">코덱스 코드 및 도구는 Github에 공개되었다.</div><div style=\"text-align: left;\"><ul style=\"text-align: left;\"><li><a href=\"https://github.com/openai/codex\">codex: Lightweight coding agent that runs in your terminal</a></li></ul></div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>코덱스 설치 및 환경설정</b></div><div style=\"text-align: left;\">터미널에서 다음을 실행해 설치 및 환경 설정을 한다.</div><div style=\"text-align: left;\">git clone https://github.com/openai/codex.git</div><div style=\"text-align: left;\">cd codex</div><div style=\"text-align: left;\">npm install -g @openai/codex</div><div style=\"text-align: center;\"><div style=\"text-align: left;\"><img alt=\"\" data-original-height=\"270\" data-original-width=\"1084\" height=\"133\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhe8O2QU6nkqpzFKwOzt8VyJTszssUlQuN1aRNvqgbzGy9iQF1T7Y19JLCbvvElUuSO2FbHRqF-2-GZ3-VuK0rymBhXul_7K51RcYsZHhubP6DbOyDemUgQeb_VKPZff3cYWL1TYtjjxsNlAqRi-SNPT8EVi5Wzut4jLvPYEYYIANR3LIgvDym8aVvwn608=w533-h133\" style=\"color: #0000ee; text-align: center;\" width=\"533\" /></div></div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">설치 시 npm error code SELF_SIGNED_CERT_IN_CHAIN 에러 발생하면 다음 명령 실행 후 패키지 재설치한다.</div><div style=\"text-align: left;\"><div>npm config set strict-ssl false -g</div><div><br /></div><div>오픈AI Key를 설정한다.</div></div><div style=\"text-align: left;\">export OPENAI_API_KEY=\"your-api-key-here\"</div><div style=\"text-align: left;\"><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div></div><div style=\"text-align: left;\"><b>실행</b></div><div style=\"text-align: left;\">터미널에서 코덱스를 실행한다.&nbsp;</div><div style=\"text-align: left;\">codex&nbsp;</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">프롬프트를 직접 입력해도 된다.&nbsp;&nbsp;</div><div style=\"text-align: left;\">codex \"explain this codebase to me\"</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">앱을 개발해보자.&nbsp;</div><div style=\"text-align: left;\">codex --approval-mode full-auto \"create the fanciest todo-list app\"</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">그럼 todo list app을 codex가 개발하는 것을 확인할 수 있다. 이외에 다음과 같은 프롬프트를 입력해보자.&nbsp;</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">\"create the ascii rendering web viewer using webcam\"</div><div style=\"text-align: left;\">\"create 3D tetris using three.js\"</div><div style=\"text-align: left;\">...</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>마무리</b></div><div style=\"text-align: left;\">점차 AI 에이전트가 우리가 사용하는 개인 기기(노트북, 스마트폰 등)에 침투하고 있다. MCP는 그 시작인 것이고, Codex는 AI OS 위치로 맵핑하고자 한다. 올해 더 큰 경쟁과 발전이 있으리라 생각된다.</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>레퍼런스</b></div><div style=\"text-align: left;\"><ul style=\"text-align: left;\"><li><a href=\"https://github.com/openai/codex\">Lightweight coding agent that runs in your terminal</a></li><li><a href=\"https://medium.com/@joe.njenga/i-tested-codex-cli-openai-tool-like-claude-code-just-average-to-good-b5483edcc6d1\">CLI OpenAI Tool Like Claude Code</a></li><li><a href=\"https://cobusgreyling.medium.com/openai-codex-cli-7b73b60bc006\">OpenAI Codex CLI. Is a Lightweight Coding AI Agent</a></li></ul></div>",
        "contentSnippet": "이 글은 OpenAI가 개발한 코딩 멀티 에이전트 Codex 사용법을 간략히 소개한다. \n\n\n현재 시점에서 14시간 전에 OpenAI o3, o4, codex 가 공개되었다. 모두 멀티 AI 에이전트 기능을 충실히 구현한 영상을 데모가 업로드되었고, 특히, 자동화 코딩을 지원하는 codex(코덱스) 가 로컬 컴퓨터에서 실행 가능한 형태로 공개된 점이 인상적이었다. \n\nOpenAI o3, o4, codex 공개 영상\n\n\n코덱스 코드 및 도구는 Github에 공개되었다.\n\ncodex: Lightweight coding agent that runs in your terminal\n\n\n\n코덱스 설치 및 환경설정\n터미널에서 다음을 실행해 설치 및 환경 설정을 한다.\ngit clone https://github.com/openai/codex.git\ncd codex\nnpm install -g @openai/codex\n\n\n\n\n설치 시 npm error code SELF_SIGNED_CERT_IN_CHAIN 에러 발생하면 다음 명령 실행 후 패키지 재설치한다.\n\nnpm config set strict-ssl false -g\n\n\n오픈AI Key를 설정한다.\n\nexport OPENAI_API_KEY=\"your-api-key-here\"\n\n\n\n실행\n터미널에서 코덱스를 실행한다. \ncodex \n\n\n프롬프트를 직접 입력해도 된다.  \ncodex \"explain this codebase to me\"\n\n\n앱을 개발해보자. \ncodex --approval-mode full-auto \"create the fanciest todo-list app\"\n\n\n그럼 todo list app을 codex가 개발하는 것을 확인할 수 있다. 이외에 다음과 같은 프롬프트를 입력해보자. \n\n\n\"create the ascii rendering web viewer using webcam\"\n\"create 3D tetris using three.js\"\n...\n\n\n마무리\n점차 AI 에이전트가 우리가 사용하는 개인 기기(노트북, 스마트폰 등)에 침투하고 있다. MCP는 그 시작인 것이고, Codex는 AI OS 위치로 맵핑하고자 한다. 올해 더 큰 경쟁과 발전이 있으리라 생각된다.\n\n\n레퍼런스\n\nLightweight coding agent that runs in your terminal\nCLI OpenAI Tool Like Claude Code\nOpenAI Codex CLI. Is a Lightweight Coding AI Agent",
        "id": "tag:blogger.com,1999:blog-5201956450461596914.post-3813547155265462040",
        "isoDate": "2025-04-17T07:04:00.000Z"
      }
    ]
  },
  {
    "name": "권용진",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김민수",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김승호",
    "category": "개인",
    "posts": []
  },
  {
    "name": "RSS feed for boyism Blog",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김성준의 린스타트업과 디자인씽킹",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강동혁",
    "category": "개인",
    "posts": []
  },
  {
    "name": "고종범",
    "category": "개인",
    "posts": []
  },
  {
    "name": "cheese10yun",
    "category": "개인",
    "posts": []
  },
  {
    "name": "구자철",
    "category": "개인",
    "posts": []
  },
  {
    "name": "FSS",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권동준",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김용일",
    "category": "개인",
    "posts": [
      {
        "creator": "흰끼끼",
        "title": "블루베리 효능 총정리: 노화 방지에 탁월한 이유 5가지",
        "link": "http://app-developer.tistory.com/entry/%EB%B8%94%EB%A3%A8%EB%B2%A0%EB%A6%AC-%ED%9A%A8%EB%8A%A5-%EC%B4%9D%EC%A0%95%EB%A6%AC-%EB%85%B8%ED%99%94-%EB%B0%A9%EC%A7%80%EC%97%90-%ED%83%81%EC%9B%94%ED%95%9C-%EC%9D%B4%EC%9C%A0-5%EA%B0%80%EC%A7%80",
        "pubDate": "Sun, 13 Apr 2025 20:44:48 +0900",
        "author": "흰끼끼",
        "comments": "http://app-developer.tistory.com/entry/%EB%B8%94%EB%A3%A8%EB%B2%A0%EB%A6%AC-%ED%9A%A8%EB%8A%A5-%EC%B4%9D%EC%A0%95%EB%A6%AC-%EB%85%B8%ED%99%94-%EB%B0%A9%EC%A7%80%EC%97%90-%ED%83%81%EC%9B%94%ED%95%9C-%EC%9D%B4%EC%9C%A0-5%EA%B0%80%EC%A7%80#entry207comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"ChatGPT Image 2025년 4월 13일 오후 08_43_47.png\" data-origin-width=\"1536\" data-origin-height=\"1024\"><span data-url=\"https://blog.kakaocdn.net/dn/c18gA9/btsNjFgQZIm/4YdksfRmkM58ehiPktlCl1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/c18gA9/btsNjFgQZIm/4YdksfRmkM58ehiPktlCl1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/c18gA9/btsNjFgQZIm/4YdksfRmkM58ehiPktlCl1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc18gA9%2FbtsNjFgQZIm%2F4YdksfRmkM58ehiPktlCl1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"1536\" height=\"1024\" data-filename=\"ChatGPT Image 2025년 4월 13일 오후 08_43_47.png\" data-origin-width=\"1536\" data-origin-height=\"1024\"/></span></figure>\n</p>\n<p>현대인의 건강식으로 각광받고 있는 <strong>블루베리</strong>, 그냥 맛있는 과일일 뿐이라고 생각하셨다면 오산입니다. 특히 <strong>노화를 늦추는 항산화 식품</strong>으로 블루베리는 수많은 연구에서 그 효과가 입증되고 있는데요. 이번 글에서는 블루베리가 <strong>왜 노화 방지에 탁월한지</strong>, 그 이유 5가지를 집중적으로 알아보겠습니다.</p>\n<h2>1. 강력한 항산화 성분, 안토시아닌의 힘</h2>\n<p>블루베리는 <strong>안토시아닌(Anthocyanin)</strong>이라는 강력한 항산화 성분이 풍부하게 들어 있습니다.<br>이 성분은 활성산소로부터 세포를 보호하여 <strong>세포 노화를 늦추는 효과</strong>를 합니다.<br>피부 탄력, 주름 개선, 면역력 강화에도 큰 도움을 줍니다.</p>\n<h2>2. 뇌 기능 보호 및 인지 능력 향상</h2>\n<p>노화의 대표적인 증상 중 하나는 <strong>기억력 저하</strong>와 같은 뇌 기능 감소입니다.<br>블루베리 섭취는 <strong>신경세포 손상을 줄이고, 뇌 신호 전달을 촉진</strong>하여<br>인지 능력 향상 및 <strong>치매 예방 효과</strong>까지 기대할 수 있습니다.</p>\n<h2>3. 심혈관 건강 개선으로 노화 예방</h2>\n<p>나이가 들수록 혈관 건강은 더 중요해지죠.<br>블루베리는 <strong>혈관을 깨끗하게 유지하고, 혈압과 콜레스테롤 수치를 낮추는 데</strong> 도움을 줍니다.<br>이로 인해 <strong>심혈관 질환 예방</strong>은 물론, 신체 전체의 노화 속도도 늦출 수 있습니다.</p>\n<h2>4. 면역력 강화로 각종 질병 예방</h2>\n<p>노화가 진행되면 <strong>면역 시스템이 약화</strong>되기 쉽습니다.<br>블루베리 속 <strong>비타민 C, K, 망간 등의 영양소</strong>는 면역 기능을 강화해<br>감기나 바이러스, 염증성 질환 등 각종 <strong>질병으로부터 몸을 보호</strong>해 줍니다.</p>\n<h2>5. 피부 건강 개선과 안티에이징 효과</h2>\n<p>블루베리는 <strong>피부 트러블 개선과 피부 톤 개선</strong>에도 효과적입니다.<br>항산화 작용으로 인해 피부의 노화 원인인 <strong>산화 스트레스와 자외선 손상</strong>을 줄여주며,<br>피부에 <strong>생기와 탄력</strong>을 더해주는 데 도움을 줍니다.</p>\n<h2>✅ 결론</h2>\n<p>블루베리는 단순한 과일이 아니라, <strong>노화 방지를 위한 자연의 선물</strong>입니다.<br>매일 소량이라도 꾸준히 섭취한다면, 건강은 물론 <strong>젊음까지 지킬 수 있는 최고의 슈퍼푸드</strong>죠.<br>오늘부터 식단에 블루베리를 더해보는 건 어떠세요?</p>\n<blockquote data-ke-style=\"style1\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>  <strong>팁</strong>: 신선한 블루베리뿐만 아니라, 냉동 블루베리나 블루베리 파우더도 동일한 효능을 기대할 수 있어요!</p>\n</span></p></blockquote>",
        "contentSnippet": "현대인의 건강식으로 각광받고 있는 블루베리, 그냥 맛있는 과일일 뿐이라고 생각하셨다면 오산입니다. 특히 노화를 늦추는 항산화 식품으로 블루베리는 수많은 연구에서 그 효과가 입증되고 있는데요. 이번 글에서는 블루베리가 왜 노화 방지에 탁월한지, 그 이유 5가지를 집중적으로 알아보겠습니다.\n1. 강력한 항산화 성분, 안토시아닌의 힘\n블루베리는 안토시아닌(Anthocyanin)이라는 강력한 항산화 성분이 풍부하게 들어 있습니다.\n이 성분은 활성산소로부터 세포를 보호하여 세포 노화를 늦추는 효과를 합니다.\n피부 탄력, 주름 개선, 면역력 강화에도 큰 도움을 줍니다.\n2. 뇌 기능 보호 및 인지 능력 향상\n노화의 대표적인 증상 중 하나는 기억력 저하와 같은 뇌 기능 감소입니다.\n블루베리 섭취는 신경세포 손상을 줄이고, 뇌 신호 전달을 촉진하여\n인지 능력 향상 및 치매 예방 효과까지 기대할 수 있습니다.\n3. 심혈관 건강 개선으로 노화 예방\n나이가 들수록 혈관 건강은 더 중요해지죠.\n블루베리는 혈관을 깨끗하게 유지하고, 혈압과 콜레스테롤 수치를 낮추는 데 도움을 줍니다.\n이로 인해 심혈관 질환 예방은 물론, 신체 전체의 노화 속도도 늦출 수 있습니다.\n4. 면역력 강화로 각종 질병 예방\n노화가 진행되면 면역 시스템이 약화되기 쉽습니다.\n블루베리 속 비타민 C, K, 망간 등의 영양소는 면역 기능을 강화해\n감기나 바이러스, 염증성 질환 등 각종 질병으로부터 몸을 보호해 줍니다.\n5. 피부 건강 개선과 안티에이징 효과\n블루베리는 피부 트러블 개선과 피부 톤 개선에도 효과적입니다.\n항산화 작용으로 인해 피부의 노화 원인인 산화 스트레스와 자외선 손상을 줄여주며,\n피부에 생기와 탄력을 더해주는 데 도움을 줍니다.\n✅ 결론\n블루베리는 단순한 과일이 아니라, 노화 방지를 위한 자연의 선물입니다.\n매일 소량이라도 꾸준히 섭취한다면, 건강은 물론 젊음까지 지킬 수 있는 최고의 슈퍼푸드죠.\n오늘부터 식단에 블루베리를 더해보는 건 어떠세요?\n\n  팁: 신선한 블루베리뿐만 아니라, 냉동 블루베리나 블루베리 파우더도 동일한 효능을 기대할 수 있어요!",
        "guid": "http://app-developer.tistory.com/207",
        "categories": [
          "건강/노화 및 웰에이징"
        ],
        "isoDate": "2025-04-13T11:44:48.000Z"
      }
    ]
  },
  {
    "name": "김도균",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김민석",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김동우",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권윤학",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김민준",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김만수",
    "category": "개인",
    "posts": []
  },
  {
    "name": "엘키",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권태환",
    "category": "개인",
    "posts": [
      {
        "title": "Composable Architecture는 만들었는데 문제가 있었네? 개선해보자.",
        "link": "https://thdev.tech/architecture/2025/04/15/Android-Architecture-02/",
        "pubDate": "Tue, 15 Apr 2025 00:00:00 +0000",
        "content": "<p>이전 글에서 Composable Architecutre를 소개하는 내용을 담아보았는데, 몇 가지 문제점을 발견하여 이를 개선한 내용을 다시 정리하는 글이다.</p>\n\n<p>크게 2가지 문제점을 확인하였다.</p>\n\n<ul>\n  <li>ViewModel 내 Reducer 처리 후 자동 next</li>\n  <li>Action 스트림 처리를 위한 싱글턴 활용 시 Lifecycle 문제</li>\n</ul>\n\n<p>이 2가지 문제점을 해결하기 위해 코드를 어떻게 수정했는지, 그리고 더 나은 방법은 없을지 고민한 과정을 정리해본다.</p>\n\n<h3>이 글에서는</h3>\n<ul>\n  <li>기존 아키텍처의 구조적 문제점을 파악한다.</li>\n  <li>문제 해결 과정과 더 나은 구조에 대한 고민을 공유한다.</li>\n  <li>기본적인 내용을 담지 않고있어 앞선 글을 참고하면 좋다.</li>\n</ul>\n\n<!--more-->\n\n<h3>이전 글</h3>\n\n<ul>\n  <li><a href=\"https://thdev.tech/architecture/2025/02/02/Android-Architecture-01/\">컴포즈에 사용할 Composable Architecutre 설명(리엑트?)</a></li>\n  <li><a href=\"https://thdev.tech/architecture/2025/04/15/Android-Architecture-02/\">Composable Architecutre는 만들었는데 문제가 있었네? 개선해보자.</a></li>\n</ul>\n\n<p><br /></p>\n\n<h2>Action이란?</h2>\n\n<p>View와 ViewModel 사이의 통신을 어떻게 더 간결하게 할 수 있을까? Jetpack Compose 환경에서는 <a href=\"https://developer.android.com/develop/ui/compose/compositionlocal\">CompositionLocal - link</a>을 활용하는 방법이 있다. 저는 이 방식을 응용하여 Composable 함수 어디서든 이벤트 처리를 쉽게 호출할 수 있도록 Action이라는 개념을 만들었다.</p>\n\n<p>Flow를 기반으로 한 Action을 사용한 이유를 설명하기 위해, 먼저 일반적인 View-ViewModel 간 통신 방식의 예시 코드를 살펴보자.</p>\n\n<p>Composable 함수에서 ViewModel 인스턴스를 파라미터로 직접 전달받아 사용하는 것이 일반적이다. 하지만 이 방식은 Composable 함수의 깊이가 깊어지거나 개수가 많아질수록 ViewModel을 어디까지 전달해야 할지 고민이 필요하며, 구조가 복잡해지면 자연스럽게 보일러플레이트 코드가 늘어나는 단점이 있다.</p>\n\n<h4>ViewModel을 직접 사용한 함수 호출</h4>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">someViewModel</span><span class=\"p\">:</span> <span class=\"nc\">SomeViewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">})</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">doSomethingTwo</span><span class=\"p\">()</span> <span class=\"p\">})</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">doSomethingThree</span><span class=\"p\">()</span> <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">SomeViewModel</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">fun</span> <span class=\"nf\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n  <span class=\"k\">fun</span> <span class=\"nf\">doSomethingTwo</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n  <span class=\"k\">fun</span> <span class=\"nf\">doSomethingThree</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h4>ViewModel 함수를 sealed interface로 통합하여 호출하는 경우</h4>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">sealed</span> <span class=\"kd\">interface</span> <span class=\"nc\">SomeAction</span> <span class=\"p\">{</span>\n    <span class=\"n\">data</span> <span class=\"kd\">object</span> <span class=\"nc\">ActionOne</span> <span class=\"p\">:</span> <span class=\"nc\">SomeAction</span>\n    <span class=\"n\">data</span> <span class=\"kd\">object</span> <span class=\"nc\">ActionTwo</span> <span class=\"p\">:</span> <span class=\"nc\">SomeAction</span>\n    <span class=\"kd\">data class</span> <span class=\"nc\">ActionThree</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">item</span><span class=\"p\">:</span> <span class=\"nc\">Any</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">SomeAction</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">someViewModel</span><span class=\"p\">:</span> <span class=\"nc\">SomeViewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">val</span> <span class=\"py\">item</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span> <span class=\"c1\">// 예시 데이터</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionOne</span><span class=\"p\">)</span> <span class=\"p\">})</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionTwo</span><span class=\"p\">)</span> <span class=\"p\">})</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionThree</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">))</span> <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">SomeViewModel</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">fun</span> <span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">SomeAction</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">when</span> <span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">is</span> <span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionOne</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n      <span class=\"k\">is</span> <span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionTwo</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n      <span class=\"k\">is</span> <span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionThree</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h4>제가 활용하는 방식 (CompositionLocal 활용)</h4>\n\n<p>위 방식들은 ViewModel을 계속 전달하거나, <code class=\"language-plaintext highlighter-rouge\">onClick: () -&gt; Unit</code> 같은 콜백을 계속 만들어 전달해야 하는 번거로움이 있다. 특히 콜백 방식은 이벤트 통합 과정에서 N개의 고차 함수(Higher-Order function)가 만들어질 수 있다.</p>\n\n<p>그래서 Compose에서 제공하는 <a href=\"https://developer.android.com/develop/ui/compose/compositionlocal\">Locally scoped - link</a>을 활용하여 Action 객체에 쉽게 접근하는 방법을 사용하고 있습니다. (자세한 활용법은 이전 글 <a href=\"https://thdev.tech/architecture/2025/02/02/Android-Architecture-01/\">컴포즈에 사용할 Composable Architecture 설명</a>을 참고해주세요.)</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Action 정의 (예시)</span>\n<span class=\"k\">sealed</span> <span class=\"kd\">interface</span> <span class=\"nc\">MyAction</span> <span class=\"p\">:</span> <span class=\"nc\">CaAction</span> <span class=\"p\">{</span> <span class=\"c1\">// CaAction은 마커 인터페이스 역할</span>\n    <span class=\"n\">data</span> <span class=\"kd\">object</span> <span class=\"nc\">ButtonClick</span> <span class=\"p\">:</span> <span class=\"nc\">MyAction</span>\n    <span class=\"kd\">data class</span> <span class=\"nc\">TextTyped</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">text</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">MyAction</span>\n    <span class=\"kd\">data class</span> <span class=\"nc\">SwitchChanged</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">isOn</span><span class=\"p\">:</span> <span class=\"nc\">Boolean</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">MyAction</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Composable View</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">uiState</span><span class=\"p\">:</span> <span class=\"nc\">UiState</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// CompositionLocal을 통해 Action 획득</span>\n  <span class=\"kd\">val</span> <span class=\"py\">action</span> <span class=\"p\">=</span> <span class=\"nc\">LocalAction</span><span class=\"p\">.</span><span class=\"n\">current</span>\n\n  <span class=\"nc\">Column</span> <span class=\"p\">{</span>\n      <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">action</span><span class=\"p\">.</span><span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">ButtonClick</span><span class=\"p\">)</span> <span class=\"p\">})</span> <span class=\"p\">{</span>\n          <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Click Me\"</span><span class=\"p\">)</span>\n      <span class=\"p\">}</span>\n\n      <span class=\"nc\">TextField</span><span class=\"p\">(</span>\n          <span class=\"n\">value</span> <span class=\"p\">=</span> <span class=\"n\">uiState</span><span class=\"p\">.</span><span class=\"n\">textState</span><span class=\"p\">,</span>\n          <span class=\"n\">onValueChange</span> <span class=\"p\">=</span> <span class=\"p\">{</span>\n              <span class=\"n\">action</span><span class=\"p\">.</span><span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">TextTyped</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">))</span>\n          <span class=\"p\">}</span>\n      <span class=\"p\">)</span>\n\n      <span class=\"nc\">Switch</span><span class=\"p\">(</span>\n          <span class=\"n\">checked</span> <span class=\"p\">=</span> <span class=\"n\">uiState</span><span class=\"p\">.</span><span class=\"n\">switchState</span><span class=\"p\">,</span>\n          <span class=\"n\">onCheckedChange</span> <span class=\"p\">=</span> <span class=\"p\">{</span>\n              <span class=\"n\">action</span><span class=\"p\">.</span><span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">SwitchChanged</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">))</span>\n          <span class=\"p\">}</span>\n      <span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// ViewModel</span>\n<span class=\"kd\">class</span> <span class=\"nc\">SomeViewModel</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">flowCaActionStream</span><span class=\"p\">:</span> <span class=\"nc\">FlowCaActionStream</span> <span class=\"c1\">// Action 스트림 주입</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"nc\">MyAction</span><span class=\"p\">&gt;(</span><span class=\"n\">flowCaActionStream</span><span class=\"p\">,</span> <span class=\"nc\">MyAction</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 수신할 Action 타입 지정</span>\n\n    <span class=\"c1\">// CaViewModel 내부에서 flowAction을 통해 MyAction 타입의 이벤트만 필터링하여 수신</span>\n    <span class=\"c1\">// reducer 메소드에서 각 Action 처리 로직 구현</span>\n    <span class=\"k\">override</span> <span class=\"k\">suspend</span> <span class=\"k\">fun</span> <span class=\"nf\">reducer</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">MyAction</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">when</span> <span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">is</span> <span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">ButtonClick</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 버튼 클릭 처리 로직</span>\n                <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">d</span><span class=\"p\">(</span><span class=\"s\">\"SomeViewModel\"</span><span class=\"p\">,</span> <span class=\"s\">\"Button Clicked\"</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n\n            <span class=\"k\">is</span> <span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">TextTyped</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 텍스트 입력 처리 로직</span>\n                <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">d</span><span class=\"p\">(</span><span class=\"s\">\"SomeViewModel\"</span><span class=\"p\">,</span> <span class=\"s\">\"Text Typed: ${action.text}\"</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n\n            <span class=\"k\">is</span> <span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">SwitchChanged</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 스위치 변경 처리 로직</span>\n                <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">d</span><span class=\"p\">(</span><span class=\"s\">\"SomeViewModel\"</span><span class=\"p\">,</span> <span class=\"s\">\"Switch Changed: ${action.isOn}\"</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<h2>사용성 측면에서의 개선</h2>\n\n<p>필요한 Action을 <code class=\"language-plaintext highlighter-rouge\">LocalAction.current</code>를 통해 어디서든 호출할 수 있으므로, ViewModel 인스턴스를 계속해서 하위 Composable로 전달할 필요가 없어 개발 편의성이 향상될 수 있다.</p>\n\n<p>CompositionLocal에 적절한 기본값이나 테스트용 구현체를 제공하면 Preview 동작에도 문제가 없다. 다만, Preview에서 특정 UI 요소의 상태 변화나 인터랙션을 테스트하려면, 선언형 UI의 원칙에 따라 <a href=\"https://developer.android.com/develop/ui/compose/state\">Stateless - link</a>한 Composable을 만들고 상태와 이벤트를 외부에서 주입하는 것이 좋다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Statefull Composable (ViewModel과 연결)</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">SomeViewModel</span> <span class=\"p\">=</span> <span class=\"nf\">hiltViewModel</span><span class=\"p\">())</span> <span class=\"p\">{</span> <span class=\"c1\">// Hilt 등 DI 활용 예시</span>\n    <span class=\"kd\">val</span> <span class=\"py\">action</span> <span class=\"p\">=</span> <span class=\"nc\">LocalActionDispatcher</span><span class=\"p\">.</span><span class=\"n\">current</span> <span class=\"c1\">// Action 발송기</span>\n    <span class=\"c1\">// ViewModel로부터 상태를 구독하거나, 필요한 상태를 여기서 관리</span>\n    <span class=\"kd\">val</span> <span class=\"py\">uiState</span> <span class=\"k\">by</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"n\">uiState</span><span class=\"p\">.</span><span class=\"nf\">collectAsState</span><span class=\"p\">()</span> <span class=\"c1\">// 예시 StateFlow</span>\n\n    <span class=\"nc\">SomeContent</span><span class=\"p\">(</span>\n        <span class=\"n\">text</span> <span class=\"p\">=</span> <span class=\"n\">uiState</span><span class=\"p\">.</span><span class=\"n\">text</span><span class=\"p\">,</span>\n        <span class=\"n\">isSwitchOn</span> <span class=\"p\">=</span> <span class=\"n\">uiState</span><span class=\"p\">.</span><span class=\"n\">switchState</span><span class=\"p\">,</span>\n        <span class=\"n\">onButtonClick</span> <span class=\"p\">=</span> <span class=\"n\">action</span><span class=\"p\">.</span><span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">ButtonClick</span><span class=\"p\">),</span>\n        <span class=\"n\">onTextTyped</span> <span class=\"p\">=</span> <span class=\"n\">action</span><span class=\"p\">.</span><span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">TextTyped</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)),</span>\n        <span class=\"n\">onSwitchChange</span> <span class=\"p\">=</span> <span class=\"n\">action</span><span class=\"p\">.</span><span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"nc\">MyAction</span><span class=\"p\">.</span><span class=\"nc\">SwitchChanged</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)),</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Stateless Composable 예시</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeContent</span><span class=\"p\">(</span>\n    <span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span>\n    <span class=\"n\">isSwitchOn</span><span class=\"p\">:</span> <span class=\"nc\">Boolean</span><span class=\"p\">,</span>\n    <span class=\"n\">onButtonClick</span><span class=\"p\">:</span> <span class=\"p\">()</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">,</span>\n    <span class=\"n\">onTextTyped</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"nc\">String</span><span class=\"p\">)</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">,</span>\n    <span class=\"n\">onSwitchChange</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"nc\">Boolean</span><span class=\"p\">)</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">,</span>\n    <span class=\"n\">modifier</span><span class=\"p\">:</span> <span class=\"nc\">Modifier</span> <span class=\"p\">=</span> <span class=\"nc\">Modifier</span> <span class=\"c1\">// Modifier 추가 권장</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nc\">Column</span><span class=\"p\">(</span><span class=\"n\">modifier</span> <span class=\"p\">=</span> <span class=\"n\">modifier</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"n\">onButtonClick</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n        <span class=\"nc\">TextField</span><span class=\"p\">(</span><span class=\"n\">value</span> <span class=\"p\">=</span> <span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">onValueChange</span> <span class=\"p\">=</span> <span class=\"n\">onTextTyped</span><span class=\"p\">)</span>\n        <span class=\"nc\">Switch</span><span class=\"p\">(</span><span class=\"n\">checked</span> <span class=\"p\">=</span> <span class=\"n\">isSwitchOn</span><span class=\"p\">,</span> <span class=\"n\">onCheckedChange</span> <span class=\"p\">=</span> <span class=\"n\">onSwitchChange</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이 방식(Stateless/Statefull 분리 및 CompositionLocal 활용)의 단점은 다음과 같다.</p>\n\n<ul>\n  <li>ViewModel에서 모든 UI 인터랙션을 하나의 reducer 함수로 통합 관리하기보다, 각 상태 업데이트 로직과 이벤트 발송 로직이 분리될 수 있다. (이는 관점에 따라 장점일 수도 있다)</li>\n  <li>새로운 Action 이벤트를 추가할 때, ViewModel의 reducer에서도 해당 이벤트를 처리하는 로직을 추가해야 한다. (이는 sealed interface 사용 시 컴파일 타임에 강제될 수 있어 오히려 장점이 될 수 있다.)</li>\n</ul>\n\n<p>하지만 장점은 다음과 같습니다.</p>\n<ul>\n  <li>각 UI 요소의 이벤트 발송 책임이 명확해진다.</li>\n  <li>Stateless Composable은 재사용 및 테스트가 용이하다.</li>\n  <li>CompositionLocal을 통해 이벤트 발송 인터페이스 접근이 간편하다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3>정리하면</h3>\n\n<h4>해결하고 싶었던 지점</h4>\n\n<ul>\n  <li>View와 ViewModel 간의 이벤트 전달을 왜 항상 ViewModel 인스턴스를 통해 viewModel.someFunction() 형태로 직접 호출해야 할까?</li>\n  <li>Composable 함수의 깊이가 깊어질 때 ViewModel 인스턴스나 콜백 함수를 계속 전달해야 하는 번거로움을 줄일 수 없을까?</li>\n</ul>\n\n<h4>그래서 도입한 Action(CompositionLocal)</h4>\n\n<p>이벤트 처리를 위한 Action 인터페이스와 이를 쉽게 발송(dispatch)할 수 있는 ActionDispatcher를 CompositionLocal로 제공하여, Composable 함수 내에서 발생하는 보일러플레이트를 줄이고자 했다.</p>\n\n<p>하지만 여전히 해결해야 할 문제가 있는데</p>\n\n<ul>\n  <li>이벤트를 보내는 쪽(View)과 받는 쪽(ViewModel)에서 정확히 어떤 Action 타입을 사용하고 처리할지 명확히 약속이 필요하다. 만약 서로 다른 타입을 사용하거나 누락하면 이벤트가 유실되어 동작하지 않는 치명적인 문제가 발생할 수 있다.</li>\n</ul>\n\n<p>이 문제를 해결하고 개발 과정에서 실수를 줄이기 위해 <code class=\"language-plaintext highlighter-rouge\">sealed interface</code>를 사용하여 <code class=\"language-plaintext highlighter-rouge\">Action</code>을 정의하는 방식을 채택했다. sealed interface를 사용하면 ViewModel의 reducer에서 when 식으로 처리할 때 모든 하위 타입을 강제로 구현해야 하므로, 이벤트 누락 가능성을 컴파일 시점에 방지할 수 있다. 이는 UI 동작 관련 테스트 케이스를 일부 줄여줄 수 있는 장점도 있다.</p>\n\n<p><br /></p>\n\n<h2>그래서 발견한 문제</h2>\n\n<p><a href=\"https://github.com/pointfreeco/swift-composable-architecture\">Swift-composable architecture - 링크</a>를 참고하여 아키텍처를 구상하다 보니, Reducer가 특정 액션을 처리한 후 다음 액션을 연쇄적으로 발생시키는 구조를 발견했다.</p>\n\n<p>Swift Composable Architecture의 코드 예시를 보면, Reduce 클로저 내에서 <code class=\"language-plaintext highlighter-rouge\">.send</code>나 다른 이펙트(Effect)를 반환하여 다음 동작을 유발할 수 있다. (아래 코드는 TCA의 이전 버전 구문일 수 있으며, 현재는 @Reducer 매크로 등을 사용한다.)</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// TCA 예시 (개념 설명용)</span>\n<span class=\"kt\">Reduce</span> <span class=\"p\">{</span> <span class=\"n\">state</span><span class=\"p\">,</span> <span class=\"n\">action</span> <span class=\"k\">in</span>\n  <span class=\"k\">switch</span> <span class=\"n\">action</span> <span class=\"p\">{</span>\n  <span class=\"k\">case</span> <span class=\"o\">.</span><span class=\"nv\">buttonTapped</span><span class=\"p\">:</span>\n    <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">isLoading</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n    <span class=\"c1\">// 이펙트를 반환하여 비동기 작업 후 다른 액션(.dataLoaded)을 발생시킴</span>\n    <span class=\"k\">return</span> <span class=\"o\">.</span><span class=\"n\">run</span> <span class=\"p\">{</span> <span class=\"n\">send</span> <span class=\"k\">in</span>\n      <span class=\"k\">let</span> <span class=\"nv\">data</span> <span class=\"o\">=</span> <span class=\"k\">try</span> <span class=\"k\">await</span> <span class=\"n\">apiClient</span><span class=\"o\">.</span><span class=\"nf\">fetchData</span><span class=\"p\">()</span>\n      <span class=\"k\">await</span> <span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">dataLoaded</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">))</span>\n    <span class=\"p\">}</span>\n  <span class=\"k\">case</span> <span class=\"kd\">let</span> <span class=\"o\">.</span><span class=\"nf\">dataLoaded</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">):</span>\n    <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">isLoading</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n    <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">data</span>\n    <span class=\"k\">return</span> <span class=\"o\">.</span><span class=\"k\">none</span> <span class=\"c1\">// 추가 액션 없음</span>\n  <span class=\"c1\">// ...</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이러한 ‘액션 후 연쇄 액션’ 개념을 안드로이드에서 Flow와 제가 만든 Action 시스템으로 구현해보고자 했다. 하지만 여기서 두 가지 주요 문제가 발생했다.</p>\n\n<ol>\n  <li>자동 nextAction 호출로 인한 문제:\n    <ul>\n      <li>ViewModel의 reducer 함수가 반환하는 값을 기반으로 시스템이 자동으로 다음 액션(nextAction)을 발생시키도록 설계했더니, 개발자가 이 동작 방식을 정확히 이해하고 사용해야 하는 부담이 늘었다. 알아야 할 규칙이 많아진 것.</li>\n      <li>결정적으로, nextAction을 잘못 지정하거나 reducer 로직에 실수가 있으면 무한 루프에 빠질 위험이 있었다. 디버깅이 불가능한 것은 아니지만, 코드 설계상 예측 가능한 문제가 쉽게 발생할 수 있는 구조였다.</li>\n    </ul>\n  </li>\n  <li>싱글턴 Action 스트림과 Lifecycle 동기화 문제:\n    <ul>\n      <li>앱 전체에서 단 하나의 Action 스트림(FlowCaActionStream)을 싱글턴으로 사용하다 보니, 새로운 Activity가 실행되거나 Composable Navigation 라이브러리(like Navigation-Compose)를 통해 화면이 전환될 때 문제가 발생했다.</li>\n      <li>예를 들어, Activity A와 Activity B가 있고 각각 여러 Composable 화면(Screen)을 가지고 있다고 가정해 보자. 사용자가 Activity B에 있더라도, 백그라운드의 Activity A에 속한 ViewModel들이 여전히 싱글턴 Action 스트림을 구독하고 있을 수 있다. 만약 특정 Action이 Activity B에서 발생했는데, Activity A의 ViewModel도 해당 Action 타입에 대해 필터링 로직(filterIsInstance)을 가지고 있다면, 의도치 않게 Activity A의 ViewModel에서도 해당 Action이 처리될 수 있다. (물론 reducer 로직 내에서 현재 화면 상태 등을 체크하여 방어할 수는 있겠지만, 근본적으로 불필요한 구독 및 처리 시도가 발생한다.)</li>\n      <li>이는 특히 Alert, Toast, Router(화면 전환)와 같이 앱 전역적으로 영향을 줄 수 있는 Side Effect 처리 시 동기화 문제를 일으킬 수 있다. ViewModel의 생명주기(viewModelScope)는 일반적으로 Composable의 생명주기보다 길기 때문에 이 문제가 더 두드러진다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>이 두 가지 문제를 어떻게 해결했는지 구체적으로 설명하겠다.</p>\n\n<p><br /></p>\n\n<h2>문제점 1 - 무한 루프 가능성 해결하기</h2>\n\n<p>무한 루프 발생 가능성을 제거하기 위해 기존 CaViewModel의 flowAction 처리 방식에서 문제의 소지가 있는 부분을 수정했다.</p>\n\n<p>기존 코드 (문제 발생 가능성 있음):</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"nc\">ACTION</span> <span class=\"p\">:</span> <span class=\"nc\">CaAction</span><span class=\"p\">,</span> <span class=\"nc\">SIDE_EFFECT</span> <span class=\"p\">:</span> <span class=\"nc\">CaSideEffect</span><span class=\"p\">&gt;(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">flowCaActionStream</span><span class=\"p\">:</span> <span class=\"nc\">FlowCaActionStream</span><span class=\"p\">,</span> <span class=\"c1\">// 'private' 추가 (캡슐화)</span>\n    <span class=\"n\">actionClass</span><span class=\"p\">:</span> <span class=\"nc\">KClass</span><span class=\"p\">&lt;</span><span class=\"nc\">ACTION</span><span class=\"p\">&gt;,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\n    <span class=\"nd\">@VisibleForTesting</span>\n    <span class=\"kd\">val</span> <span class=\"py\">flowAction</span> <span class=\"k\">by</span> <span class=\"nf\">lazy</span><span class=\"p\">(</span><span class=\"nc\">LazyThreadSafetyMode</span><span class=\"p\">.</span><span class=\"nc\">NONE</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">flowCaActionStream</span><span class=\"p\">.</span><span class=\"nf\">flowAction</span><span class=\"p\">()</span>\n            <span class=\"p\">.</span><span class=\"nf\">filterIsInstance</span><span class=\"p\">(</span><span class=\"n\">actionClass</span><span class=\"p\">)</span> <span class=\"c1\">// 1. 해당 ViewModel이 처리할 Action만 필터링</span>\n            <span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"n\">action</span> <span class=\"p\">-&gt;</span> <span class=\"c1\">// 2. reducer를 호출하고, 그 결과를 반환 (문제의 소지)</span>\n                <span class=\"nf\">reducer</span><span class=\"p\">(</span><span class=\"n\">action</span> <span class=\"p\">=</span> <span class=\"n\">action</span><span class=\"p\">)</span> <span class=\"c1\">// reducer가 다음 Action을 반환한다고 가정</span>\n            <span class=\"p\">}</span>\n            <span class=\"p\">.</span><span class=\"nf\">onEach</span> <span class=\"p\">{</span> <span class=\"n\">nextActionToDispatch</span> <span class=\"p\">-&gt;</span> <span class=\"c1\">// 3. map에서 반환된 다음 Action을 자동으로 전파 (문제!)</span>\n                <span class=\"n\">flowCaActionStream</span><span class=\"p\">.</span><span class=\"nf\">nextAction</span><span class=\"p\">(</span><span class=\"n\">nextActionToDispatch</span><span class=\"p\">)</span> <span class=\"c1\">// 무한 루프 가능 지점</span>\n            <span class=\"p\">}</span>\n            <span class=\"c1\">// .launchIn(viewModelScope) // 실제로는 여기서 launch 되어야 함</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// reducer 함수가 다음 Action을 반환하는 형태였다고 가정</span>\n    <span class=\"k\">abstract</span> <span class=\"k\">suspend</span> <span class=\"k\">fun</span> <span class=\"nf\">reducer</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">ACTION</span><span class=\"p\">):</span> <span class=\"nc\">CaAction</span><span class=\"p\">?</span> <span class=\"c1\">// 예시: 반환 타입이 다음 Action</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>수정된 코드:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"nc\">CA_ACTION</span> <span class=\"p\">:</span> <span class=\"nc\">CaAction</span><span class=\"p\">&gt;(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">flowCaActionStream</span><span class=\"p\">:</span> <span class=\"nc\">FlowCaActionStream</span><span class=\"p\">,</span>\n    <span class=\"n\">actionClass</span><span class=\"p\">:</span> <span class=\"nc\">KClass</span><span class=\"p\">&lt;</span><span class=\"nc\">CA_ACTION</span><span class=\"p\">&gt;,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\n    <span class=\"c1\">// Action 처리를 위한 Flow (자동 nextAction 로직 제거)</span>\n    <span class=\"nd\">@VisibleForTesting</span>\n    <span class=\"k\">internal</span> <span class=\"kd\">val</span> <span class=\"py\">actionProcessingFlow</span> <span class=\"k\">by</span> <span class=\"nf\">lazy</span><span class=\"p\">(</span><span class=\"nc\">LazyThreadSafetyMode</span><span class=\"p\">.</span><span class=\"nc\">NONE</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 'internal'로 변경하고 이름 명확화</span>\n        <span class=\"n\">flowCaActionStream</span><span class=\"p\">.</span><span class=\"nf\">flowAction</span><span class=\"p\">()</span>\n            <span class=\"p\">.</span><span class=\"nf\">filterIsInstance</span><span class=\"p\">(</span><span class=\"n\">actionClass</span><span class=\"p\">)</span> <span class=\"c1\">// 1. 처리할 Action 필터링</span>\n            <span class=\"p\">.</span><span class=\"nf\">onEach</span> <span class=\"p\">{</span> <span class=\"n\">action</span> <span class=\"p\">-&gt;</span> <span class=\"c1\">// 2. map 대신 onEach 사용. 각 Action에 대해 reducer만 실행 (반환값 사용 안 함)</span>\n                <span class=\"nf\">reducer</span><span class=\"p\">(</span><span class=\"n\">action</span> <span class=\"p\">=</span> <span class=\"n\">action</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n            <span class=\"c1\">// 3. 자동 nextAction 전파 로직 제거됨</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// reducer 함수는 이제 Side Effect 처리나 상태 변경에만 집중 (반환값 없음)</span>\n    <span class=\"k\">abstract</span> <span class=\"k\">suspend</span> <span class=\"k\">fun</span> <span class=\"nf\">reducer</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">CA_ACTION</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">// 다음 Action을 명시적으로 전파하고 싶을 때 호출하는 함수 추가</span>\n    <span class=\"k\">protected</span> <span class=\"k\">fun</span> <span class=\"nf\">nextAction</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">CaAction</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 'protected'로 변경하여 자식 클래스에서만 사용하도록 제한</span>\n        <span class=\"n\">flowCaActionStream</span><span class=\"p\">.</span><span class=\"nf\">nextAction</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 실제 Flow 구독 시작/취소는 별도 관리 (아래 Lifecycle 해결 부분 참조)</span>\n    <span class=\"nd\">@VisibleForTesting</span>\n    <span class=\"kd\">var</span> <span class=\"py\">actionProcessingJob</span><span class=\"p\">:</span> <span class=\"nc\">Job</span><span class=\"p\">?</span> <span class=\"p\">=</span> <span class=\"k\">null</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>수정 내용 요약:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">map</code> -&gt; <code class=\"language-plaintext highlighter-rouge\">onEach</code> 변경: <code class=\"language-plaintext highlighter-rouge\">reducer</code> 함수가 다음 Action을 반환하고 이를 <code class=\"language-plaintext highlighter-rouge\">map</code> 연산자가 받아 downstream로 흘려보내는 구조를 제거했다. 대신 onEach를 사용하여 각 Action에 대해 reducer 함수를 실행만 하도록 변경다. 이로써 reducer의 반환값과 관계없이 자동 nextAction 호출 가능성이 사라졌다.</li>\n  <li>명시적 <code class=\"language-plaintext highlighter-rouge\">nextAction</code> 함수 추가: 연쇄적인 Action 전파가 필요한 경우, 개발자가 <code class=\"language-plaintext highlighter-rouge\">reducer</code> 함수 내에서 직접 <code class=\"language-plaintext highlighter-rouge\">nextAction(action)</code> 함수를 호출하도록 변경했다. 이는 시스템에 의한 암묵적인 동작 대신, 개발자의 명확한 의도에 따라 다음 Action이 발생하도록 하여 코드의 예측 가능성을 높인다.</li>\n</ul>\n\n<p>이제 reducer 내에서 다음과 같이 명시적으로 다음 Action을 지정해야 한다.</p>\n\n<pre><code class=\"language-koltin\">override suspend fun reducer(action: MyAction) {\n    when (action) {\n        is MyAction.ButtonClick -&gt; {\n            // 예시: 버튼 클릭 후 특정 조건 만족 시 Alert 표시 Action 전파\n            if (shouldShowAlert()) {\n                nextAction(CommonUiAction.ShowAlert(\"버튼 클릭됨!\")) // 명시적으로 nextAction 호출\n            }\n        }\n        // ... 다른 Action 처리\n    }\n}\n</code></pre>\n\n<p>이 변경으로 시스템적인 무한 루프 발생 가능성은 제거되었고, 코드의 흐름이 더 명확해졌다.</p>\n\n<p><br /></p>\n\n<h2>문제점 2 - Lifecycle 문제 해결하기</h2>\n\n<p>싱글턴 Action 스트림(FlowCaActionStream) 사용 시 발생하는 Lifecycle 동기화 문제를 해결하기 위해, Composable의 Lifecycle에 맞춰 ViewModel의 Action 스트림 구독을 시작하고 중지하는 방식을 도입했다.</p>\n\n<p>문제 상황: Activity A와 B가 있을 때, Activity B가 화면에 보이는 동안에도 백그라운드의 Activity A에 있는 ViewModel이 Action 스트림을 계속 구독하고 있으면, Activity B에서 발생한 Action이 Activity A의 ViewModel에게도 전달될 수 있다. (물론 filterIsInstance로 타입 필터링은 되지만, 같은 타입의 Action을 여러 화면에서 사용한다면 문제가 된다.)</p>\n\n<p><img src=\"/images/posts/2025/Android-Architecture-02/sample_01.jpg\" alt=\"sample_01\" /></p>\n\n<p><br /></p>\n\n<h3>해결 방안: Lifecycle에 따른 구독 제어</h3>\n\n<p>Composable의 Lifecycle 상태(특히 <code class=\"language-plaintext highlighter-rouge\">ON_RESUME</code>, <code class=\"language-plaintext highlighter-rouge\">ON_PAUSE</code>)에 맞춰 ViewModel 내 Action 스트림(<code class=\"language-plaintext highlighter-rouge\">actionProcessingFlow</code>)의 구독(Job)을 시작하고 취소하는 방법을 사용합니다. 이를 위해 <code class=\"language-plaintext highlighter-rouge\">DisposableEffect</code>와 <code class=\"language-plaintext highlighter-rouge\">LocalLifecycleOwner</code>를 활용하는 Helper Composable 함수를 만들었습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">LaunchedLifecycleViewModel</span><span class=\"p\">(</span>\n    <span class=\"n\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;</span> <span class=\"c1\">// 라이프사이클 관리가 필요한 ViewModel</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">lifecycleOwner</span> <span class=\"p\">=</span> <span class=\"nc\">LocalLifecycleOwner</span><span class=\"p\">.</span><span class=\"n\">current</span>\n    <span class=\"nc\">DisposableEffect</span><span class=\"p\">(</span><span class=\"n\">lifecycleOwner</span><span class=\"p\">,</span> <span class=\"n\">viewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// lifecycleOwner와 viewModel이 키</span>\n        <span class=\"kd\">val</span> <span class=\"py\">observer</span> <span class=\"p\">=</span> <span class=\"nc\">LifecycleEventObserver</span> <span class=\"p\">{</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">event</span> <span class=\"p\">-&gt;</span>\n            <span class=\"k\">when</span> <span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"nc\">Lifecycle</span><span class=\"p\">.</span><span class=\"nc\">Event</span><span class=\"p\">.</span><span class=\"nc\">ON_RESUME</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                    <span class=\"c1\">// 화면이 활성화되면 Action 스트림 구독 시작</span>\n                    <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">startActionProcessing</span><span class=\"p\">()</span>\n                <span class=\"p\">}</span>\n                <span class=\"nc\">Lifecycle</span><span class=\"p\">.</span><span class=\"nc\">Event</span><span class=\"p\">.</span><span class=\"nc\">ON_PAUSE</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                    <span class=\"c1\">// 화면이 비활성화되면 Action 스트림 구독 취소</span>\n                    <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">cancelActionProcessing</span><span class=\"p\">()</span>\n                <span class=\"p\">}</span>\n                <span class=\"c1\">// ON_DESTROY는 DisposableEffect의 onDispose에서 처리되거나</span>\n                <span class=\"c1\">// ViewModel의 onCleared에서 처리될 수 있음</span>\n                <span class=\"k\">else</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span> <span class=\"cm\">/* Do nothing for other events */</span> <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">lifecycleOwner</span><span class=\"p\">.</span><span class=\"n\">lifecycle</span><span class=\"p\">.</span><span class=\"nf\">addObserver</span><span class=\"p\">(</span><span class=\"n\">observer</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// Composable이 Composition에서 제거될 때(onDispose) Observer 제거</span>\n        <span class=\"nf\">onDispose</span> <span class=\"p\">{</span>\n            <span class=\"n\">lifecycleOwner</span><span class=\"p\">.</span><span class=\"n\">lifecycle</span><span class=\"p\">.</span><span class=\"nf\">removeObserver</span><span class=\"p\">(</span><span class=\"n\">observer</span><span class=\"p\">)</span>\n            <span class=\"c1\">// 필요하다면 여기서도 cancelActionProcessing() 호출 고려</span>\n            <span class=\"c1\">// viewModel.cancelActionProcessing()</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>그리고 <code class=\"language-plaintext highlighter-rouge\">CaViewModel</code>에 <code class=\"language-plaintext highlighter-rouge\">Action</code> 스트림 구독을 시작하고 취소하는 함수를 추가한다. (<code class=\"language-plaintext highlighter-rouge\">internal</code> 접근 제한자를 사용하여 모듈 외부에서의 직접 호출을 방지한다.)</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"nc\">CA_ACTION</span> <span class=\"p\">:</span> <span class=\"nc\">CaAction</span><span class=\"p\">&gt;(</span>\n    <span class=\"c1\">// ... (이전 코드와 동일)</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\n    <span class=\"c1\">// ... (actionProcessingFlow, reducer, nextAction 등) ...</span>\n\n    <span class=\"nd\">@VisibleForTesting</span>\n    <span class=\"kd\">var</span> <span class=\"py\">actionProcessingJob</span><span class=\"p\">:</span> <span class=\"nc\">Job</span><span class=\"p\">?</span> <span class=\"p\">=</span> <span class=\"k\">null</span> <span class=\"c1\">// 구독 상태를 관리하는 Job</span>\n\n    <span class=\"c1\">// Action 스트림 구독 시작 (ON_RESUME 시 호출됨)</span>\n    <span class=\"k\">internal</span> <span class=\"k\">fun</span> <span class=\"nf\">startActionProcessing</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 이미 실행 중이라면 중복 실행 방지</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">actionProcessingJob</span><span class=\"o\">?.</span><span class=\"n\">isActive</span> <span class=\"p\">==</span> <span class=\"k\">true</span><span class=\"p\">)</span> <span class=\"k\">return</span>\n\n        <span class=\"c1\">// 기존 Job이 있다면 취소 (혹시 모를 상황 대비)</span>\n        <span class=\"nf\">cancelActionProcessing</span><span class=\"p\">()</span>\n\n        <span class=\"c1\">// actionProcessingFlow를 viewModelScope에서 구독 시작</span>\n        <span class=\"n\">actionProcessingJob</span> <span class=\"p\">=</span> <span class=\"n\">actionProcessingFlow</span>\n            <span class=\"p\">.</span><span class=\"nf\">launchIn</span><span class=\"p\">(</span><span class=\"n\">viewModelScope</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// Action 스트림 구독 취소 (ON_PAUSE 시 호출됨)</span>\n    <span class=\"k\">internal</span> <span class=\"k\">fun</span> <span class=\"nf\">cancelActionProcessing</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">actionProcessingJob</span><span class=\"o\">?.</span><span class=\"nf\">cancel</span><span class=\"p\">()</span>\n        <span class=\"n\">actionProcessingJob</span> <span class=\"p\">=</span> <span class=\"k\">null</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// ViewModel이 파괴될 때(onCleared) 확실하게 Job 취소</span>\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">onCleared</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">super</span><span class=\"p\">.</span><span class=\"nf\">onCleared</span><span class=\"p\">()</span>\n        <span class=\"nf\">cancelActionProcessing</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3>위 코드를 활용하는 방법은?</h3>\n\n<p>각 화면의 최상위 Composable에서 ObserveLifecycle 함수를 호출해주어야 한다.</p>\n\n<pre><code class=\"language-koltin\">@Composable\nfun SomeScreen(viewModel: SomeViewModel = hiltViewModel()) {\n    // ViewModel의 Action 구독 라이프사이클 관리\n    LaunchedLifecycleViewModel(viewModel = viewModel)\n\n    // --- 실제 UI ---\n    // val state by viewModel.uiState.collectAsState()\n    // SomeContent(...)\n    // ---\n}\n</code></pre>\n\n<p>개선 아이디어: 매번 ObserveLifecycle(viewModel)를 호출하는 것이 번거롭다면, ViewModel 인스턴스를 얻을 때 자동으로 이 로직을 포함시키는 확장 함수나 위임(delegate)을 고려해볼 수 있다. 예를 들어:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">Some</span><span class=\"p\">(</span><span class=\"n\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">ViewModel</span> <span class=\"p\">=</span> <span class=\"nf\">hiltViewModel</span><span class=\"p\">().</span><span class=\"nc\">Activate</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// Your view</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>또는 hilt를 직접 확장한다면 아래와 같다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 개념적인 아이디어 (구현 필요)</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">inline</span> <span class=\"k\">fun</span> <span class=\"p\">&lt;</span><span class=\"k\">reified</span> <span class=\"nc\">VM</span> <span class=\"p\">:</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;&gt;</span> <span class=\"nf\">hiltViewModelWithLifecycle</span><span class=\"p\">():</span> <span class=\"nc\">VM</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">VM</span> <span class=\"p\">=</span> <span class=\"nf\">hiltViewModel</span><span class=\"p\">()</span>\n    <span class=\"nc\">LaunchedLifecycleViewModel</span><span class=\"p\">(</span><span class=\"n\">viewModel</span> <span class=\"p\">=</span> <span class=\"n\">viewModel</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">viewModel</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 사용 예시</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">SomeViewModel</span> <span class=\"p\">=</span> <span class=\"nf\">hiltViewModelWithLifecycle</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 이제 LaunchedLifecycleViewModel() 호출 불필요</span>\n    <span class=\"c1\">// ... UI ...</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>(Gemini 주의: <code class=\"language-plaintext highlighter-rouge\">hiltViewModelWithLifecycle</code> 같은 함수는 Composable 함수 내에서 다른 Composable 함수(LaunchedLifecycleViewModel)를 호출하는 방식이므로, ViewModel 생성 로직과 Lifecycle 관찰 로직을 분리하는 것이 더 좋을 수 있다. 또는 별도의 진입점 Composable에서 처리하는 방식도 고려할 수 있다.)</p>\n\n<p>고려사항:</p>\n<ul>\n  <li>이 방식은 ViewModel이 간접적으로 UI Lifecycle을 인지하게 되는 것 아니냐는 비판이 있을 수 있다. 하지만 start/cancelActionProcessing 함수 호출 시점은 ViewModel 외부(LaunchedLifecycleViewModel)에서 결정되므로, ViewModel 자체는 Lifecycle 객체를 직접 참조하지 않는다.</li>\n  <li>ON_RESUME / ON_PAUSE 이벤트마다 Job을 취소하고 다시 시작하는 오버헤드가 발생할 수 있다. 하지만 이는 화면이 실제로 보이지 않을 때 불필요한 Action 처리를 방지하는 효과적인 방법 중 하나이다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2>해결했을까?</h2>\n\n<p>위 변경 사항들을 통해 초기 설계에서 발견된 두 가지 주요 문제점을 해결할 수 있었다.</p>\n\n<ul>\n  <li>무한 루프 발생 가능성: <code class=\"language-plaintext highlighter-rouge\">reducer</code> 처리 후 자동 <code class=\"language-plaintext highlighter-rouge\">nextAction</code> 전파 로직을 제거하고, 명시적인 <code class=\"language-plaintext highlighter-rouge\">nextAction</code> 함수 호출 방식으로 변경하여 해결했다.</li>\n  <li>싱글턴 <code class=\"language-plaintext highlighter-rouge\">Action</code> 스트림의 Lifecycle 문제: Composable의 Lifecycle에 맞춰 ViewModel의 Action 스트림 구독을 제어하는 <code class=\"language-plaintext highlighter-rouge\">LaunchedLifecycleViewModel</code> Helper Composable을 도입하여, 비활성 화면에서의 불필요한 Action 처리 가능성을 해결했다.</li>\n</ul>\n\n<p>하지만 항상 더 나은 방법이 있을 수 있다.</p>\n\n<p><br /></p>\n\n<h2>구독하는 더 좋은 방법은 없을까?</h2>\n\n<p><code class=\"language-plaintext highlighter-rouge\">ON_RESUME</code>/<code class=\"language-plaintext highlighter-rouge\">ON_PAUSE</code> 마다 <code class=\"language-plaintext highlighter-rouge\">launchIn</code>으로 <code class=\"language-plaintext highlighter-rouge\">Job</code>을 생성하고 취소하는 방식 대신, Flow의 <code class=\"language-plaintext highlighter-rouge\">stateIn</code> 연산자를 활용하는 방법을 고려해볼 수 있다.</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">stateIn</code> 연산자는 <code class=\"language-plaintext highlighter-rouge\">Flow</code>를 <code class=\"language-plaintext highlighter-rouge\">StateFlow</code>로 변환하며, 구독자(collector)의 유무에 따라 업스트림 Flow의 실행을 제어할 수 있는 SharingStarted 정책을 제공한다. 예를 들어 <code class=\"language-plaintext highlighter-rouge\">SharingStarted.WhileSubscribed()</code> 정책을 사용하면, StateFlow를 구독하는 Composable이 화면에 보이는 동안(<code class=\"language-plaintext highlighter-rouge\">collectAsState</code> 등으로 구독 중)에만 업스트림 Flow(actionProcessingFlow)가 활성화되고, 화면에서 사라지면 자동으로 구독이 중단(cancel)될 수 있다.</p>\n\n<p>이러한 접근 방식은 Slack에서 만든 <a href=\"https://slackhq.github.io/circuit/\">Circuit - link</a> 아키텍처와 유사한 방향으로 흘러갈 수 있다. Circuit에서는 Presenter가 UI State를 Flow로 노출하고, UI 이벤트는 Sink를 통해 Presenter로 전달됩니다. Presenter 내부 로직의 실행 여부는 최종적으로 UI State Flow의 구독 여부에 따라 결정될 수 있다.</p>\n\n<p>skydoves(재웅 님)가 작성한 <a href=\"https://proandroiddev.com/loading-initial-data-in-launchedeffect-vs-viewmodel-f1747c20ce62\">Loading Initial Data in LaunchedEffect vs. ViewModel - link</a> 글에서도 LaunchedEffect 내에서의 데이터 로딩과 ViewModel의 stateIn을 활용한 데이터 로딩 방식을 비교하며 유사한 아이디어를 엿볼 수 있다.</p>\n\n<p>결국 상태(State)를 중심으로 데이터 흐름을 관리하고, 그 상태의 구독 생명주기에 맞춰 연관된 로직(Action 처리 등)의 실행 여부를 제어하는 방식이 더 Compose 친화적이고 효율적일 수 있다.</p>\n\n<p>저는 현재 설계에서 상태 관리와 이벤트 처리를 분리하고 싶어 이 방식(Circuit이나 stateIn을 전면적으로 활용하는 방식)까지 적용하지는 않았지만, 궁극적으로는 이와 유사한 형태로 발전할 수 있지 않을까 생각하고 있다.</p>\n\n<p><br /></p>\n\n<h2>Next</h2>\n\n<p>이번 글에서는 기존 Composable Architecture 설계에서 발견된 2가지 문제점을 파악하고 이를 해결하기 위해 어떤 고민과 선택을 했는지 정리해보았다.</p>\n\n<p>다음 글에서는 이 아키텍처를 활용하여 구현한 구체적인 기능들을 다룰 예정이다.</p>\n\n<ul>\n  <li>코드에는 이미 있지만 Alert/Toast를 포함하고있다.</li>\n  <li>Router(액티비티, 네비게이션)를 처리하기 위한 부분도 포함하고있다.</li>\n</ul>\n\n<p>이제 다음 글에서 이 두개를 정리할 계획이다.</p>\n\n<p><br /></p>\n\n<h2>작성 글 이어보기</h2>\n\n<ul>\n  <li><a href=\"https://thdev.tech/architecture/2025/02/02/Android-Architecture-01/\">컴포즈에 사용할 Composable Architecutre 설명(리엑트?)</a></li>\n  <li><a href=\"https://thdev.tech/architecture/2025/04/15/Android-Architecture-02/\">Composable Architecutre는 만들었는데 문제가 있었네? 개선해보자.</a></li>\n  <li>예고 - Composable Architecutre를 활용한 Alert/Toast?</li>\n  <li>예고 - Composable Architecutre를 활용한 Router?</li>\n</ul>\n\n",
        "contentSnippet": "이전 글에서 Composable Architecutre를 소개하는 내용을 담아보았는데, 몇 가지 문제점을 발견하여 이를 개선한 내용을 다시 정리하는 글이다.\n크게 2가지 문제점을 확인하였다.\nViewModel 내 Reducer 처리 후 자동 next\nAction 스트림 처리를 위한 싱글턴 활용 시 Lifecycle 문제\n이 2가지 문제점을 해결하기 위해 코드를 어떻게 수정했는지, 그리고 더 나은 방법은 없을지 고민한 과정을 정리해본다.\n이 글에서는\n기존 아키텍처의 구조적 문제점을 파악한다.\n문제 해결 과정과 더 나은 구조에 대한 고민을 공유한다.\n기본적인 내용을 담지 않고있어 앞선 글을 참고하면 좋다.\n이전 글\n컴포즈에 사용할 Composable Architecutre 설명(리엑트?)\nComposable Architecutre는 만들었는데 문제가 있었네? 개선해보자.\n\nAction이란?\nView와 ViewModel 사이의 통신을 어떻게 더 간결하게 할 수 있을까? Jetpack Compose 환경에서는 CompositionLocal - link을 활용하는 방법이 있다. 저는 이 방식을 응용하여 Composable 함수 어디서든 이벤트 처리를 쉽게 호출할 수 있도록 Action이라는 개념을 만들었다.\nFlow를 기반으로 한 Action을 사용한 이유를 설명하기 위해, 먼저 일반적인 View-ViewModel 간 통신 방식의 예시 코드를 살펴보자.\nComposable 함수에서 ViewModel 인스턴스를 파라미터로 직접 전달받아 사용하는 것이 일반적이다. 하지만 이 방식은 Composable 함수의 깊이가 깊어지거나 개수가 많아질수록 ViewModel을 어디까지 전달해야 할지 고민이 필요하며, 구조가 복잡해지면 자연스럽게 보일러플레이트 코드가 늘어나는 단점이 있다.\nViewModel을 직접 사용한 함수 호출\n\n@Composable\nfun SomeScreen(someViewModel: SomeViewModel) {\n  Button(onClick = { someViewModel.doSomething() })\n  Button(onClick = { someViewModel.doSomethingTwo() })\n  Button(onClick = { someViewModel.doSomethingThree() })\n}\n\nclass SomeViewModel : ViewModel() {\n  fun doSomething() { /* ... */ }\n  fun doSomethingTwo() { /* ... */ }\n  fun doSomethingThree() { /* ... */ }\n}\n\n\nViewModel 함수를 sealed interface로 통합하여 호출하는 경우\n\nsealed interface SomeAction {\n    data object ActionOne : SomeAction\n    data object ActionTwo : SomeAction\n    data class ActionThree(val item: Any) : SomeAction\n}\n\n@Composable\nfun SomeScreen(someViewModel: SomeViewModel) {\n  val item = remember { /* ... */ } // 예시 데이터\n  Button(onClick = { someViewModel.dispatch(SomeAction.ActionOne) })\n  Button(onClick = { someViewModel.dispatch(SomeAction.ActionTwo) })\n  Button(onClick = { someViewModel.dispatch(SomeAction.ActionThree(item)) })\n}\n\nclass SomeViewModel : ViewModel() {\n  fun dispatch(action: SomeAction) {\n    when (action) {\n      is SomeAction.ActionOne -> { /* ... */ }\n      is SomeAction.ActionTwo -> { /* ... */ }\n      is SomeAction.ActionThree -> { /* ... */ }\n    }\n  }\n}\n\n\n제가 활용하는 방식 (CompositionLocal 활용)\n위 방식들은 ViewModel을 계속 전달하거나, onClick: () -> Unit 같은 콜백을 계속 만들어 전달해야 하는 번거로움이 있다. 특히 콜백 방식은 이벤트 통합 과정에서 N개의 고차 함수(Higher-Order function)가 만들어질 수 있다.\n그래서 Compose에서 제공하는 Locally scoped - link을 활용하여 Action 객체에 쉽게 접근하는 방법을 사용하고 있습니다. (자세한 활용법은 이전 글 컴포즈에 사용할 Composable Architecture 설명을 참고해주세요.)\n\n// Action 정의 (예시)\nsealed interface MyAction : CaAction { // CaAction은 마커 인터페이스 역할\n    data object ButtonClick : MyAction\n    data class TextTyped(val text: String) : MyAction\n    data class SwitchChanged(val isOn: Boolean) : MyAction\n}\n\n// Composable View\n@Composable\nfun SomeScreen(uiState: UiState) {\n  // CompositionLocal을 통해 Action 획득\n  val action = LocalAction.current\n\n  Column {\n      Button(onClick = { action.send(MyAction.ButtonClick) }) {\n          Text(\"Click Me\")\n      }\n\n      TextField(\n          value = uiState.textState,\n          onValueChange = {\n              action.send(MyAction.TextTyped(it))\n          }\n      )\n\n      Switch(\n          checked = uiState.switchState,\n          onCheckedChange = {\n              action.send(MyAction.SwitchChanged(it))\n          }\n      )\n  }\n}\n\n// ViewModel\nclass SomeViewModel(\n    private val flowCaActionStream: FlowCaActionStream // Action 스트림 주입\n) : CaViewModel<MyAction>(flowCaActionStream, MyAction::class) { // 수신할 Action 타입 지정\n\n    // CaViewModel 내부에서 flowAction을 통해 MyAction 타입의 이벤트만 필터링하여 수신\n    // reducer 메소드에서 각 Action 처리 로직 구현\n    override suspend fun reducer(action: MyAction) {\n        when (action) {\n            is MyAction.ButtonClick -> {\n                // 버튼 클릭 처리 로직\n                Log.d(\"SomeViewModel\", \"Button Clicked\")\n            }\n\n            is MyAction.TextTyped -> {\n                // 텍스트 입력 처리 로직\n                Log.d(\"SomeViewModel\", \"Text Typed: ${action.text}\")\n            }\n\n            is MyAction.SwitchChanged -> {\n                // 스위치 변경 처리 로직\n                Log.d(\"SomeViewModel\", \"Switch Changed: ${action.isOn}\")\n            }\n        }\n    }\n}\n\n\n\n사용성 측면에서의 개선\n필요한 Action을 LocalAction.current를 통해 어디서든 호출할 수 있으므로, ViewModel 인스턴스를 계속해서 하위 Composable로 전달할 필요가 없어 개발 편의성이 향상될 수 있다.\nCompositionLocal에 적절한 기본값이나 테스트용 구현체를 제공하면 Preview 동작에도 문제가 없다. 다만, Preview에서 특정 UI 요소의 상태 변화나 인터랙션을 테스트하려면, 선언형 UI의 원칙에 따라 Stateless - link한 Composable을 만들고 상태와 이벤트를 외부에서 주입하는 것이 좋다.\n\n// Statefull Composable (ViewModel과 연결)\n@Composable\nfun SomeScreen(viewModel: SomeViewModel = hiltViewModel()) { // Hilt 등 DI 활용 예시\n    val action = LocalActionDispatcher.current // Action 발송기\n    // ViewModel로부터 상태를 구독하거나, 필요한 상태를 여기서 관리\n    val uiState by viewModel.uiState.collectAsState() // 예시 StateFlow\n\n    SomeContent(\n        text = uiState.text,\n        isSwitchOn = uiState.switchState,\n        onButtonClick = action.send(MyAction.ButtonClick),\n        onTextTyped = action.send(MyAction.TextTyped(it)),\n        onSwitchChange = action.send(MyAction.SwitchChanged(it)),\n    )\n}\n\n// Stateless Composable 예시\n@Composable\nfun SomeContent(\n    text: String,\n    isSwitchOn: Boolean,\n    onButtonClick: () -> Unit,\n    onTextTyped: (String) -> Unit,\n    onSwitchChange: (Boolean) -> Unit,\n    modifier: Modifier = Modifier // Modifier 추가 권장\n) {\n    Column(modifier = modifier) {\n        Button(onClick = onButtonClick) { /* ... */ }\n        TextField(value = text, onValueChange = onTextTyped)\n        Switch(checked = isSwitchOn, onCheckedChange = onSwitchChange)\n    }\n}\n\n\n이 방식(Stateless/Statefull 분리 및 CompositionLocal 활용)의 단점은 다음과 같다.\nViewModel에서 모든 UI 인터랙션을 하나의 reducer 함수로 통합 관리하기보다, 각 상태 업데이트 로직과 이벤트 발송 로직이 분리될 수 있다. (이는 관점에 따라 장점일 수도 있다)\n새로운 Action 이벤트를 추가할 때, ViewModel의 reducer에서도 해당 이벤트를 처리하는 로직을 추가해야 한다. (이는 sealed interface 사용 시 컴파일 타임에 강제될 수 있어 오히려 장점이 될 수 있다.)\n하지만 장점은 다음과 같습니다.\n각 UI 요소의 이벤트 발송 책임이 명확해진다.\nStateless Composable은 재사용 및 테스트가 용이하다.\nCompositionLocal을 통해 이벤트 발송 인터페이스 접근이 간편하다.\n\n정리하면\n해결하고 싶었던 지점\nView와 ViewModel 간의 이벤트 전달을 왜 항상 ViewModel 인스턴스를 통해 viewModel.someFunction() 형태로 직접 호출해야 할까?\nComposable 함수의 깊이가 깊어질 때 ViewModel 인스턴스나 콜백 함수를 계속 전달해야 하는 번거로움을 줄일 수 없을까?\n그래서 도입한 Action(CompositionLocal)\n이벤트 처리를 위한 Action 인터페이스와 이를 쉽게 발송(dispatch)할 수 있는 ActionDispatcher를 CompositionLocal로 제공하여, Composable 함수 내에서 발생하는 보일러플레이트를 줄이고자 했다.\n하지만 여전히 해결해야 할 문제가 있는데\n이벤트를 보내는 쪽(View)과 받는 쪽(ViewModel)에서 정확히 어떤 Action 타입을 사용하고 처리할지 명확히 약속이 필요하다. 만약 서로 다른 타입을 사용하거나 누락하면 이벤트가 유실되어 동작하지 않는 치명적인 문제가 발생할 수 있다.\n이 문제를 해결하고 개발 과정에서 실수를 줄이기 위해 sealed interface를 사용하여 Action을 정의하는 방식을 채택했다. sealed interface를 사용하면 ViewModel의 reducer에서 when 식으로 처리할 때 모든 하위 타입을 강제로 구현해야 하므로, 이벤트 누락 가능성을 컴파일 시점에 방지할 수 있다. 이는 UI 동작 관련 테스트 케이스를 일부 줄여줄 수 있는 장점도 있다.\n\n그래서 발견한 문제\nSwift-composable architecture - 링크를 참고하여 아키텍처를 구상하다 보니, Reducer가 특정 액션을 처리한 후 다음 액션을 연쇄적으로 발생시키는 구조를 발견했다.\nSwift Composable Architecture의 코드 예시를 보면, Reduce 클로저 내에서 .send나 다른 이펙트(Effect)를 반환하여 다음 동작을 유발할 수 있다. (아래 코드는 TCA의 이전 버전 구문일 수 있으며, 현재는 @Reducer 매크로 등을 사용한다.)\n\n// TCA 예시 (개념 설명용)\nReduce { state, action in\n  switch action {\n  case .buttonTapped:\n    state.isLoading = true\n    // 이펙트를 반환하여 비동기 작업 후 다른 액션(.dataLoaded)을 발생시킴\n    return .run { send in\n      let data = try await apiClient.fetchData()\n      await send(.dataLoaded(data))\n    }\n  case let .dataLoaded(data):\n    state.isLoading = false\n    state.data = data\n    return .none // 추가 액션 없음\n  // ...\n  }\n}\n\n\n이러한 ‘액션 후 연쇄 액션’ 개념을 안드로이드에서 Flow와 제가 만든 Action 시스템으로 구현해보고자 했다. 하지만 여기서 두 가지 주요 문제가 발생했다.\n자동 nextAction 호출로 인한 문제:\n    \nViewModel의 reducer 함수가 반환하는 값을 기반으로 시스템이 자동으로 다음 액션(nextAction)을 발생시키도록 설계했더니, 개발자가 이 동작 방식을 정확히 이해하고 사용해야 하는 부담이 늘었다. 알아야 할 규칙이 많아진 것.\n결정적으로, nextAction을 잘못 지정하거나 reducer 로직에 실수가 있으면 무한 루프에 빠질 위험이 있었다. 디버깅이 불가능한 것은 아니지만, 코드 설계상 예측 가능한 문제가 쉽게 발생할 수 있는 구조였다.\n싱글턴 Action 스트림과 Lifecycle 동기화 문제:\n    \n앱 전체에서 단 하나의 Action 스트림(FlowCaActionStream)을 싱글턴으로 사용하다 보니, 새로운 Activity가 실행되거나 Composable Navigation 라이브러리(like Navigation-Compose)를 통해 화면이 전환될 때 문제가 발생했다.\n예를 들어, Activity A와 Activity B가 있고 각각 여러 Composable 화면(Screen)을 가지고 있다고 가정해 보자. 사용자가 Activity B에 있더라도, 백그라운드의 Activity A에 속한 ViewModel들이 여전히 싱글턴 Action 스트림을 구독하고 있을 수 있다. 만약 특정 Action이 Activity B에서 발생했는데, Activity A의 ViewModel도 해당 Action 타입에 대해 필터링 로직(filterIsInstance)을 가지고 있다면, 의도치 않게 Activity A의 ViewModel에서도 해당 Action이 처리될 수 있다. (물론 reducer 로직 내에서 현재 화면 상태 등을 체크하여 방어할 수는 있겠지만, 근본적으로 불필요한 구독 및 처리 시도가 발생한다.)\n이는 특히 Alert, Toast, Router(화면 전환)와 같이 앱 전역적으로 영향을 줄 수 있는 Side Effect 처리 시 동기화 문제를 일으킬 수 있다. ViewModel의 생명주기(viewModelScope)는 일반적으로 Composable의 생명주기보다 길기 때문에 이 문제가 더 두드러진다.\n이 두 가지 문제를 어떻게 해결했는지 구체적으로 설명하겠다.\n\n문제점 1 - 무한 루프 가능성 해결하기\n무한 루프 발생 가능성을 제거하기 위해 기존 CaViewModel의 flowAction 처리 방식에서 문제의 소지가 있는 부분을 수정했다.\n기존 코드 (문제 발생 가능성 있음):\n\nabstract class CaViewModel<ACTION : CaAction, SIDE_EFFECT : CaSideEffect>(\n    private val flowCaActionStream: FlowCaActionStream, // 'private' 추가 (캡슐화)\n    actionClass: KClass<ACTION>,\n) : ViewModel() {\n\n    @VisibleForTesting\n    val flowAction by lazy(LazyThreadSafetyMode.NONE) {\n        flowCaActionStream.flowAction()\n            .filterIsInstance(actionClass) // 1. 해당 ViewModel이 처리할 Action만 필터링\n            .map { action -> // 2. reducer를 호출하고, 그 결과를 반환 (문제의 소지)\n                reducer(action = action) // reducer가 다음 Action을 반환한다고 가정\n            }\n            .onEach { nextActionToDispatch -> // 3. map에서 반환된 다음 Action을 자동으로 전파 (문제!)\n                flowCaActionStream.nextAction(nextActionToDispatch) // 무한 루프 가능 지점\n            }\n            // .launchIn(viewModelScope) // 실제로는 여기서 launch 되어야 함\n    }\n\n    // reducer 함수가 다음 Action을 반환하는 형태였다고 가정\n    abstract suspend fun reducer(action: ACTION): CaAction? // 예시: 반환 타입이 다음 Action\n}\n\n\n수정된 코드:\n\nabstract class CaViewModel<CA_ACTION : CaAction>(\n    private val flowCaActionStream: FlowCaActionStream,\n    actionClass: KClass<CA_ACTION>,\n) : ViewModel() {\n\n    // Action 처리를 위한 Flow (자동 nextAction 로직 제거)\n    @VisibleForTesting\n    internal val actionProcessingFlow by lazy(LazyThreadSafetyMode.NONE) { // 'internal'로 변경하고 이름 명확화\n        flowCaActionStream.flowAction()\n            .filterIsInstance(actionClass) // 1. 처리할 Action 필터링\n            .onEach { action -> // 2. map 대신 onEach 사용. 각 Action에 대해 reducer만 실행 (반환값 사용 안 함)\n                reducer(action = action)\n            }\n            // 3. 자동 nextAction 전파 로직 제거됨\n    }\n\n    // reducer 함수는 이제 Side Effect 처리나 상태 변경에만 집중 (반환값 없음)\n    abstract suspend fun reducer(action: CA_ACTION)\n\n    // 다음 Action을 명시적으로 전파하고 싶을 때 호출하는 함수 추가\n    protected fun nextAction(action: CaAction) { // 'protected'로 변경하여 자식 클래스에서만 사용하도록 제한\n        flowCaActionStream.nextAction(action)\n    }\n\n    // 실제 Flow 구독 시작/취소는 별도 관리 (아래 Lifecycle 해결 부분 참조)\n    @VisibleForTesting\n    var actionProcessingJob: Job? = null\n}\n\n\n수정 내용 요약:\nmap -> onEach 변경: reducer 함수가 다음 Action을 반환하고 이를 map 연산자가 받아 downstream로 흘려보내는 구조를 제거했다. 대신 onEach를 사용하여 각 Action에 대해 reducer 함수를 실행만 하도록 변경다. 이로써 reducer의 반환값과 관계없이 자동 nextAction 호출 가능성이 사라졌다.\n명시적 nextAction 함수 추가: 연쇄적인 Action 전파가 필요한 경우, 개발자가 reducer 함수 내에서 직접 nextAction(action) 함수를 호출하도록 변경했다. 이는 시스템에 의한 암묵적인 동작 대신, 개발자의 명확한 의도에 따라 다음 Action이 발생하도록 하여 코드의 예측 가능성을 높인다.\n이제 reducer 내에서 다음과 같이 명시적으로 다음 Action을 지정해야 한다.\noverride suspend fun reducer(action: MyAction) {\n    when (action) {\n        is MyAction.ButtonClick -> {\n            // 예시: 버튼 클릭 후 특정 조건 만족 시 Alert 표시 Action 전파\n            if (shouldShowAlert()) {\n                nextAction(CommonUiAction.ShowAlert(\"버튼 클릭됨!\")) // 명시적으로 nextAction 호출\n            }\n        }\n        // ... 다른 Action 처리\n    }\n}\n\n이 변경으로 시스템적인 무한 루프 발생 가능성은 제거되었고, 코드의 흐름이 더 명확해졌다.\n\n문제점 2 - Lifecycle 문제 해결하기\n싱글턴 Action 스트림(FlowCaActionStream) 사용 시 발생하는 Lifecycle 동기화 문제를 해결하기 위해, Composable의 Lifecycle에 맞춰 ViewModel의 Action 스트림 구독을 시작하고 중지하는 방식을 도입했다.\n문제 상황: Activity A와 B가 있을 때, Activity B가 화면에 보이는 동안에도 백그라운드의 Activity A에 있는 ViewModel이 Action 스트림을 계속 구독하고 있으면, Activity B에서 발생한 Action이 Activity A의 ViewModel에게도 전달될 수 있다. (물론 filterIsInstance로 타입 필터링은 되지만, 같은 타입의 Action을 여러 화면에서 사용한다면 문제가 된다.)\n\n\n해결 방안: Lifecycle에 따른 구독 제어\nComposable의 Lifecycle 상태(특히 ON_RESUME, ON_PAUSE)에 맞춰 ViewModel 내 Action 스트림(actionProcessingFlow)의 구독(Job)을 시작하고 취소하는 방법을 사용합니다. 이를 위해 DisposableEffect와 LocalLifecycleOwner를 활용하는 Helper Composable 함수를 만들었습니다.\n\n@Composable\nfun LaunchedLifecycleViewModel(\n    viewModel: CaViewModel<*> // 라이프사이클 관리가 필요한 ViewModel\n) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    DisposableEffect(lifecycleOwner, viewModel) { // lifecycleOwner와 viewModel이 키\n        val observer = LifecycleEventObserver { _, event ->\n            when (event) {\n                Lifecycle.Event.ON_RESUME -> {\n                    // 화면이 활성화되면 Action 스트림 구독 시작\n                    viewModel.startActionProcessing()\n                }\n                Lifecycle.Event.ON_PAUSE -> {\n                    // 화면이 비활성화되면 Action 스트림 구독 취소\n                    viewModel.cancelActionProcessing()\n                }\n                // ON_DESTROY는 DisposableEffect의 onDispose에서 처리되거나\n                // ViewModel의 onCleared에서 처리될 수 있음\n                else -> { /* Do nothing for other events */ }\n            }\n        }\n        lifecycleOwner.lifecycle.addObserver(observer)\n\n        // Composable이 Composition에서 제거될 때(onDispose) Observer 제거\n        onDispose {\n            lifecycleOwner.lifecycle.removeObserver(observer)\n            // 필요하다면 여기서도 cancelActionProcessing() 호출 고려\n            // viewModel.cancelActionProcessing()\n        }\n    }\n}\n\n\n그리고 CaViewModel에 Action 스트림 구독을 시작하고 취소하는 함수를 추가한다. (internal 접근 제한자를 사용하여 모듈 외부에서의 직접 호출을 방지한다.)\n\nabstract class CaViewModel<CA_ACTION : CaAction>(\n    // ... (이전 코드와 동일)\n) : ViewModel() {\n\n    // ... (actionProcessingFlow, reducer, nextAction 등) ...\n\n    @VisibleForTesting\n    var actionProcessingJob: Job? = null // 구독 상태를 관리하는 Job\n\n    // Action 스트림 구독 시작 (ON_RESUME 시 호출됨)\n    internal fun startActionProcessing() {\n        // 이미 실행 중이라면 중복 실행 방지\n        if (actionProcessingJob?.isActive == true) return\n\n        // 기존 Job이 있다면 취소 (혹시 모를 상황 대비)\n        cancelActionProcessing()\n\n        // actionProcessingFlow를 viewModelScope에서 구독 시작\n        actionProcessingJob = actionProcessingFlow\n            .launchIn(viewModelScope)\n    }\n\n    // Action 스트림 구독 취소 (ON_PAUSE 시 호출됨)\n    internal fun cancelActionProcessing() {\n        actionProcessingJob?.cancel()\n        actionProcessingJob = null\n    }\n\n    // ViewModel이 파괴될 때(onCleared) 확실하게 Job 취소\n    override fun onCleared() {\n        super.onCleared()\n        cancelActionProcessing()\n    }\n}\n\n\n위 코드를 활용하는 방법은?\n각 화면의 최상위 Composable에서 ObserveLifecycle 함수를 호출해주어야 한다.\n@Composable\nfun SomeScreen(viewModel: SomeViewModel = hiltViewModel()) {\n    // ViewModel의 Action 구독 라이프사이클 관리\n    LaunchedLifecycleViewModel(viewModel = viewModel)\n\n    // --- 실제 UI ---\n    // val state by viewModel.uiState.collectAsState()\n    // SomeContent(...)\n    // ---\n}\n\n개선 아이디어: 매번 ObserveLifecycle(viewModel)를 호출하는 것이 번거롭다면, ViewModel 인스턴스를 얻을 때 자동으로 이 로직을 포함시키는 확장 함수나 위임(delegate)을 고려해볼 수 있다. 예를 들어:\n\n@Composable\nfun Some(viewModel: ViewModel = hiltViewModel().Activate()) {\n  // Your view\n}\n\n\n또는 hilt를 직접 확장한다면 아래와 같다.\n\n// 개념적인 아이디어 (구현 필요)\n@Composable\ninline fun <reified VM : CaViewModel<*>> hiltViewModelWithLifecycle(): VM {\n    val viewModel: VM = hiltViewModel()\n    LaunchedLifecycleViewModel(viewModel = viewModel)\n    return viewModel\n}\n\n// 사용 예시\n@Composable\nfun SomeScreen(viewModel: SomeViewModel = hiltViewModelWithLifecycle()) {\n    // 이제 LaunchedLifecycleViewModel() 호출 불필요\n    // ... UI ...\n}\n\n\n(Gemini 주의: hiltViewModelWithLifecycle 같은 함수는 Composable 함수 내에서 다른 Composable 함수(LaunchedLifecycleViewModel)를 호출하는 방식이므로, ViewModel 생성 로직과 Lifecycle 관찰 로직을 분리하는 것이 더 좋을 수 있다. 또는 별도의 진입점 Composable에서 처리하는 방식도 고려할 수 있다.)\n고려사항:\n이 방식은 ViewModel이 간접적으로 UI Lifecycle을 인지하게 되는 것 아니냐는 비판이 있을 수 있다. 하지만 start/cancelActionProcessing 함수 호출 시점은 ViewModel 외부(LaunchedLifecycleViewModel)에서 결정되므로, ViewModel 자체는 Lifecycle 객체를 직접 참조하지 않는다.\nON_RESUME / ON_PAUSE 이벤트마다 Job을 취소하고 다시 시작하는 오버헤드가 발생할 수 있다. 하지만 이는 화면이 실제로 보이지 않을 때 불필요한 Action 처리를 방지하는 효과적인 방법 중 하나이다.\n\n해결했을까?\n위 변경 사항들을 통해 초기 설계에서 발견된 두 가지 주요 문제점을 해결할 수 있었다.\n무한 루프 발생 가능성: reducer 처리 후 자동 nextAction 전파 로직을 제거하고, 명시적인 nextAction 함수 호출 방식으로 변경하여 해결했다.\n싱글턴 Action 스트림의 Lifecycle 문제: Composable의 Lifecycle에 맞춰 ViewModel의 Action 스트림 구독을 제어하는 LaunchedLifecycleViewModel Helper Composable을 도입하여, 비활성 화면에서의 불필요한 Action 처리 가능성을 해결했다.\n하지만 항상 더 나은 방법이 있을 수 있다.\n\n구독하는 더 좋은 방법은 없을까?\nON_RESUME/ON_PAUSE 마다 launchIn으로 Job을 생성하고 취소하는 방식 대신, Flow의 stateIn 연산자를 활용하는 방법을 고려해볼 수 있다.\nstateIn 연산자는 Flow를 StateFlow로 변환하며, 구독자(collector)의 유무에 따라 업스트림 Flow의 실행을 제어할 수 있는 SharingStarted 정책을 제공한다. 예를 들어 SharingStarted.WhileSubscribed() 정책을 사용하면, StateFlow를 구독하는 Composable이 화면에 보이는 동안(collectAsState 등으로 구독 중)에만 업스트림 Flow(actionProcessingFlow)가 활성화되고, 화면에서 사라지면 자동으로 구독이 중단(cancel)될 수 있다.\n이러한 접근 방식은 Slack에서 만든 Circuit - link 아키텍처와 유사한 방향으로 흘러갈 수 있다. Circuit에서는 Presenter가 UI State를 Flow로 노출하고, UI 이벤트는 Sink를 통해 Presenter로 전달됩니다. Presenter 내부 로직의 실행 여부는 최종적으로 UI State Flow의 구독 여부에 따라 결정될 수 있다.\nskydoves(재웅 님)가 작성한 Loading Initial Data in LaunchedEffect vs. ViewModel - link 글에서도 LaunchedEffect 내에서의 데이터 로딩과 ViewModel의 stateIn을 활용한 데이터 로딩 방식을 비교하며 유사한 아이디어를 엿볼 수 있다.\n결국 상태(State)를 중심으로 데이터 흐름을 관리하고, 그 상태의 구독 생명주기에 맞춰 연관된 로직(Action 처리 등)의 실행 여부를 제어하는 방식이 더 Compose 친화적이고 효율적일 수 있다.\n저는 현재 설계에서 상태 관리와 이벤트 처리를 분리하고 싶어 이 방식(Circuit이나 stateIn을 전면적으로 활용하는 방식)까지 적용하지는 않았지만, 궁극적으로는 이와 유사한 형태로 발전할 수 있지 않을까 생각하고 있다.\n\nNext\n이번 글에서는 기존 Composable Architecture 설계에서 발견된 2가지 문제점을 파악하고 이를 해결하기 위해 어떤 고민과 선택을 했는지 정리해보았다.\n다음 글에서는 이 아키텍처를 활용하여 구현한 구체적인 기능들을 다룰 예정이다.\n코드에는 이미 있지만 Alert/Toast를 포함하고있다.\nRouter(액티비티, 네비게이션)를 처리하기 위한 부분도 포함하고있다.\n이제 다음 글에서 이 두개를 정리할 계획이다.\n\n작성 글 이어보기\n컴포즈에 사용할 Composable Architecutre 설명(리엑트?)\nComposable Architecutre는 만들었는데 문제가 있었네? 개선해보자.\n예고 - Composable Architecutre를 활용한 Alert/Toast?\n예고 - Composable Architecutre를 활용한 Router?",
        "guid": "https://thdev.tech/architecture/2025/04/15/Android-Architecture-02/",
        "isoDate": "2025-04-15T00:00:00.000Z"
      }
    ]
  },
  {
    "name": "김슬기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김광현",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김성빈",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김영우",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강명훈",
    "category": "개인",
    "posts": [
      {
        "title": "Splunk의 Join - 5th",
        "link": "https://kangmyounghun.blogspot.com/2025/04/splunk-join-5th.html",
        "pubDate": "2025-04-13T02:57:00.000Z",
        "author": "강명훈",
        "content": "<div>inner join.</div><div><br /></div>\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixDdh6sq0h7NiY7ekFt67l7iM1xq8xuzAs98M-YfZLGi-RF5u0jJuPt7ZKDvnI2QLHtL8ApWNdZG9BKztDHCP_Icc0AkSCy9D5VDDXr2ByO-OSVFgsjxK5KGhrL2_Whi2fNJmoWUjdSedGCFF60NFAPwO1M8dCuslqlKFPuauk9_V-Y8fEbFnaDDEj7dTQ/s1470/inner_join.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"1470\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixDdh6sq0h7NiY7ekFt67l7iM1xq8xuzAs98M-YfZLGi-RF5u0jJuPt7ZKDvnI2QLHtL8ApWNdZG9BKztDHCP_Icc0AkSCy9D5VDDXr2ByO-OSVFgsjxK5KGhrL2_Whi2fNJmoWUjdSedGCFF60NFAPwO1M8dCuslqlKFPuauk9_V-Y8fEbFnaDDEj7dTQ/s16000/inner_join.png\" /></a></div>\n<div><br /></div><div><span><a name='more'></a></span>left join.</div><br />\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhBMe03aUKkg4gKcHkNA0_SYmAO9Qc_hcPLnmMg31hmS2tsgmWAbPfHsV0ap9GvpdrL1tDkxln4vpLrebn7ON935oJPZJT3G9TDJkFxFUkBKH92N_qoj9KFolOzXj6AQF8j0sc7maki5Fof20iL1eq2tXHp-dIZqI2SZu6DxS08Q1S5iR6Z66si6mVRbROb/s1394/left_join.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"1394\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhBMe03aUKkg4gKcHkNA0_SYmAO9Qc_hcPLnmMg31hmS2tsgmWAbPfHsV0ap9GvpdrL1tDkxln4vpLrebn7ON935oJPZJT3G9TDJkFxFUkBKH92N_qoj9KFolOzXj6AQF8j0sc7maki5Fof20iL1eq2tXHp-dIZqI2SZu6DxS08Q1S5iR6Z66si6mVRbROb/s16000/left_join.png\" /></a></div>\n<div><br /></div><div>교집합 제외한 left join.</div><br />\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiz1UdN6mn1NqtKodNpELfR6Jn4F9aLLlveptkzxioo2L_r8ISYu7ww6XSn2rbYbYtBQoq_SJtoKlAXzjtSWbV80ALWuAMX7gcTdceAJY5dRSv0qEpr_2TGk7cXyURnN0Xzg6Is88PDX0EcZopXJVY3lMjf5RJoZnogWaCMx1MsPSXEYI7Ts_oX-4d_4yEJ/s1502/left_join2.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"1502\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiz1UdN6mn1NqtKodNpELfR6Jn4F9aLLlveptkzxioo2L_r8ISYu7ww6XSn2rbYbYtBQoq_SJtoKlAXzjtSWbV80ALWuAMX7gcTdceAJY5dRSv0qEpr_2TGk7cXyURnN0Xzg6Is88PDX0EcZopXJVY3lMjf5RJoZnogWaCMx1MsPSXEYI7Ts_oX-4d_4yEJ/s16000/left_join2.png\" /></a></div>\n<br /><div>full join.</div><div><br /></div>\n<div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiyoVvxzr8IoshQYh36Igmd1CshyphenhyphencRy2qO_13b-CepCvOKannzB5NLUTkMD_gbjAqVhKjR8vIZ0D2sBI9r9NebVtKHXSe4kKO0-T5n_zzvzh7H3cA159pQv9ekt_qWKvK_OnHQjy9mMw2BXBhTc3XRvz-gbaRl3M5XnfptbxtO74GJK6HIUhO5QJ7ZXLU_0/s1125/full_join.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"944\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiyoVvxzr8IoshQYh36Igmd1CshyphenhyphencRy2qO_13b-CepCvOKannzB5NLUTkMD_gbjAqVhKjR8vIZ0D2sBI9r9NebVtKHXSe4kKO0-T5n_zzvzh7H3cA159pQv9ekt_qWKvK_OnHQjy9mMw2BXBhTc3XRvz-gbaRl3M5XnfptbxtO74GJK6HIUhO5QJ7ZXLU_0/s16000/full_join.png\" /></a></div><br /></div><div>교집합 제외한 full join.</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgPSJ6DgrvnRYmhT5qwkLjXTFV8ig78PCr9gPHmpDfYxcycB4sM6Hcu6A4cuuTd3a6F3HDwU9kNgjiqBJlQs1UggleUsH2gWer86fn7sjY_N6CxQofWcubDBLlWHvZ2jMalTLIEFMJ1PWoJ59lrG9BYGrn75eOQqhyWkzaOsdyIQD6dcJkQu4_v4suR-kfC/s1125/full_join2.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"990\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgPSJ6DgrvnRYmhT5qwkLjXTFV8ig78PCr9gPHmpDfYxcycB4sM6Hcu6A4cuuTd3a6F3HDwU9kNgjiqBJlQs1UggleUsH2gWer86fn7sjY_N6CxQofWcubDBLlWHvZ2jMalTLIEFMJ1PWoJ59lrG9BYGrn75eOQqhyWkzaOsdyIQD6dcJkQu4_v4suR-kfC/s16000/full_join2.png\" /></a></div><br /><div><b>관련 글</b></div><div><div><ul><li><a href=\"https://kangmyounghun.blogspot.com/2024/10/splunk-join-4th.html\">Splunk의 Join - 4th</a></li><li><a href=\"https://kangmyounghun.blogspot.com/2021/03/splunk-join.html\" target=\"\">Splunk의 Join</a></li><li><a href=\"https://kangmyounghun.blogspot.com/2021/07/splunk-lookup.html\" target=\"\">Splunk의 lookup</a></li><li><a href=\"https://kangmyounghun.blogspot.com/2022/10/join.html\" target=\"\">엘라스틱의 Join</a></li></ul></div></div>",
        "contentSnippet": "inner join.\n\n\n\n\nleft join.\n\n\n\n교집합 제외한 left join.\n\n\nfull join.\n\n\n\n\n\n교집합 제외한 full join.\n\n\n\n\n관련 글\n\n\nSplunk의 Join - 4th\nSplunk의 Join\nSplunk의 lookup\n엘라스틱의 Join",
        "id": "tag:blogger.com,1999:blog-2597780270996323853.post-9209557534125241532",
        "isoDate": "2025-04-13T02:57:00.000Z"
      }
    ]
  },
  {
    "name": "김민장",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김성중",
    "category": "개인",
    "posts": []
  },
  {
    "name": "구교준",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김덕기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "고명환",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강병수",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김봉현",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강형석",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김수로",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강미경",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김성현",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강진우",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권민재",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권태관",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김도곤",
    "category": "개인",
    "posts": []
  },
  {
    "name": "칡토스의 게임 개발",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김선철",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김놀부",
    "category": "개인",
    "posts": []
  },
  {
    "name": "Lael's World",
    "category": "개인",
    "posts": []
  },
  {
    "name": "프리웨어 이야기",
    "category": "개인",
    "posts": [
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "검색엔진 상위 노출을 위한 무료 프로그램, 키워드 파이터로 SEO 최적화하는 법",
        "link": "http://muzbox.tistory.com/483571",
        "pubDate": "Thu, 17 Apr 2025 19:33:06 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483571#entry483571comment",
        "content": "<p data-ke-size=\"size16\">블로그 방문자수 고민 끝! 키워드 파이터 V2로 SEO 최적화하고 상위노출 비결을 찾아보세요. 무료인데 실시간 트렌드부터 제목 생성까지 한번에! 클릭 한 번으로 블로그 트래픽이 두 배로 늘어날 수 있어요.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"><span data-url=\"https://blog.kakaocdn.net/dn/4tZKN/btsNo9W0MgL/4VRDExwXGs7p7CKu6dKjU1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/4tZKN/btsNo9W0MgL/4VRDExwXGs7p7CKu6dKjU1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/4tZKN/btsNo9W0MgL/4VRDExwXGs7p7CKu6dKjU1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4tZKN%2FbtsNo9W0MgL%2F4VRDExwXGs7p7CKu6dKjU1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"검색엔진 상위 노출을 위한 무료 프로그램, 키워드 파이터로 SEO 최적화하는 법\" loading=\"lazy\" width=\"1280\" height=\"853\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">요즘 블로그 운영하면서 방문자수 고민 안 해본 사람 있을까요? 솔직히 저도 블로그 시작하고 한동안은 그냥 '좋은 글 쓰면 사람들이 알아서 찾아오겠지' 하는 안일한 생각으로 운영했어요. 근데 현실은? 아무리 좋은 글 써도 구글이나 네이버가 내 글을 상위에 노출시켜주지 않으면 그냥 인터넷 바다에 던져진 돌맹이 신세더라고요.  </p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">그래서 요즘은 SEO(검색엔진 최적화)와 키워드 선정에 진심인데요. 오늘은 블로그 운영자, 콘텐츠 크리에이터분들에게 정말 유용한 무료 프로그램을 소개해드리려고 해요. 바로 '<span style=\"color: #ee2323;\"><b>키워드 파이터 V2</b></span>'인데, 이 프로그램 하나면 어떤 키워드로 글을 써야 할지, 어떻게 제목을 지어야 할지 고민이 싹 사라질 거예요!</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>  키워드 파이터 V2가 뭐길래?</b></span></h2>\n<p data-ke-size=\"size16\">키워드 파이터 V2는 블로그, 유튜브, 쇼핑몰 운영자들을 위한 올인원 키워드 발굴 &amp; 분석 툴이에요. 제가 일주일 전부터 써봤는데, 진짜 이런 프로그램이 무료라니...싶을 정도로 기능이 알차요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">가장 마음에 드는 점은 키워드 분석부터 블로그 제목 생성까지 원스톱으로 가능하다는 건데요. 특히 요즘처럼 경쟁이 치열한 상황에서 '어떤 키워드로 글을 써야 노출이 잘 될까?'라는 고민을 해결해주는 정말 고마운 프로그램이에요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>⚙️ 주요 기능과 사용법 살펴보기</b></span></h2>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"kakaotv\" data-video-url=\"https://tv.kakao.com/v/454478220\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/qS5Rf/hyYIkqMoa7/ivIxC54hoYKva66b76P350/img.jpg?width=1330&amp;height=1080&amp;face=0_0_1330_1080,https://scrap.kakaocdn.net/dn/kpVF8/hyYFBzWtd5/b0QKFZtmcQlj34ifOypjv0/img.jpg?width=1330&amp;height=1080&amp;face=0_0_1330_1080\" data-video-width=\"860\" data-video-height=\"698\" data-video-origin-width=\"860\" data-video-origin-height=\"698\" data-ke-mobilestyle=\"widthContent\" data-video-play-service=\"daum_tistory\" data-original-url=\"\" data-video-title=\"\"><iframe src=\"https://play-tv.kakao.com/embed/player/cliplink/454478220?service=daum_tistory\" width=\"860\" height=\"698\" frameborder=\"0\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"color: #ee2323;\">1. 실시간 트렌드 키워드 분석</span></h3>\n<p data-ke-size=\"size16\">트렌드 탭에서는 구글 트렌드와 시그널(옛 네이버 실검과 비슷한) 실시간 인기 검색어를 한눈에 볼 수 있어요. '실시간 검색어 일괄 조회' 버튼만 누르면 현재 사람들이 많이 검색하는 키워드가 쫙 나오죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이렇게 뜨는 키워드 중에서 내 블로그 주제와 연관된 것이 있다면? 바로 그날의 트렌드에 맞는 글을 쓸 수 있는 절호의 기회예요! 제가 지난주 '메타버스'라는 키워드가 실시간 검색어에 올라왔을 때 바로 관련 글을 썼더니 평소보다 3배 이상 방문자가 늘었어요. 이게 바로 트렌드 파악의 힘이죠!</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">2. 자동완성 키워드 수집</span></h3>\n<p data-ke-size=\"size16\">그 다음으로 유용한 건 자동완성 키워드 기능이에요. 구글, 네이버, 빙의 자동완성 키워드를 한 번에 수집해주는데, 이게 왜 중요하냐면, 자동완성 키워드는 실제로 사람들이 많이 검색하는 키워드를 보여주기 때문이에요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어 '다이어트'를 검색하면 '다이어트 식단', '다이어트 운동', '다이어트 방법' 같은 자동완성 키워드가 뜨는데, 이런 키워드들은 실제 사용자들이 관심있어 하는 정보를 보여주는 거예요. 그래서 이걸 활용하면 독자들이 정말 알고 싶어하는 내용으로 글을 쓸 수 있죠.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">3. 키워드 분석 및 경쟁도 체크</span></h3>\n<p data-ke-size=\"size16\">이 기능이 진짜 핵심인데요, '키워드 분석' 탭에서는 검색한 키워드의 월간 검색량(PC/모바일), 총 조회수, 문서 수, 그리고 경쟁 비율까지 분석해줘요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어 '제주도 여행'이라는 키워드를 검색했다고 쳐볼게요. 그러면 PC 검색량 5만, 모바일 검색량 10만, 문서 수 50만 개 정도가 나올 수 있어요. 이 정보를 보고 '아, 이 키워드는 검색량은 많지만 이미 경쟁이 너무 심하구나'라고 판단할 수 있죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">근데 더 놀라운 건 '관련 키워드' 목록도 함께 보여준다는 거예요. '제주도 여행'에서 파생된 '제주도 여행 코스', '제주도 여행 맛집', '제주도 여행 렌트카' 같은 연관 키워드를 확인할 수 있어요. 이 중에서 검색량은 적당히 있는데 경쟁은 덜한 키워드를 찾아내는 게 SEO의 핵심 전략이죠!</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">4. SEO 최적화 블로그 제목 자동 생성</span></h3>\n<p data-ke-size=\"size16\">이 기능은 정말 신세계였어요. 키워드 분석 결과에서 '키워드 조합으로 SEO 최적화 블로그 제목 만들기' 버튼을 누르면 자동으로 GPTS 사이트로 연결되는데요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">거기서 분석한 키워드들을 붙여넣기만 하면 GPTS가 알아서 SEO에 최적화된 블로그 제목을 여러 개 제안해줘요. 제가 얼마 전에 '홈카페 원두추천'이라는 키워드로 해봤는데, '집에서 즐기는 프리미엄 커피, 바리스타도 인정한 원두 BEST 5', '홈카페 격이 다른 맛, 가성비 원두 추천 및 활용법 총정리' 같은 제목을 제안해줬어요. 이런 제목들은 단순히 키워드만 넣은 것보다 클릭율이 훨씬 높더라고요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>  실전에서 키워드 파이터 활용하기</b></span></h2>\n<p data-ke-size=\"size16\">제가 실제로 키워드 파이터를 활용해서 블로그 글을 작성한 방법을 공유할게요.</p>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>트렌드 키워드 발굴 &rarr; 관련성 확인</b> 저는 먼저 '실시간 트렌드' 탭에서 핫한 키워드를 확인해요. 얼마 전에 '미니멀라이프'가 트렌드에 올라왔을 때, 제 블로그가 라이프스타일 관련이다 보니 이걸 놓칠 수 없었죠.</li>\n<li><b>키워드 분석으로 경쟁도 체크</b> 그 다음 '미니멀라이프'를 검색창에 넣고 키워드 분석을 해봤어요. 검색량은 꽤 있는데 경쟁이 너무 심해서, 관련 키워드 중에서 '미니멀라이프 시작하기'라는 키워드를 선택했죠. 이건 검색량도 적당하고 경쟁도 상대적으로 적었거든요.</li>\n<li><b>자동완성 키워드로 독자 의도 파악</b> 자동완성 키워드를 보니 '미니멀라이프 시작하기 팁', '미니멀라이프 시작하기 옷정리' 같은 키워드가 있더라고요. 이걸 보고 '아, 사람들은 구체적인 실천 방법을 알고 싶어하는구나'라고 파악했어요.</li>\n<li><b>최적화 제목 생성 및 콘텐츠 작성</b> 마지막으로 GPTS 제목 생성 기능을 활용해 '버리기 전에 읽어보세요, 후회 없는 미니멀라이프 시작하기 8단계 가이드'라는 제목으로 글을 작성했어요.</li>\n</ol>\n<p data-ke-size=\"size16\">결과적으로 이 글은 구글에서 '미니멀라이프 시작하기' 키워드로 검색했을 때 2페이지에 노출되었고, 평소보다 2배 이상의 트래픽을 가져왔어요. 이게 다 키워드 파이터 덕분이죠!  </p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>  실전 활용을 위한 꿀팁</b></span><b></b></h2>\n<p data-ke-size=\"size16\">\"키워드 파이터 V2\"에는 위의 핵심기능 외에도 키워드와 블로그 주제선정에 유용한 무료 GPTS 를 함께 공개하니 참고하세요.</p>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>롱테일 키워드를 노려라</b> 메인 키워드보다는 '명사+명사+동사' 형태의 구체적인 롱테일 키워드가 경쟁이 적고 전환율이 높아요. 키워드 파이터의 관련 키워드와 자동완성 키워드에서 이런 롱테일을 찾아보세요.</li>\n<li><b>트렌드와 에버그린의 균형</b> 트렌드 키워드는 단기 트래픽에 좋지만, 에버그린 콘텐츠(시간이 지나도 가치가 있는)를 위한 키워드도 균형있게 공략하세요. 프로그램의 'GPTS 탭'에 있는 '에버그린 콘텐츠 GPT'가 이런 키워드 발굴에 도움이 돼요.</li>\n<li><b>제목에 감정을 자극하는 단어 추가</b> 키워드 파이터로 찾은 키워드에 '놀라운', '충격적인', '꼭 알아야 할' 같은 감정적 단어를 더하면 클릭율이 높아져요. 물론 너무 낚시성은 피해야겠죠!</li>\n<li><b>경쟁자 분석에 활용</b> 상위 노출된 경쟁자의 제목과 키워드를 분석해 역공략 전략을 세우는 데도 키워드 파이터가 유용해요. 그들이 놓친 틈새 키워드를 찾아내세요.</li>\n</ol>\n<p style=\"color: #333333; text-align: start;\" data-ke-size=\"size16\">요즘 블로그 운영이 점점 더 경쟁이 치열해지고 있어요. 그냥 좋은 글만 쓴다고 사람들이 찾아오는 시대는 지났죠. 하지만 이런 도구의 도움을 받으면 우리 같은 개인 블로거도 큰 포털 사이트나 기업 블로그와 경쟁할 수 있어요!</p>\n<p style=\"color: #333333; text-align: start;\" data-ke-size=\"size16\">키워드 파이터 V2는 제가 써본 무료 키워드 분석 도구 중에서 가장 실용적이고 직관적이었던 것 같아요. 특히 GPTS와의 연동 기능은 정말 혁신적이라고 생각해요. 이 글을 읽고 계신 블로거분들, 유튜버분들, 온라인 숍 운영자분들이라면 꼭 한번 사용해보시길 추천드려요!</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"1055\" data-origin-height=\"664\"><span data-url=\"https://blog.kakaocdn.net/dn/6yFnv/btsNo3JtAGz/zTJWS0l8KGwwYglKEJL3Wk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/6yFnv/btsNo3JtAGz/zTJWS0l8KGwwYglKEJL3Wk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/6yFnv/btsNo3JtAGz/zTJWS0l8KGwwYglKEJL3Wk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6yFnv%2FbtsNo3JtAGz%2FzTJWS0l8KGwwYglKEJL3Wk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"키워드 파이터 V2 활용팁\" loading=\"lazy\" width=\"1055\" height=\"664\" data-origin-width=\"1055\" data-origin-height=\"664\"/></span></figure>\n</p>\n<p style=\"color: #333333; text-align: start;\" data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\" data-ke-size=\"size16\">여러분의 블로그 운영 경험이나 키워드 파이터 사용 후기가 있다면 댓글로 남겨주세요. 서로의 경험을 나누다 보면 모두 함께 성장할 수 있을 거예요! 다음 포스팅에서는 제가 키워드 파이터로 발굴한 키워드로 실제 한 달간 블로그를 운영한 결과를 공유해드릴게요. 기대해주세요!  </p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style1\" />\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\">  자주 묻는 질문 (Q&amp;A)</span></h2>\n<p data-ke-size=\"size16\"><b>Q: 키워드 파이터 V2는 어디서 다운로드할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 본 기사 하단에 다운로드 링크가 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 다른 키워드 분석 도구와 비교했을 때 장점은 무엇인가요?</b></p>\n<p data-ke-size=\"size16\">A: 무료임에도 실시간 트렌드, 키워드 분석, 자동완성, 블로그 제목 생성까지 올인원으로 제공하는 점이 가장 큰 장점입니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 유튜브나 쇼핑몰에도 활용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 네, 키워드 분석 원리는 동일하게 적용됩니다. 특히 'GPTS 탭'의 다양한 도구를 활용하면 각 플랫폼에 맞는 키워드 전략을 수립할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 초보자도 쉽게 사용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 네, 직관적인 UI와 '사용법' 탭의 상세한 가이드 덕분에 SEO 초보자도 쉽게 활용할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 실제로 효과가 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 적절한 키워드 선정은 SEO의 기본이므로, 이 도구를 잘 활용하면 검색 노출과 트래픽 향상에 확실한 효과가 있습니다. 다만 양질의 콘텐츠가 뒷받침되어야 합니다.</p>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"키워드 파이터 V2는 어디서 다운로드할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 구글에서 '키워드 파이터 V2 다운로드'로 검색하면 공식 배포 페이지를 찾을 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"다른 키워드 분석 도구와 비교했을 때 장점은 무엇인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"무료임에도 실시간 트렌드, 키워드 분석, 자동완성, 블로그 제목 생성까지 올인원으로 제공하는 점이 가장 큰 장점입니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"유튜브나 쇼핑몰에도 활용할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 키워드 분석 원리는 동일하게 적용됩니다. 특히 'GPTS 탭'의 다양한 도구를 활용하면 각 플랫폼에 맞는 키워드 전략을 수립할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"초보자도 쉽게 사용할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 직관적인 UI와 '사용법' 탭의 상세한 가이드 덕분에 SEO 초보자도 쉽게 활용할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"실제로 효과가 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"적절한 키워드 선정은 SEO의 기본이므로, 이 도구를 잘 활용하면 검색 노출과 트래픽 향상에 확실한 효과가 있습니다. 다만 양질의 콘텐츠가 뒷받침되어야 합니다.\"\n      }\n    }\n  ]\n}\n</script>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"color: #006dd7;\">  프로그램 다운로드</span></h2>\n<div class=\"revenue_unit_wrap\">\n  <div class=\"revenue_unit_item adsense responsive\">\n    <div class=\"revenue_unit_info\">반응형</div>\n    <script src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\" async=\"async\"></script>\n    <ins class=\"adsbygoogle\" style=\"display: block;\" data-ad-host=\"ca-host-pub-9691043933427338\" data-ad-client=\"ca-pub-8195497734535830\" data-ad-format=\"auto\"></ins>\n    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>\n  </div>\n</div>\n<h4 data-ke-size=\"size20\"><b>1. 단일 파일 버전</b></h4>\n<p><figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/pIAMA/btsNslV7CA0/Mdf8RsKt6X4N0N1euzWei1/keyword_fighter_v2.z01?attach=1&amp;knm=tfile.z01\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.z01</span></div>\n<div class=\"size\">9.77MB</div>\n</div>\n  </a></figure>\n<figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/28gZT/btsNr1JV7ye/F4pum7jbtlszAZtj6mmK4k/keyword_fighter_v2.z02?attach=1&amp;knm=tfile.z02\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.z02</span></div>\n<div class=\"size\">9.77MB</div>\n</div>\n  </a></figure>\n<figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/qmJlY/btsNsQux8WK/V4ANk5gdlukPuuD9p30cr1/keyword_fighter_v2.z03?attach=1&amp;knm=tfile.z03\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.z03</span></div>\n<div class=\"size\">9.77MB</div>\n</div>\n  </a></figure>\n<figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/eceaPH/btsNsjjF29V/DSYKcXmXKcn121fNpvGL61/keyword_fighter_v2.zip?attach=1&amp;knm=tfile.zip\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.zip</span></div>\n<div class=\"size\">3.25MB</div>\n</div>\n  </a></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h4 data-ke-size=\"size20\"><b>2. standalone 버전 (리소스 파일들을 분리해서 폴더로) - 단일 파일 버전 오류시</b></h4>\n<p><figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/erEvCd/btsNsjYlnyL/yvLJlOxfqIMleUuV6DzvEk/keyword_fighter_v2.z01?attach=1&amp;knm=tfile.z01\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.z01</span></div>\n<div class=\"size\">19.53MB</div>\n</div>\n  </a></figure>\n<figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/tO39t/btsNpT7dsMf/FU77PpsLmfPeSk96LiMwi1/keyword_fighter_v2.z02?attach=1&amp;knm=tfile.z02\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.z02</span></div>\n<div class=\"size\">19.53MB</div>\n</div>\n  </a></figure>\n<figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/8yXo2/btsNpxcgpWS/3oTJ8XfUk9vwN2RkgXroB1/keyword_fighter_v2.zip?attach=1&amp;knm=tfile.zip\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.zip</span></div>\n<div class=\"size\">7.35MB</div>\n</div>\n  </a></figure>\n</p>",
        "contentSnippet": "블로그 방문자수 고민 끝! 키워드 파이터 V2로 SEO 최적화하고 상위노출 비결을 찾아보세요. 무료인데 실시간 트렌드부터 제목 생성까지 한번에! 클릭 한 번으로 블로그 트래픽이 두 배로 늘어날 수 있어요.\n\n\n \n요즘 블로그 운영하면서 방문자수 고민 안 해본 사람 있을까요? 솔직히 저도 블로그 시작하고 한동안은 그냥 '좋은 글 쓰면 사람들이 알아서 찾아오겠지' 하는 안일한 생각으로 운영했어요. 근데 현실은? 아무리 좋은 글 써도 구글이나 네이버가 내 글을 상위에 노출시켜주지 않으면 그냥 인터넷 바다에 던져진 돌맹이 신세더라고요.  \n \n그래서 요즘은 SEO(검색엔진 최적화)와 키워드 선정에 진심인데요. 오늘은 블로그 운영자, 콘텐츠 크리에이터분들에게 정말 유용한 무료 프로그램을 소개해드리려고 해요. 바로 '키워드 파이터 V2'인데, 이 프로그램 하나면 어떤 키워드로 글을 써야 할지, 어떻게 제목을 지어야 할지 고민이 싹 사라질 거예요!\n \n  키워드 파이터 V2가 뭐길래?\n키워드 파이터 V2는 블로그, 유튜브, 쇼핑몰 운영자들을 위한 올인원 키워드 발굴 & 분석 툴이에요. 제가 일주일 전부터 써봤는데, 진짜 이런 프로그램이 무료라니...싶을 정도로 기능이 알차요.\n \n가장 마음에 드는 점은 키워드 분석부터 블로그 제목 생성까지 원스톱으로 가능하다는 건데요. 특히 요즘처럼 경쟁이 치열한 상황에서 '어떤 키워드로 글을 써야 노출이 잘 될까?'라는 고민을 해결해주는 정말 고마운 프로그램이에요.\n \n⚙️ 주요 기능과 사용법 살펴보기\n\n\n\n \n1. 실시간 트렌드 키워드 분석\n트렌드 탭에서는 구글 트렌드와 시그널(옛 네이버 실검과 비슷한) 실시간 인기 검색어를 한눈에 볼 수 있어요. '실시간 검색어 일괄 조회' 버튼만 누르면 현재 사람들이 많이 검색하는 키워드가 쫙 나오죠.\n \n이렇게 뜨는 키워드 중에서 내 블로그 주제와 연관된 것이 있다면? 바로 그날의 트렌드에 맞는 글을 쓸 수 있는 절호의 기회예요! 제가 지난주 '메타버스'라는 키워드가 실시간 검색어에 올라왔을 때 바로 관련 글을 썼더니 평소보다 3배 이상 방문자가 늘었어요. 이게 바로 트렌드 파악의 힘이죠!\n \n2. 자동완성 키워드 수집\n그 다음으로 유용한 건 자동완성 키워드 기능이에요. 구글, 네이버, 빙의 자동완성 키워드를 한 번에 수집해주는데, 이게 왜 중요하냐면, 자동완성 키워드는 실제로 사람들이 많이 검색하는 키워드를 보여주기 때문이에요.\n \n예를 들어 '다이어트'를 검색하면 '다이어트 식단', '다이어트 운동', '다이어트 방법' 같은 자동완성 키워드가 뜨는데, 이런 키워드들은 실제 사용자들이 관심있어 하는 정보를 보여주는 거예요. 그래서 이걸 활용하면 독자들이 정말 알고 싶어하는 내용으로 글을 쓸 수 있죠.\n3. 키워드 분석 및 경쟁도 체크\n이 기능이 진짜 핵심인데요, '키워드 분석' 탭에서는 검색한 키워드의 월간 검색량(PC/모바일), 총 조회수, 문서 수, 그리고 경쟁 비율까지 분석해줘요.\n \n예를 들어 '제주도 여행'이라는 키워드를 검색했다고 쳐볼게요. 그러면 PC 검색량 5만, 모바일 검색량 10만, 문서 수 50만 개 정도가 나올 수 있어요. 이 정보를 보고 '아, 이 키워드는 검색량은 많지만 이미 경쟁이 너무 심하구나'라고 판단할 수 있죠.\n \n근데 더 놀라운 건 '관련 키워드' 목록도 함께 보여준다는 거예요. '제주도 여행'에서 파생된 '제주도 여행 코스', '제주도 여행 맛집', '제주도 여행 렌트카' 같은 연관 키워드를 확인할 수 있어요. 이 중에서 검색량은 적당히 있는데 경쟁은 덜한 키워드를 찾아내는 게 SEO의 핵심 전략이죠!\n4. SEO 최적화 블로그 제목 자동 생성\n이 기능은 정말 신세계였어요. 키워드 분석 결과에서 '키워드 조합으로 SEO 최적화 블로그 제목 만들기' 버튼을 누르면 자동으로 GPTS 사이트로 연결되는데요.\n \n거기서 분석한 키워드들을 붙여넣기만 하면 GPTS가 알아서 SEO에 최적화된 블로그 제목을 여러 개 제안해줘요. 제가 얼마 전에 '홈카페 원두추천'이라는 키워드로 해봤는데, '집에서 즐기는 프리미엄 커피, 바리스타도 인정한 원두 BEST 5', '홈카페 격이 다른 맛, 가성비 원두 추천 및 활용법 총정리' 같은 제목을 제안해줬어요. 이런 제목들은 단순히 키워드만 넣은 것보다 클릭율이 훨씬 높더라고요.\n \n  실전에서 키워드 파이터 활용하기\n제가 실제로 키워드 파이터를 활용해서 블로그 글을 작성한 방법을 공유할게요.\n트렌드 키워드 발굴 → 관련성 확인 저는 먼저 '실시간 트렌드' 탭에서 핫한 키워드를 확인해요. 얼마 전에 '미니멀라이프'가 트렌드에 올라왔을 때, 제 블로그가 라이프스타일 관련이다 보니 이걸 놓칠 수 없었죠.\n키워드 분석으로 경쟁도 체크 그 다음 '미니멀라이프'를 검색창에 넣고 키워드 분석을 해봤어요. 검색량은 꽤 있는데 경쟁이 너무 심해서, 관련 키워드 중에서 '미니멀라이프 시작하기'라는 키워드를 선택했죠. 이건 검색량도 적당하고 경쟁도 상대적으로 적었거든요.\n자동완성 키워드로 독자 의도 파악 자동완성 키워드를 보니 '미니멀라이프 시작하기 팁', '미니멀라이프 시작하기 옷정리' 같은 키워드가 있더라고요. 이걸 보고 '아, 사람들은 구체적인 실천 방법을 알고 싶어하는구나'라고 파악했어요.\n최적화 제목 생성 및 콘텐츠 작성 마지막으로 GPTS 제목 생성 기능을 활용해 '버리기 전에 읽어보세요, 후회 없는 미니멀라이프 시작하기 8단계 가이드'라는 제목으로 글을 작성했어요.\n결과적으로 이 글은 구글에서 '미니멀라이프 시작하기' 키워드로 검색했을 때 2페이지에 노출되었고, 평소보다 2배 이상의 트래픽을 가져왔어요. 이게 다 키워드 파이터 덕분이죠!  \n \n  실전 활용을 위한 꿀팁\n\"키워드 파이터 V2\"에는 위의 핵심기능 외에도 키워드와 블로그 주제선정에 유용한 무료 GPTS 를 함께 공개하니 참고하세요.\n롱테일 키워드를 노려라 메인 키워드보다는 '명사+명사+동사' 형태의 구체적인 롱테일 키워드가 경쟁이 적고 전환율이 높아요. 키워드 파이터의 관련 키워드와 자동완성 키워드에서 이런 롱테일을 찾아보세요.\n트렌드와 에버그린의 균형 트렌드 키워드는 단기 트래픽에 좋지만, 에버그린 콘텐츠(시간이 지나도 가치가 있는)를 위한 키워드도 균형있게 공략하세요. 프로그램의 'GPTS 탭'에 있는 '에버그린 콘텐츠 GPT'가 이런 키워드 발굴에 도움이 돼요.\n제목에 감정을 자극하는 단어 추가 키워드 파이터로 찾은 키워드에 '놀라운', '충격적인', '꼭 알아야 할' 같은 감정적 단어를 더하면 클릭율이 높아져요. 물론 너무 낚시성은 피해야겠죠!\n경쟁자 분석에 활용 상위 노출된 경쟁자의 제목과 키워드를 분석해 역공략 전략을 세우는 데도 키워드 파이터가 유용해요. 그들이 놓친 틈새 키워드를 찾아내세요.\n요즘 블로그 운영이 점점 더 경쟁이 치열해지고 있어요. 그냥 좋은 글만 쓴다고 사람들이 찾아오는 시대는 지났죠. 하지만 이런 도구의 도움을 받으면 우리 같은 개인 블로거도 큰 포털 사이트나 기업 블로그와 경쟁할 수 있어요!\n키워드 파이터 V2는 제가 써본 무료 키워드 분석 도구 중에서 가장 실용적이고 직관적이었던 것 같아요. 특히 GPTS와의 연동 기능은 정말 혁신적이라고 생각해요. 이 글을 읽고 계신 블로거분들, 유튜버분들, 온라인 숍 운영자분들이라면 꼭 한번 사용해보시길 추천드려요!\n\n\n \n여러분의 블로그 운영 경험이나 키워드 파이터 사용 후기가 있다면 댓글로 남겨주세요. 서로의 경험을 나누다 보면 모두 함께 성장할 수 있을 거예요! 다음 포스팅에서는 제가 키워드 파이터로 발굴한 키워드로 실제 한 달간 블로그를 운영한 결과를 공유해드릴게요. 기대해주세요!  \n \n  자주 묻는 질문 (Q&A)\nQ: 키워드 파이터 V2는 어디서 다운로드할 수 있나요?\nA: 본 기사 하단에 다운로드 링크가 있습니다.\nQ: 다른 키워드 분석 도구와 비교했을 때 장점은 무엇인가요?\nA: 무료임에도 실시간 트렌드, 키워드 분석, 자동완성, 블로그 제목 생성까지 올인원으로 제공하는 점이 가장 큰 장점입니다.\nQ: 유튜브나 쇼핑몰에도 활용할 수 있나요?\nA: 네, 키워드 분석 원리는 동일하게 적용됩니다. 특히 'GPTS 탭'의 다양한 도구를 활용하면 각 플랫폼에 맞는 키워드 전략을 수립할 수 있습니다.\nQ: 초보자도 쉽게 사용할 수 있나요?\nA: 네, 직관적인 UI와 '사용법' 탭의 상세한 가이드 덕분에 SEO 초보자도 쉽게 활용할 수 있습니다.\nQ: 실제로 효과가 있나요?\nA: 적절한 키워드 선정은 SEO의 기본이므로, 이 도구를 잘 활용하면 검색 노출과 트래픽 향상에 확실한 효과가 있습니다. 다만 양질의 콘텐츠가 뒷받침되어야 합니다.\n \n  프로그램 다운로드\n반응형\n\n    \n    (adsbygoogle = window.adsbygoogle || []).push({});\n  \n1. 단일 파일 버전\n\n    \n\n    \nkeyword_fighter_v2.z01\n9.77MB\n\n\n    \n\n    \nkeyword_fighter_v2.z02\n9.77MB\n\n\n    \n\n    \nkeyword_fighter_v2.z03\n9.77MB\n\n\n    \n\n    \nkeyword_fighter_v2.zip\n3.25MB\n\n\n \n \n2. standalone 버전 (리소스 파일들을 분리해서 폴더로) - 단일 파일 버전 오류시\n\n    \n\n    \nkeyword_fighter_v2.z01\n19.53MB\n\n\n    \n\n    \nkeyword_fighter_v2.z02\n19.53MB\n\n\n    \n\n    \nkeyword_fighter_v2.zip\n7.35MB",
        "guid": "http://muzbox.tistory.com/483571",
        "categories": [
          "NEWS/My Self",
          "gpts",
          "SEO 최적화",
          "검색엔진 최적화",
          "구글 트렌드",
          "롱테일 키워드",
          "무료 키워드 도구",
          "블로그 검색 노출",
          "블로그 제목 생성",
          "키워드 분석",
          "키워드 파이터"
        ],
        "isoDate": "2025-04-17T10:33:06.000Z"
      },
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "더 똑똑해진 챗GPT o3와 o4-mini 공개 , 기존 모델과 차이는?",
        "link": "http://muzbox.tistory.com/483570",
        "pubDate": "Thu, 17 Apr 2025 08:39:33 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483570#entry483570comment",
        "content": "<p data-ke-size=\"size16\">OpenAI의 새 모델 o3와 o4-mini가 뭐길래 이렇게 화제인걸까요? 더 오래 생각하고, 도구를 사용하며, 이미지까지 이해하는 이 모델들이 AI의 미래를 어떻게 바꿀지 함께 알아보세요!  </p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"><span data-url=\"https://blog.kakaocdn.net/dn/4B70K/btsNoPv2TY6/bQzUb4AxbrWIWdoJkwOrOk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/4B70K/btsNoPv2TY6/bQzUb4AxbrWIWdoJkwOrOk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/4B70K/btsNoPv2TY6/bQzUb4AxbrWIWdoJkwOrOk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4B70K%2FbtsNoPv2TY6%2FbQzUb4AxbrWIWdoJkwOrOk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"더 똑똑해진 챗GPT o3와 o4-mini 공개\" loading=\"lazy\" width=\"1280\" height=\"853\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">요즘 인공지능 업계는 진짜 숨 돌릴 틈이 없는 것 같아요. 오늘은 OpenAI가 또 새로운 모델을 내놨네요. 솔직히 따라가기 벅찬 느낌이랄까요? 특히 이번에 공개된 OpenAI의 o3와 o4-mini는 정말 많은 관심을 받고 있더라고요. 근데 이게 진짜 대단한 혁신인지, 아니면 그냥 마케팅 전략인지 궁금해서 한번 자세히 들여다봤어요. 여러분도 이런 고민 한번쯤 해보셨죠?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>o 시리즈가 뭘까? 그리고 이게 왜 중요할까?  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI의 새로운 o3와 o4-mini는 생각하는 시간을 더 길게 가지고 응답할 수 있도록 학습된 O 시리즈의 최신 모델입니다. 이 모델들은 지금까지 OpenAI가 출시한 모델 중 가장 똑똑한 모델로, ChatGPT의 기능에 큰 변화를 가져올 것으로 예상됩니다.</p>\n<p data-ke-size=\"size16\">특히 주목할 점은 이 모델들이 챗GPT 내의 모든 도구를 에이전트처럼 사용하고 결합할 수 있다는 것입니다. 여기에는 웹 검색, 업로드된 파일 및 기타 데이터를 Python으로 분석하는 기능, 시각적 입력에 대한 심층 추론, 심지어 이미지 생성까지 포함됩니다. 이건 진짜 획기적인 변화 아닐까요?  </p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이를 통해 다면적인 질문을 더 효과적으로 해결할 수 있게 되었고, 이는 사용자를 대신해 독립적으로 작업을 실행할 수 있는 더 에이전트형 ChatGPT를 향한 한 걸음이라고 볼 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>o3와 o4-mini의 차이점은 무엇일까?  </b></span></h2>\n<table style=\"border-collapse: collapse; width: 100%; margin: 15px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #4a86e8; color: white;\">\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px; width: 13.4884%;\">모델</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px; width: 42.3256%;\">주요 특징</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px; width: 44.0698%;\">최적 사용 케이스</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 13.4884%;\"><b>OpenAI o3</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 42.3256%;\">가장 강력한 추론 모델, 코딩/수학/과학/시각적 인식에서 최고 성능, o1보다 20% 더 적은 오류율</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 44.0698%;\">복잡한 다면적 분석, 이미지/차트/그래픽 분석, 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상</td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 13.4884%;\"><b>OpenAI o4-mini</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 42.3256%;\">빠르고 비용 효율적인 추론에 최적화, 크기와 비용 대비 뛰어난 성능, AIME 2024/2025 벤치마크 1위</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 44.0698%;\">수학, 코딩, 시각적 작업, 데이터 과학, 고용량/고처리량 필요 작업</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">OpenAI o3는 회사의 가장 강력한 추론 모델로, 코딩, 수학, 과학, 시각적 인식 등 여러 분야에서 최첨단 성능을 발휘합니다. Codeforces, SWE-bench (별도의 모델별 스캐폴드 없이), MMMU 등의 벤치마크에서 새로운 최고 성능을 기록했죠. 이 모델은 복잡한 다면적 분석이 필요하고 즉각적인 답이 명확하지 않은 복잡한 질의에 이상적입니다. 특히 이미지, 차트, 그래픽 분석과 같은 시각적 작업에서 강점을 보입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">외부 전문가들의 평가에 따르면, o3는 어려운 실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘합니다. 초기 테스터들은 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력을 강조했습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">반면에, OpenAI o4-mini는 빠르고 비용 효율적인 추론에 최적화된 더 작은 모델입니다. 크기와 비용 대비 놀라운 성능을 보이며, 특히 수학, 코딩, 시각적 작업에서 뛰어납니다. AIME 2024와 2025 벤치마크에서 가장 뛰어난 성능을 보이는 모델입니다. 전문가 평가에서도 데이터 과학과 같은 분야뿐만 아니라 비-STEM 작업에서도 이전 모델인 o3-mini보다 뛰어난 성능을 보였습니다.</p>\n<p data-ke-size=\"size16\">효율성 덕분에 o3보다 훨씬 더 높은 사용 제한을 지원하여, 추론이 필요한 질문에 대해 강력한 고용량, 고처리량 옵션이 됩니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>실제 성능은 어떨까?  </b></span></h2>\n<table style=\"border-collapse: collapse; width: 100%; margin: 15px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #4a86e8; color: white;\">\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">벤치마크/작업</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">o1</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">o3-mini</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">o3</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">o4-mini</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">AIME 2024 (경쟁 수학)</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">74.3%</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">87.3%</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">91.6%</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\"><b>93.4%</b></td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">Codeforces (경쟁 코딩)</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">1891</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">2073</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\"><b>2706</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">2719</td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">MMMU (대학 수준 시각적 문제 해결)</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">77.6%</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">-</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\"><b>82.9%</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">81.6%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">벤치마크 성능을 보면 정말 놀랍습니다. 외부 전문가 평가자들은 두 모델 모두 향상된 명령 준수와 이전 모델보다 더 유용하고 검증 가능한 응답을 보여준다고 평가했습니다. 이는 향상된 지능과 웹 소스의 통합 덕분입니다. 이전 추론 모델 반복과 비교할 때, 이 두 모델은 특히 기억과 과거 대화를 참조하여 응답을 더 개인화하고 관련성을 높이는 데 있어 더 자연스럽고 대화적이라고 합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">OpenAI o3는 ChatGPT 내 전체 도구 접근권과 함께 API를 통한 사용자 지정 도구에도 접근할 수 있습니다. 이 모델들은 문제 해결 방법을 추론하고, 도구를 언제, 어떻게 사용할지 선택하여 일반적으로 1분 이내에 올바른 출력 형식으로 상세하고 사려 깊은 답변을 빠르게 생성하도록 학습되었습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어, 사용자가 \"캘리포니아의 여름 에너지 사용량이 작년과 비교하여 어떻게 될까요?\"라고 물을 수 있습니다. 이때 모델은 공공 유틸리티 데이터에 대한 웹 검색을 하고, 예측을 구축하기 위한 Python 코드를 작성하고, 그래프나 이미지를 생성한 다음, 예측 뒤에 있는 주요 요소를 설명할 수 있습니다. 이 과정에서 여러 도구 호출을 연결합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">추론을 통해 모델은 접하는 정보에 따라 필요에 따라 반응하고 방향을 전환할 수 있습니다. 예를 들어, 검색 제공업체의 도움을 받아 웹을 여러 번 검색하고, 결과를 살펴보고, 더 많은 정보가 필요한 경우 새로운 검색을 시도할 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>예를 통해 본 성능 차이  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI는 이 모델들의 뛰어난 성능을 보여주는 몇 가지 예시를 제공했습니다. o3와 o1의 성능을 비교하면 그 차이가 확연히 드러납니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어, 복잡한 수학 문제에서 o3는 디크슨 다항식(Dickson polynomial)을 사용해 문제를 정확히 풀어내는 반면, o1은 시간이 더 걸리고 부정확한 해결책을 제시합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">또한 호텔 체인 확장에 관한 질문에서도 o3는 실제 데이터를 활용한 철저한 분석을 통해 아테네와 오사카를 목표 도시로 추천했습니다. 각 도시의 점유율, RevPAR 성장률, 승객 증가율 등 구체적인 지표와 2024년 통계자료를 바탕으로 상세한 비교 테이블까지 제공했죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">배터리 기술 발전에 관한 질문에서도 o3는 리튬 이온 배터리, 솔리드 스테이트 배터리, 나트륨 이온 배터리 등 최신 기술의 영향을 상세히 분석하며, 2011년부터 2024년까지의 전기차 주행거리, 충전 속도, 보급률 등의 변화를 그래프로 시각화해 보여주었습니다.</p>\n<p data-ke-size=\"size16\">MLB 피치 클럭 규칙이 투수 성능과 게임 시간에 미친 영향에 관한 질문에서도 o3는 구체적인 통계 데이터를 활용해 2021년부터 2024년까지의 변화를 상세히 분석했습니다. 규칙 도입 이후 게임 시간이 24분 단축됐고, 초기에는 투수들의 ERA가 상승했지만 적응 기간을 거쳐 다시 안정되었다는 흥미로운 분석을 제공했죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이런 예시들을 보면 o3와 o4-mini의 성능이 정말 인상적이라는 걸 알 수 있어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>핵심 기술적 특징  </b></span></h2>\n<table style=\"border-collapse: collapse; width: 100%; margin: 15px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #4a86e8; color: white;\">\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">기술적 혁신</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">특징</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">영향</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\"><b>강화학습 확장</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">\"더 많은 컴퓨팅 = 더 나은 성능\" 트렌드 확인</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">더 오래 생각할수록 성능이 지속적으로 향상</td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\"><b>에이전트형 도구 사용</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">도구를 언제, 어떻게 사용할지 추론하는 능력</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">시각적 추론, 다단계 워크플로우 처리 능력 향상</td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\"><b>이미지 통합 사고</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">이미지를 사고 과정에 직접 통합</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">시각적, 텍스트 추론을 혼합한 새로운 문제 해결 가능</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">OpenAI의 o3 개발 과정에서, 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 GPT 시리즈 사전 학습에서 관찰된 것과 동일한 추세를 보여주는 것으로 확인됐습니다. OpenAI는 현재 강화학습에서 이 확장 경로를 다시 따라가며, 학습 컴퓨팅과 추론 시간을 추가로 10배 증가시켰음에도 여전히 성능 향상이 명확하게 보이는 것을 확인했습니다. 이는 모델이 더 오래 생각할수록 성능이 계속 향상된다는 것을 검증합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">o3와 o4-mini는 강화학습을 통해 도구를 사용하도록 학습되었습니다. 이는 단순히 도구 사용법을 학습하는 것이 아니라, 언제 도구를 사용할지에 대해 추론하는 능력을 키웠다는 의미입니다. 원하는 결과에 따라 도구를 배치하는 능력은 특히 시각적 추론과 다단계 워크플로우를 포함하는 개방형 상황에서 더 유능하게 만듭니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이러한 개선은 학술 벤치마크와 실제 작업 모두에서 반영되어, 초기 테스터들의 보고에서도 확인됩니다.</p>\n<p data-ke-size=\"size16\">또한 이 모델들은 처음으로 이미지를 직접 사고 과정에 통합할 수 있습니다. 단순히 이미지를 보는 것이 아니라, 그것을 가지고 생각합니다. 이는 시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결을 가능하게 하며, 이는 다양한 다중모달 벤치마크에서의 최첨단 성능으로 반영됩니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>실생활에서의 응용 가능성  ️</b></span></h2>\n<p data-ke-size=\"size16\">이 새로운 모델들의 활용 가능성은 정말 광범위해요. 일상적인 작업부터 복잡한 비즈니스 문제, 교육, 연구까지 다양한 분야에서 활용될 수 있습니다. 예를 들어, 공공 유틸리티 데이터를 검색하고, 예측 모델을 구축하며, 결과를 시각화하는 복잡한 작업을 한 번에 처리할 수 있습니다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"edited_GPT O3, O4MINI.jpg\" data-origin-width=\"1000\" data-origin-height=\"668\"><span data-url=\"https://blog.kakaocdn.net/dn/86LNl/btsNn8iMy87/IKK7KcXRwKEGOZiMYkk4RK/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/86LNl/btsNn8iMy87/IKK7KcXRwKEGOZiMYkk4RK/img.png\"><img src=\"https://blog.kakaocdn.net/dn/86LNl/btsNn8iMy87/IKK7KcXRwKEGOZiMYkk4RK/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F86LNl%2FbtsNn8iMy87%2FIKK7KcXRwKEGOZiMYkk4RK%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"챗GPT o3, o4 mini\" loading=\"lazy\" width=\"1000\" height=\"668\" data-filename=\"edited_GPT O3, O4MINI.jpg\" data-origin-width=\"1000\" data-origin-height=\"668\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이러한 유연하고 전략적인 접근 방식을 통해 모델은 모델의 내장 지식을 넘어서는 최신 정보에 대한 접근, 확장된 추론, 합성, 여러 양식에 걸친 출력 생성이 필요한 작업을 처리할 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">특히 비즈니스 분야에서는 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘할 것으로 기대됩니다. 또한 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력은 과학 연구 분야에서도 큰 도움이 될 것입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>앞으로의 발전 방향  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI의 o 시리즈 모델들은 인공지능의 미래를 보여주는 중요한 이정표라고 생각해요. 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 추세를 따른다는 사실은, 앞으로도 더 많은 컴퓨팅 파워를 투입하면 성능이 계속 향상될 수 있다는 것을 시사합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">또한 도구 사용에 대한 강화학습의 성공은 향후 AI 모델들이 더 다양한 도구를 효과적으로 활용할 수 있게 될 것임을 암시합니다. 이는 AI가 더 자율적이고 에이전트적인 역할을 할 수 있게 되는 방향으로 발전한다는 의미겠죠.</p>\n<p data-ke-size=\"size16\">시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결 능력은 앞으로 더 발전해 다양한 분야에서 혁신적인 응용을 가능하게 할 것입니다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"1013\" data-origin-height=\"678\"><span data-url=\"https://blog.kakaocdn.net/dn/d0uCQM/btsNn923Xa9/m2efxCnY5nJuAHpUYT1o70/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/d0uCQM/btsNn923Xa9/m2efxCnY5nJuAHpUYT1o70/img.png\"><img src=\"https://blog.kakaocdn.net/dn/d0uCQM/btsNn923Xa9/m2efxCnY5nJuAHpUYT1o70/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd0uCQM%2FbtsNn923Xa9%2Fm2efxCnY5nJuAHpUYT1o70%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"챗GPT o3와 o4-mini 성능\" loading=\"lazy\" width=\"1013\" height=\"678\" data-origin-width=\"1013\" data-origin-height=\"678\"/></span></figure>\n</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>정리해보자면...  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI의 o3와 o4-mini는 그저 작은 업데이트가 아니라 AI 기술의 중요한 도약이라고 생각해요. 최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘한다는 사실은 이 모델들이 실용적인 면에서도 큰 가치가 있음을 보여줍니다.</p>\n<p data-ke-size=\"size16\">이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이러한 능력은 AI 보조자의 역할과 가능성을 크게 확장시킬 것입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">앞으로 AI 기술이 어떻게 발전할지, 그리고 우리의 삶과 일에 어떤 변화를 가져올지 정말 기대가 되네요. 여러분은 이런 새로운 AI 모델들에 대해 어떻게 생각하시나요? 댓글로 여러분의 생각을 공유해주세요!  </p>\n<hr data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\"><b>자주 묻는 질문 (FAQ)</b></span></h2>\n<p data-ke-size=\"size16\"><b>Q: o3와 o4-mini는 언제부터 사용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: o3와 o4-mini의 가장 큰 차이점은 무엇인가요?</b></p>\n<p data-ke-size=\"size16\">A: O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 이 모델들은 이전 GPT 모델들과 어떻게 다른가요?</b></p>\n<p data-ke-size=\"size16\">A: 더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 이 모델들은 어떤 도구들을 사용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 일반 사용자들에게는 어떤 혜택이 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.</p>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini는 언제부터 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini의 가장 큰 차이점은 무엇인가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 이전 GPT 모델들과 어떻게 다른가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 어떤 도구들을 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"일반 사용자들에게는 어떤 혜택이 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.\"\n    }\n  }]\n}\n</script>",
        "contentSnippet": "OpenAI의 새 모델 o3와 o4-mini가 뭐길래 이렇게 화제인걸까요? 더 오래 생각하고, 도구를 사용하며, 이미지까지 이해하는 이 모델들이 AI의 미래를 어떻게 바꿀지 함께 알아보세요!  \n\n\n \n요즘 인공지능 업계는 진짜 숨 돌릴 틈이 없는 것 같아요. 오늘은 OpenAI가 또 새로운 모델을 내놨네요. 솔직히 따라가기 벅찬 느낌이랄까요? 특히 이번에 공개된 OpenAI의 o3와 o4-mini는 정말 많은 관심을 받고 있더라고요. 근데 이게 진짜 대단한 혁신인지, 아니면 그냥 마케팅 전략인지 궁금해서 한번 자세히 들여다봤어요. 여러분도 이런 고민 한번쯤 해보셨죠?\n \no 시리즈가 뭘까? 그리고 이게 왜 중요할까?  \nOpenAI의 새로운 o3와 o4-mini는 생각하는 시간을 더 길게 가지고 응답할 수 있도록 학습된 O 시리즈의 최신 모델입니다. 이 모델들은 지금까지 OpenAI가 출시한 모델 중 가장 똑똑한 모델로, ChatGPT의 기능에 큰 변화를 가져올 것으로 예상됩니다.\n특히 주목할 점은 이 모델들이 챗GPT 내의 모든 도구를 에이전트처럼 사용하고 결합할 수 있다는 것입니다. 여기에는 웹 검색, 업로드된 파일 및 기타 데이터를 Python으로 분석하는 기능, 시각적 입력에 대한 심층 추론, 심지어 이미지 생성까지 포함됩니다. 이건 진짜 획기적인 변화 아닐까요?  \n \n이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이를 통해 다면적인 질문을 더 효과적으로 해결할 수 있게 되었고, 이는 사용자를 대신해 독립적으로 작업을 실행할 수 있는 더 에이전트형 ChatGPT를 향한 한 걸음이라고 볼 수 있습니다.\n \n최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.\n \no3와 o4-mini의 차이점은 무엇일까?  \n모델\n주요 특징\n최적 사용 케이스\n\n\n\n\nOpenAI o3\n가장 강력한 추론 모델, 코딩/수학/과학/시각적 인식에서 최고 성능, o1보다 20% 더 적은 오류율\n복잡한 다면적 분석, 이미지/차트/그래픽 분석, 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상\n\n\nOpenAI o4-mini\n빠르고 비용 효율적인 추론에 최적화, 크기와 비용 대비 뛰어난 성능, AIME 2024/2025 벤치마크 1위\n수학, 코딩, 시각적 작업, 데이터 과학, 고용량/고처리량 필요 작업\n\n\n\nOpenAI o3는 회사의 가장 강력한 추론 모델로, 코딩, 수학, 과학, 시각적 인식 등 여러 분야에서 최첨단 성능을 발휘합니다. Codeforces, SWE-bench (별도의 모델별 스캐폴드 없이), MMMU 등의 벤치마크에서 새로운 최고 성능을 기록했죠. 이 모델은 복잡한 다면적 분석이 필요하고 즉각적인 답이 명확하지 않은 복잡한 질의에 이상적입니다. 특히 이미지, 차트, 그래픽 분석과 같은 시각적 작업에서 강점을 보입니다.\n \n외부 전문가들의 평가에 따르면, o3는 어려운 실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘합니다. 초기 테스터들은 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력을 강조했습니다.\n \n반면에, OpenAI o4-mini는 빠르고 비용 효율적인 추론에 최적화된 더 작은 모델입니다. 크기와 비용 대비 놀라운 성능을 보이며, 특히 수학, 코딩, 시각적 작업에서 뛰어납니다. AIME 2024와 2025 벤치마크에서 가장 뛰어난 성능을 보이는 모델입니다. 전문가 평가에서도 데이터 과학과 같은 분야뿐만 아니라 비-STEM 작업에서도 이전 모델인 o3-mini보다 뛰어난 성능을 보였습니다.\n효율성 덕분에 o3보다 훨씬 더 높은 사용 제한을 지원하여, 추론이 필요한 질문에 대해 강력한 고용량, 고처리량 옵션이 됩니다.\n \n실제 성능은 어떨까?  \n벤치마크/작업\no1\no3-mini\no3\no4-mini\n\n\n\n\nAIME 2024 (경쟁 수학)\n74.3%\n87.3%\n91.6%\n93.4%\n\n\nCodeforces (경쟁 코딩)\n1891\n2073\n2706\n2719\n\n\nMMMU (대학 수준 시각적 문제 해결)\n77.6%\n-\n82.9%\n81.6%\n\n\n\n벤치마크 성능을 보면 정말 놀랍습니다. 외부 전문가 평가자들은 두 모델 모두 향상된 명령 준수와 이전 모델보다 더 유용하고 검증 가능한 응답을 보여준다고 평가했습니다. 이는 향상된 지능과 웹 소스의 통합 덕분입니다. 이전 추론 모델 반복과 비교할 때, 이 두 모델은 특히 기억과 과거 대화를 참조하여 응답을 더 개인화하고 관련성을 높이는 데 있어 더 자연스럽고 대화적이라고 합니다.\n \nOpenAI o3는 ChatGPT 내 전체 도구 접근권과 함께 API를 통한 사용자 지정 도구에도 접근할 수 있습니다. 이 모델들은 문제 해결 방법을 추론하고, 도구를 언제, 어떻게 사용할지 선택하여 일반적으로 1분 이내에 올바른 출력 형식으로 상세하고 사려 깊은 답변을 빠르게 생성하도록 학습되었습니다.\n \n예를 들어, 사용자가 \"캘리포니아의 여름 에너지 사용량이 작년과 비교하여 어떻게 될까요?\"라고 물을 수 있습니다. 이때 모델은 공공 유틸리티 데이터에 대한 웹 검색을 하고, 예측을 구축하기 위한 Python 코드를 작성하고, 그래프나 이미지를 생성한 다음, 예측 뒤에 있는 주요 요소를 설명할 수 있습니다. 이 과정에서 여러 도구 호출을 연결합니다.\n \n추론을 통해 모델은 접하는 정보에 따라 필요에 따라 반응하고 방향을 전환할 수 있습니다. 예를 들어, 검색 제공업체의 도움을 받아 웹을 여러 번 검색하고, 결과를 살펴보고, 더 많은 정보가 필요한 경우 새로운 검색을 시도할 수 있습니다.\n \n예를 통해 본 성능 차이  \nOpenAI는 이 모델들의 뛰어난 성능을 보여주는 몇 가지 예시를 제공했습니다. o3와 o1의 성능을 비교하면 그 차이가 확연히 드러납니다.\n \n예를 들어, 복잡한 수학 문제에서 o3는 디크슨 다항식(Dickson polynomial)을 사용해 문제를 정확히 풀어내는 반면, o1은 시간이 더 걸리고 부정확한 해결책을 제시합니다.\n \n또한 호텔 체인 확장에 관한 질문에서도 o3는 실제 데이터를 활용한 철저한 분석을 통해 아테네와 오사카를 목표 도시로 추천했습니다. 각 도시의 점유율, RevPAR 성장률, 승객 증가율 등 구체적인 지표와 2024년 통계자료를 바탕으로 상세한 비교 테이블까지 제공했죠.\n \n배터리 기술 발전에 관한 질문에서도 o3는 리튬 이온 배터리, 솔리드 스테이트 배터리, 나트륨 이온 배터리 등 최신 기술의 영향을 상세히 분석하며, 2011년부터 2024년까지의 전기차 주행거리, 충전 속도, 보급률 등의 변화를 그래프로 시각화해 보여주었습니다.\nMLB 피치 클럭 규칙이 투수 성능과 게임 시간에 미친 영향에 관한 질문에서도 o3는 구체적인 통계 데이터를 활용해 2021년부터 2024년까지의 변화를 상세히 분석했습니다. 규칙 도입 이후 게임 시간이 24분 단축됐고, 초기에는 투수들의 ERA가 상승했지만 적응 기간을 거쳐 다시 안정되었다는 흥미로운 분석을 제공했죠.\n \n이런 예시들을 보면 o3와 o4-mini의 성능이 정말 인상적이라는 걸 알 수 있어요.\n \n핵심 기술적 특징  \n기술적 혁신\n특징\n영향\n\n\n\n\n강화학습 확장\n\"더 많은 컴퓨팅 = 더 나은 성능\" 트렌드 확인\n더 오래 생각할수록 성능이 지속적으로 향상\n\n\n에이전트형 도구 사용\n도구를 언제, 어떻게 사용할지 추론하는 능력\n시각적 추론, 다단계 워크플로우 처리 능력 향상\n\n\n이미지 통합 사고\n이미지를 사고 과정에 직접 통합\n시각적, 텍스트 추론을 혼합한 새로운 문제 해결 가능\n\n\n\nOpenAI의 o3 개발 과정에서, 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 GPT 시리즈 사전 학습에서 관찰된 것과 동일한 추세를 보여주는 것으로 확인됐습니다. OpenAI는 현재 강화학습에서 이 확장 경로를 다시 따라가며, 학습 컴퓨팅과 추론 시간을 추가로 10배 증가시켰음에도 여전히 성능 향상이 명확하게 보이는 것을 확인했습니다. 이는 모델이 더 오래 생각할수록 성능이 계속 향상된다는 것을 검증합니다.\n \no3와 o4-mini는 강화학습을 통해 도구를 사용하도록 학습되었습니다. 이는 단순히 도구 사용법을 학습하는 것이 아니라, 언제 도구를 사용할지에 대해 추론하는 능력을 키웠다는 의미입니다. 원하는 결과에 따라 도구를 배치하는 능력은 특히 시각적 추론과 다단계 워크플로우를 포함하는 개방형 상황에서 더 유능하게 만듭니다.\n \n이러한 개선은 학술 벤치마크와 실제 작업 모두에서 반영되어, 초기 테스터들의 보고에서도 확인됩니다.\n또한 이 모델들은 처음으로 이미지를 직접 사고 과정에 통합할 수 있습니다. 단순히 이미지를 보는 것이 아니라, 그것을 가지고 생각합니다. 이는 시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결을 가능하게 하며, 이는 다양한 다중모달 벤치마크에서의 최첨단 성능으로 반영됩니다.\n \n실생활에서의 응용 가능성  ️\n이 새로운 모델들의 활용 가능성은 정말 광범위해요. 일상적인 작업부터 복잡한 비즈니스 문제, 교육, 연구까지 다양한 분야에서 활용될 수 있습니다. 예를 들어, 공공 유틸리티 데이터를 검색하고, 예측 모델을 구축하며, 결과를 시각화하는 복잡한 작업을 한 번에 처리할 수 있습니다.\n\n\n \n이러한 유연하고 전략적인 접근 방식을 통해 모델은 모델의 내장 지식을 넘어서는 최신 정보에 대한 접근, 확장된 추론, 합성, 여러 양식에 걸친 출력 생성이 필요한 작업을 처리할 수 있습니다.\n \n특히 비즈니스 분야에서는 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘할 것으로 기대됩니다. 또한 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력은 과학 연구 분야에서도 큰 도움이 될 것입니다.\n \n앞으로의 발전 방향  \nOpenAI의 o 시리즈 모델들은 인공지능의 미래를 보여주는 중요한 이정표라고 생각해요. 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 추세를 따른다는 사실은, 앞으로도 더 많은 컴퓨팅 파워를 투입하면 성능이 계속 향상될 수 있다는 것을 시사합니다.\n \n또한 도구 사용에 대한 강화학습의 성공은 향후 AI 모델들이 더 다양한 도구를 효과적으로 활용할 수 있게 될 것임을 암시합니다. 이는 AI가 더 자율적이고 에이전트적인 역할을 할 수 있게 되는 방향으로 발전한다는 의미겠죠.\n시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결 능력은 앞으로 더 발전해 다양한 분야에서 혁신적인 응용을 가능하게 할 것입니다.\n\n\n정리해보자면...  \nOpenAI의 o3와 o4-mini는 그저 작은 업데이트가 아니라 AI 기술의 중요한 도약이라고 생각해요. 최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.\n \n실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘한다는 사실은 이 모델들이 실용적인 면에서도 큰 가치가 있음을 보여줍니다.\n이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이러한 능력은 AI 보조자의 역할과 가능성을 크게 확장시킬 것입니다.\n \n앞으로 AI 기술이 어떻게 발전할지, 그리고 우리의 삶과 일에 어떤 변화를 가져올지 정말 기대가 되네요. 여러분은 이런 새로운 AI 모델들에 대해 어떻게 생각하시나요? 댓글로 여러분의 생각을 공유해주세요!  \n자주 묻는 질문 (FAQ)\nQ: o3와 o4-mini는 언제부터 사용할 수 있나요?\nA: 이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.\nQ: o3와 o4-mini의 가장 큰 차이점은 무엇인가요?\nA: O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.\nQ: 이 모델들은 이전 GPT 모델들과 어떻게 다른가요?\nA: 더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.\nQ: 이 모델들은 어떤 도구들을 사용할 수 있나요?\nA: 웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.\nQ: 일반 사용자들에게는 어떤 혜택이 있나요?\nA: 더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.\n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini는 언제부터 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini의 가장 큰 차이점은 무엇인가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 이전 GPT 모델들과 어떻게 다른가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 어떤 도구들을 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"일반 사용자들에게는 어떤 혜택이 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.\"\n    }\n  }]\n}",
        "guid": "http://muzbox.tistory.com/483570",
        "categories": [
          "AI, 미래기술/AI 챗봇 및 언어 모델",
          "AI 모델",
          "o4-mini",
          "openai o3",
          "강화학습",
          "도구 사용",
          "문제 해결",
          "벤치마크 성능",
          "시각적 추론",
          "에이전트 ai",
          "추론 능력"
        ],
        "isoDate": "2025-04-16T23:39:33.000Z"
      },
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "GPT-4.1, mini, nano 총정리: 성능, 가격, 활용법까지 한번에",
        "link": "http://muzbox.tistory.com/483569",
        "pubDate": "Wed, 16 Apr 2025 10:06:48 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483569#entry483569comment",
        "content": "<p data-ke-size=\"size16\">GPT-4.1 시리즈의 혁신적 기능과 성능 향상을 소개합니다. 코딩, 긴 컨텍스트 처리, 지시 이행 능력이 크게 개선되었고, 최초의 나노 모델까지 출시된 GPT-4.1의 모든 것을 파헤쳐볼게요!</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"edited_GPT-4.1 패밀리 총정리.jpg\" data-origin-width=\"1920\" data-origin-height=\"1080\"><span data-url=\"https://blog.kakaocdn.net/dn/bso32X/btsNmvyyFST/RQI7KTppDTErnKLy2rDZuk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/bso32X/btsNmvyyFST/RQI7KTppDTErnKLy2rDZuk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/bso32X/btsNmvyyFST/RQI7KTppDTErnKLy2rDZuk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbso32X%2FbtsNmvyyFST%2FRQI7KTppDTErnKLy2rDZuk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"GPT-4.1, mini, nano 총정리: 성능, 가격, 활용법까지 한번에\" loading=\"lazy\" width=\"1920\" height=\"1080\" data-filename=\"edited_GPT-4.1 패밀리 총정리.jpg\" data-origin-width=\"1920\" data-origin-height=\"1080\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">어제 정말 신기한 뉴스를 봤어요. OpenAI가 또 새로운 모델을 출시했더라고요. 요새 AI 기술이 진짜 미친 속도로 발전하는데, 그냥 따라가기도 버거울 지경이에요. 근데 이번에 나온 GPT-4.1 시리즈는 뭔가 특별해 보이더라고요. 코딩 능력이 확 좋아졌다는데, 개발자분들은 어떻게 생각하세요? 저같은 일반인한테도 도움될까요?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>GPT-4.1 시리즈, 무엇이 달라졌을까?  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI가 API를 통해 제공하는 세 가지 새로운 모델을 소개했어요. GPT-4.1, GPT-4.1 mini, 그리고 GPT-4.1 nano까지. 이 모델들은 기존의 GPT-4o와 GPT-4o mini보다 전반적으로 더 뛰어난 성능을 보여준다고 해요. 특히 코딩과 지시사항 이행 능력에서 엄청난 발전이 있었다고 하네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">가장 눈에 띄는 변화는 <b>컨텍스트 윈도우</b>의 크기예요. 무려 100만 토큰까지 처리할 수 있게 되었다고 해요! 이전 모델들이 128,000 토큰까지 처리할 수 있었던 것과 비교하면 정말 큰 발전이죠. 그리고 단순히 더 많은 컨텍스트를 처리하는 것뿐만 아니라, 그 컨텍스트를 더 효율적으로 이해하고 활용할 수 있게 되었다고 해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">또한 지식 기반도 업데이트되어 2024년 6월까지의 정보를 담고 있어요. 이제 좀 더 최신 정보에 대해서도 물어볼 수 있겠네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>코딩 능력이 대폭 향상됐어요  </b></span></h2>\n<p data-ke-size=\"size16\">제가 개인적으로 가장 흥미로웠던 부분은 코딩 능력의 향상이에요. GPT-4.1은 SWE-bench Verified에서 54.6%의 점수를 받았다고 해요. 이는 GPT-4o의 33.2%보다 무려 21.4% 포인트나 높은 점수예요!</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #4285f4; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">모델</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">SWE-bench Verified 점수</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">향상된 정도</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">54.6%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">기준</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4o</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">33.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">-21.4%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.5</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">38.0%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">-16.6%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">실제 사용자들의 반응도 놀라웠어요. Windsurf라는 회사에서는 GPT-4.1이 내부 코딩 벤치마크에서 GPT-4o보다 60% 높은 점수를 받았다고 해요. 특히 도구 호출에서 30% 더 효율적이었고, 불필요한 편집을 반복할 가능성이 약 50% 낮았다고 하네요.</p>\n<p data-ke-size=\"size16\">이거 진짜 대단한 발전 아닌가요? 개발자들이 코드를 작성하고, 디버깅하는 데 훨씬 더 도움이 될 것 같아요. 제가 개발자는 아니지만, 이런 발전이 미래의 소프트웨어 개발에 어떤 영향을 미칠지 정말 궁금해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>지시 이행 능력도 확실히 좋아졌어요  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4.1은 지시 이행 능력도 크게 향상되었어요. 특히 Format following, Negative instructions, Ordered instructions, Content requirements, Ranking, Overconfidence 등 여러 범주에서 성능이 향상되었다고 해요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #34a853; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">벤치마크</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4.1</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4o</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">향상도</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">MultiChallenge</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">38.3%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">27.8%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">+10.5%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">IFEval</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">87.4%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">81.0%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">+6.4%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">내부 API 지시 이행 (어려운 유형)</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">49.1%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">29.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">+19.9%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">실제로 세금 관련 회사인 Blue J에서는 GPT-4.1이 내부 벤치마크에서 GPT-4o보다 53% 더 정확했다고 해요. Hex라는 회사에서는 SQL 평가 세트에서 거의 2배 향상된 성능을 보였다고 하네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이런 개선은 복잡한 지시사항을 더 잘 따를 수 있게 해준다는 뜻이니까, 실무에서 활용도가 훨씬 높아질 것 같아요. 솔직히 말해서, 이전 모델들도 간단한 지시는 잘 따랐지만 복잡한 지시나 여러 단계의 지시는 종종 헷갈려 했잖아요? 이제 그런 문제가 많이 해결될 것 같네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>100만 토큰의 긴 컨텍스트, 어떻게 활용할까?  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4.1 시리즈의 가장 큰 변화 중 하나는 100만 토큰의 컨텍스트 윈도우예요. 이건 React 코드베이스 전체를 8개 넣을 수 있는 양이라고 하네요. 진짜 엄청난 양이죠?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">OpenAI는 GPT-4.1이 이 긴 컨텍스트에서 정보를 효과적으로 찾고 활용할 수 있도록 특별히 훈련시켰다고 해요. 'Needle in a Haystack' 테스트에서 GPT-4.1은 100만 토큰 안에 숨겨진 정보를 정확하게 찾아낼 수 있었다고 해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">또 흥미로운 점은 OpenAI가 새로운 평가 방식인 OpenAI-MRCR과 Graphwalks를 공개했다는 거예요. 이 평가들은 모델이 긴 컨텍스트에서 여러 정보를 어떻게 찾고 연결하는지 테스트하는 방식이라고 해요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #ea4335; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">모델</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">컨텍스트 윈도우</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">OpenAI-MRCR (2 바늘) 128k</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">Graphwalks bfs &lt;128k</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">100만 토큰</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">57.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">61.7%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 mini</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">100만 토큰</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">47.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">61.7%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 nano</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">100만 토큰</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">36.6%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">25.0%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4o</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">128k 토큰</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">31.9%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">41.7%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">실제 사용 사례도 인상적이었어요. Thomson Reuters는 GPT-4.1을 사용해 다중 문서 검토 정확도를 17% 향상시켰고, Carlyle은 매우 큰 문서에서 세부적인 재무 데이터를 추출하는 성능이 50% 향상되었다고 해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">솔직히 말해서, 이런 긴 컨텍스트 기능은 법률, 금융, 의료 등 복잡한 문서를 다루는 분야에서 정말 혁신적인 변화를 가져올 것 같아요. 생각해보세요, 수백 페이지의 계약서나 의료 기록을 한 번에 분석할 수 있다면 얼마나 편리할까요?</p>\n<blockquote data-ke-style=\"style3\"><b> 컨텍스트</b>는 AI 모델이 대화나 질문을 이해하기 위해 고려하는 배경 정보나 이전 대화 내용을 의미해요. 쉽게 설명하자면, 사람과 대화할 때 이전에 나눈 모든 대화를 기억하고 참고하는 것과 비슷해요.</blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>비전(Vision) 능력도 강화됐어요  ️</b></span></h2>\n<p data-ke-size=\"size16\">GPT-4.1 시리즈는 이미지 이해 능력도 크게 향상되었어요. 특히 GPT-4.1 mini는 이미지 벤치마크에서 종종 GPT-4o보다 더 좋은 성능을 보여줬다고 해요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #fbbc05; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">벤치마크</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4.1</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4.1 mini</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4o</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">MMMU</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">74.8%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">72.7%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">68.7%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">MathVista</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">72.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">73.1%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">61.4%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">CharXiv-R</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">56.7%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">56.8%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">52.7%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">Video-MME (자막 없음)</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">72.0%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">-</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">65.3%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">MMMU에서 GPT-4.1은 74.8%, GPT-4.1 mini는 72.7%의 점수를 받았어요. 이는 GPT-4o의 68.7%보다 훨씬 높은 점수죠. MathVista에서도 GPT-4.1은 72.2%, GPT-4.1 mini는 73.1%로 GPT-4o의 61.4%를 크게 앞섰어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">Video-MME 테스트에서는 GPT-4.1이 72.0%의 점수를 얻어 GPT-4o의 65.3%보다 훨씬 좋은 성적을 거뒀어요. 이 테스트는 30-60분 길이의 자막 없는 비디오를 기반으로 질문에 답하는 테스트인데, 정말 인상적인 성능이죠?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">아직 사진이나 비디오를 많이 활용하진 않지만, 앞으로는 이런 비전 능력을 활용한 애플리케이션이 더 많아질 것 같아요. 제 생각엔 교육이나 의료 분야에서 특히 유용할 것 같네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>가격은 어떻게 변했을까?  </b></span></h2>\n<p data-ke-size=\"size16\">가격도 상당히 흥미로웠어요. OpenAI는 추론 시스템의 효율성 향상으로 GPT-4.1 시리즈의 가격을 낮출 수 있었다고 해요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #673ab7; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">모델</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">입력 (100만 토큰)</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">캐시된 입력 (100만 토큰)</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">출력 (100만 토큰)</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">혼합 가격*</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$2.00</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.50</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$8.00</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$1.84</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 mini</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.40</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.10</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$1.60</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.42</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 nano</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.10</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.025</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.40</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.12</td>\n</tr>\n</tbody>\n</table>\n<p style=\"font-size: 0.9em; font-style: italic;\" data-ke-size=\"size16\">*일반적인 입력/출력 및 캐시 비율 기준</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">GPT-4.1은 중간 규모 쿼리의 경우 GPT-4o보다 26% 저렴하고, GPT-4.1 nano는 가장 저렴하고 빠른 모델이라고 해요.</p>\n<p data-ke-size=\"size16\">또 하나 좋은 점은 캐시된 입력에 대한 할인이 이전의 50%에서 75%로 증가했다는 거예요. 같은 컨텍스트를 반복해서 전달하는 경우에 더 많은 비용을 절약할 수 있게 된 거죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">확실히 더 저렴해진 가격은 중소기업이나 개인 개발자들에게 큰 도움이 될 것 같아요. 특히 GPT-4.1 nano는 정말 매력적인 가격대라고 생각해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>내가 받은 느낌은?  </b></span></h2>\n<p data-ke-size=\"size16\">이번 GPT-4.1 시리즈 발표를 보면서 정말 많은 생각이 들었어요. AI 기술이 이렇게 빠르게 발전하는 걸 보니 약간 두렵기도 하지만, 동시에 정말 기대되기도 해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">특히 코딩 능력의 향상은 소프트웨어 개발 방식을 완전히 바꿀 수 있을 것 같아요. 개발자들이 복잡한 코드를 더 쉽게 작성하고 수정할 수 있게 되면, 더 빠르게 혁신적인 제품들이 나올 수 있겠죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">긴 컨텍스트 기능도 정말 흥미로워요. 법률 문서, 의학 연구, 학술 논문 등 긴 문서를 분석하는 데 엄청난 도움이 될 것 같아요. 이전에는 불가능했던 방식으로 정보를 처리하고 통찰력을 얻을 수 있게 될 거예요.</p>\n<p data-ke-size=\"size16\">지시 이행 능력의 향상은 AI가 더 신뢰할 수 있는 도구가 되었다는 걸 의미해요. 사용자가 원하는 정확한 결과를 더 쉽게 얻을 수 있게 되었으니까요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">하지만 여전히 몇 가지 질문도 남아있어요. 이런 강력한 AI 도구들이 사회에 어떤 영향을 미칠까요? 직업 시장은 어떻게 변할까요? 우리는 어떻게 이 기술을 책임감 있게 사용할 수 있을까요?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>GPT-4.1 시리즈, 누구를 위한 모델일까?  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4.1 시리즈는 다양한 사용자와 사용 사례를 위해 설계되었어요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #009688; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">모델</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">주요 사용자층</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">주요 특징</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">비용 효율성</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">최고 성능을 원하는 사용자</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">코딩 능력, 정확한 지시 이행, 긴 문서 분석</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">중간</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 mini</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">균형 잡힌 성능과 비용을 원하는 사용자</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4o보다 더 좋은 성능, 지연 시간 절반</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">높음</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 nano</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">짧은 대기 시간이 중요한 작업</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">분류, 자동 완성, 100만 토큰 컨텍스트</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">매우 높음</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">GPT-4.1은 최고의 성능을 원하는 사용자를 위한 모델이에요. 복잡한 코딩 작업, 정확한 지시 이행이 필요한 작업, 긴 문서 분석 등에 적합해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">GPT-4.1 mini는 균형 잡힌 성능과 비용을 원하는 사용자에게 적합해요. GPT-4o보다 여러 벤치마크에서 더 좋은 성능을 보이면서도 지연 시간은 절반으로 줄고 비용은 83% 감소했다고 하니 정말 매력적이죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">GPT-4.1 nano는 짧은 대기 시간이 중요한 작업에 적합해요. 분류나 자동 완성과 같은 작업에 이상적이라고 해요. 100만 토큰의 컨텍스트 윈도우를 가지고 있으면서도 MMLU에서 80.1%, GPQA에서 50.3%의 높은 점수를 받았대요.</p>\n<p data-ke-size=\"size16\">저는 개인적으로 GPT-4.1 mini가 가성비 면에서 가장 좋은 선택일 것 같다는 생각이 들어요. 대부분의 일반적인 작업에 충분한 성능을 제공하면서도 비용은 상당히 저렴하니까요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"1263\" data-origin-height=\"794\"><span data-url=\"https://blog.kakaocdn.net/dn/k8Dbg/btsNnx9IUT0/EblLfRQjlhiSN4qaUeA101/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/k8Dbg/btsNnx9IUT0/EblLfRQjlhiSN4qaUeA101/img.png\"><img src=\"https://blog.kakaocdn.net/dn/k8Dbg/btsNnx9IUT0/EblLfRQjlhiSN4qaUeA101/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fk8Dbg%2FbtsNnx9IUT0%2FEblLfRQjlhiSN4qaUeA101%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"GPT-4.1 시리즈, 무엇이 달라졌을까?\" loading=\"lazy\" width=\"1263\" height=\"794\" data-origin-width=\"1263\" data-origin-height=\"794\"/></span></figure>\n</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\"><b>자주 묻는 질문 (FAQ) ❓</b></span></h2>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.1은 ChatGPT에서도 사용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?</b></p>\n<p data-ke-size=\"size16\">A: GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.1 시리즈의 가격은 어떻게 되나요?</b></p>\n<p data-ke-size=\"size16\">A: GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.5 Preview는 어떻게 되나요?</b></p>\n<p data-ke-size=\"size16\">A: GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 2024년 6월까지의 정보를 담고 있습니다.</p>\n<div style=\"margin: 0px auto; border: 2px dashed #ff5722; position: absolute; z-index: 2147483647; visibility: hidden; background-color: rgba(255, 87, 34, 0.1); left: 738px; width: 0px; top: 2092px; height: 0px;\">&nbsp;</div>\n<div style=\"z-index: 2147483647; position: absolute; visibility: hidden; padding: 5px 10px; font-size: 14px; font-family: Arial, sans-serif; color: #ffffff; background-color: #00633e; border-radius: 15px; box-shadow: rgba(0, 0, 0, 0.2) 0px 2px 5px; font-weight: bold; left: 753px; top: 2052px;\">&nbsp;</div>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1은 ChatGPT에서도 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 가격은 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.5 Preview는 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"2024년 6월까지의 정보를 담고 있습니다.\"\n    }\n  }]\n}\n</script>",
        "contentSnippet": "GPT-4.1 시리즈의 혁신적 기능과 성능 향상을 소개합니다. 코딩, 긴 컨텍스트 처리, 지시 이행 능력이 크게 개선되었고, 최초의 나노 모델까지 출시된 GPT-4.1의 모든 것을 파헤쳐볼게요!\n\n\n \n어제 정말 신기한 뉴스를 봤어요. OpenAI가 또 새로운 모델을 출시했더라고요. 요새 AI 기술이 진짜 미친 속도로 발전하는데, 그냥 따라가기도 버거울 지경이에요. 근데 이번에 나온 GPT-4.1 시리즈는 뭔가 특별해 보이더라고요. 코딩 능력이 확 좋아졌다는데, 개발자분들은 어떻게 생각하세요? 저같은 일반인한테도 도움될까요?\n \nGPT-4.1 시리즈, 무엇이 달라졌을까?  \nOpenAI가 API를 통해 제공하는 세 가지 새로운 모델을 소개했어요. GPT-4.1, GPT-4.1 mini, 그리고 GPT-4.1 nano까지. 이 모델들은 기존의 GPT-4o와 GPT-4o mini보다 전반적으로 더 뛰어난 성능을 보여준다고 해요. 특히 코딩과 지시사항 이행 능력에서 엄청난 발전이 있었다고 하네요.\n \n가장 눈에 띄는 변화는 컨텍스트 윈도우의 크기예요. 무려 100만 토큰까지 처리할 수 있게 되었다고 해요! 이전 모델들이 128,000 토큰까지 처리할 수 있었던 것과 비교하면 정말 큰 발전이죠. 그리고 단순히 더 많은 컨텍스트를 처리하는 것뿐만 아니라, 그 컨텍스트를 더 효율적으로 이해하고 활용할 수 있게 되었다고 해요.\n \n또한 지식 기반도 업데이트되어 2024년 6월까지의 정보를 담고 있어요. 이제 좀 더 최신 정보에 대해서도 물어볼 수 있겠네요.\n \n코딩 능력이 대폭 향상됐어요  \n제가 개인적으로 가장 흥미로웠던 부분은 코딩 능력의 향상이에요. GPT-4.1은 SWE-bench Verified에서 54.6%의 점수를 받았다고 해요. 이는 GPT-4o의 33.2%보다 무려 21.4% 포인트나 높은 점수예요!\n모델\nSWE-bench Verified 점수\n향상된 정도\n\n\n\n\nGPT-4.1\n54.6%\n기준\n\n\nGPT-4o\n33.2%\n-21.4%\n\n\nGPT-4.5\n38.0%\n-16.6%\n\n\n\n실제 사용자들의 반응도 놀라웠어요. Windsurf라는 회사에서는 GPT-4.1이 내부 코딩 벤치마크에서 GPT-4o보다 60% 높은 점수를 받았다고 해요. 특히 도구 호출에서 30% 더 효율적이었고, 불필요한 편집을 반복할 가능성이 약 50% 낮았다고 하네요.\n이거 진짜 대단한 발전 아닌가요? 개발자들이 코드를 작성하고, 디버깅하는 데 훨씬 더 도움이 될 것 같아요. 제가 개발자는 아니지만, 이런 발전이 미래의 소프트웨어 개발에 어떤 영향을 미칠지 정말 궁금해요.\n \n지시 이행 능력도 확실히 좋아졌어요  \nGPT-4.1은 지시 이행 능력도 크게 향상되었어요. 특히 Format following, Negative instructions, Ordered instructions, Content requirements, Ranking, Overconfidence 등 여러 범주에서 성능이 향상되었다고 해요.\n벤치마크\nGPT-4.1\nGPT-4o\n향상도\n\n\n\n\nMultiChallenge\n38.3%\n27.8%\n+10.5%\n\n\nIFEval\n87.4%\n81.0%\n+6.4%\n\n\n내부 API 지시 이행 (어려운 유형)\n49.1%\n29.2%\n+19.9%\n\n\n\n실제로 세금 관련 회사인 Blue J에서는 GPT-4.1이 내부 벤치마크에서 GPT-4o보다 53% 더 정확했다고 해요. Hex라는 회사에서는 SQL 평가 세트에서 거의 2배 향상된 성능을 보였다고 하네요.\n \n이런 개선은 복잡한 지시사항을 더 잘 따를 수 있게 해준다는 뜻이니까, 실무에서 활용도가 훨씬 높아질 것 같아요. 솔직히 말해서, 이전 모델들도 간단한 지시는 잘 따랐지만 복잡한 지시나 여러 단계의 지시는 종종 헷갈려 했잖아요? 이제 그런 문제가 많이 해결될 것 같네요.\n \n100만 토큰의 긴 컨텍스트, 어떻게 활용할까?  \nGPT-4.1 시리즈의 가장 큰 변화 중 하나는 100만 토큰의 컨텍스트 윈도우예요. 이건 React 코드베이스 전체를 8개 넣을 수 있는 양이라고 하네요. 진짜 엄청난 양이죠?\n \nOpenAI는 GPT-4.1이 이 긴 컨텍스트에서 정보를 효과적으로 찾고 활용할 수 있도록 특별히 훈련시켰다고 해요. 'Needle in a Haystack' 테스트에서 GPT-4.1은 100만 토큰 안에 숨겨진 정보를 정확하게 찾아낼 수 있었다고 해요.\n \n또 흥미로운 점은 OpenAI가 새로운 평가 방식인 OpenAI-MRCR과 Graphwalks를 공개했다는 거예요. 이 평가들은 모델이 긴 컨텍스트에서 여러 정보를 어떻게 찾고 연결하는지 테스트하는 방식이라고 해요.\n모델\n컨텍스트 윈도우\nOpenAI-MRCR (2 바늘) 128k\nGraphwalks bfs <128k\n\n\n\n\nGPT-4.1\n100만 토큰\n57.2%\n61.7%\n\n\nGPT-4.1 mini\n100만 토큰\n47.2%\n61.7%\n\n\nGPT-4.1 nano\n100만 토큰\n36.6%\n25.0%\n\n\nGPT-4o\n128k 토큰\n31.9%\n41.7%\n\n\n\n실제 사용 사례도 인상적이었어요. Thomson Reuters는 GPT-4.1을 사용해 다중 문서 검토 정확도를 17% 향상시켰고, Carlyle은 매우 큰 문서에서 세부적인 재무 데이터를 추출하는 성능이 50% 향상되었다고 해요.\n \n솔직히 말해서, 이런 긴 컨텍스트 기능은 법률, 금융, 의료 등 복잡한 문서를 다루는 분야에서 정말 혁신적인 변화를 가져올 것 같아요. 생각해보세요, 수백 페이지의 계약서나 의료 기록을 한 번에 분석할 수 있다면 얼마나 편리할까요?\n 컨텍스트는 AI 모델이 대화나 질문을 이해하기 위해 고려하는 배경 정보나 이전 대화 내용을 의미해요. 쉽게 설명하자면, 사람과 대화할 때 이전에 나눈 모든 대화를 기억하고 참고하는 것과 비슷해요.\n \n비전(Vision) 능력도 강화됐어요  ️\nGPT-4.1 시리즈는 이미지 이해 능력도 크게 향상되었어요. 특히 GPT-4.1 mini는 이미지 벤치마크에서 종종 GPT-4o보다 더 좋은 성능을 보여줬다고 해요.\n벤치마크\nGPT-4.1\nGPT-4.1 mini\nGPT-4o\n\n\n\n\nMMMU\n74.8%\n72.7%\n68.7%\n\n\nMathVista\n72.2%\n73.1%\n61.4%\n\n\nCharXiv-R\n56.7%\n56.8%\n52.7%\n\n\nVideo-MME (자막 없음)\n72.0%\n-\n65.3%\n\n\n\nMMMU에서 GPT-4.1은 74.8%, GPT-4.1 mini는 72.7%의 점수를 받았어요. 이는 GPT-4o의 68.7%보다 훨씬 높은 점수죠. MathVista에서도 GPT-4.1은 72.2%, GPT-4.1 mini는 73.1%로 GPT-4o의 61.4%를 크게 앞섰어요.\n \nVideo-MME 테스트에서는 GPT-4.1이 72.0%의 점수를 얻어 GPT-4o의 65.3%보다 훨씬 좋은 성적을 거뒀어요. 이 테스트는 30-60분 길이의 자막 없는 비디오를 기반으로 질문에 답하는 테스트인데, 정말 인상적인 성능이죠?\n \n아직 사진이나 비디오를 많이 활용하진 않지만, 앞으로는 이런 비전 능력을 활용한 애플리케이션이 더 많아질 것 같아요. 제 생각엔 교육이나 의료 분야에서 특히 유용할 것 같네요.\n \n가격은 어떻게 변했을까?  \n가격도 상당히 흥미로웠어요. OpenAI는 추론 시스템의 효율성 향상으로 GPT-4.1 시리즈의 가격을 낮출 수 있었다고 해요.\n모델\n입력 (100만 토큰)\n캐시된 입력 (100만 토큰)\n출력 (100만 토큰)\n혼합 가격*\n\n\n\n\nGPT-4.1\n$2.00\n$0.50\n$8.00\n$1.84\n\n\nGPT-4.1 mini\n$0.40\n$0.10\n$1.60\n$0.42\n\n\nGPT-4.1 nano\n$0.10\n$0.025\n$0.40\n$0.12\n\n\n\n*일반적인 입력/출력 및 캐시 비율 기준\n \nGPT-4.1은 중간 규모 쿼리의 경우 GPT-4o보다 26% 저렴하고, GPT-4.1 nano는 가장 저렴하고 빠른 모델이라고 해요.\n또 하나 좋은 점은 캐시된 입력에 대한 할인이 이전의 50%에서 75%로 증가했다는 거예요. 같은 컨텍스트를 반복해서 전달하는 경우에 더 많은 비용을 절약할 수 있게 된 거죠.\n \n확실히 더 저렴해진 가격은 중소기업이나 개인 개발자들에게 큰 도움이 될 것 같아요. 특히 GPT-4.1 nano는 정말 매력적인 가격대라고 생각해요.\n \n내가 받은 느낌은?  \n이번 GPT-4.1 시리즈 발표를 보면서 정말 많은 생각이 들었어요. AI 기술이 이렇게 빠르게 발전하는 걸 보니 약간 두렵기도 하지만, 동시에 정말 기대되기도 해요.\n \n특히 코딩 능력의 향상은 소프트웨어 개발 방식을 완전히 바꿀 수 있을 것 같아요. 개발자들이 복잡한 코드를 더 쉽게 작성하고 수정할 수 있게 되면, 더 빠르게 혁신적인 제품들이 나올 수 있겠죠.\n \n긴 컨텍스트 기능도 정말 흥미로워요. 법률 문서, 의학 연구, 학술 논문 등 긴 문서를 분석하는 데 엄청난 도움이 될 것 같아요. 이전에는 불가능했던 방식으로 정보를 처리하고 통찰력을 얻을 수 있게 될 거예요.\n지시 이행 능력의 향상은 AI가 더 신뢰할 수 있는 도구가 되었다는 걸 의미해요. 사용자가 원하는 정확한 결과를 더 쉽게 얻을 수 있게 되었으니까요.\n \n하지만 여전히 몇 가지 질문도 남아있어요. 이런 강력한 AI 도구들이 사회에 어떤 영향을 미칠까요? 직업 시장은 어떻게 변할까요? 우리는 어떻게 이 기술을 책임감 있게 사용할 수 있을까요?\n \nGPT-4.1 시리즈, 누구를 위한 모델일까?  \nGPT-4.1 시리즈는 다양한 사용자와 사용 사례를 위해 설계되었어요.\n모델\n주요 사용자층\n주요 특징\n비용 효율성\n\n\n\n\nGPT-4.1\n최고 성능을 원하는 사용자\n코딩 능력, 정확한 지시 이행, 긴 문서 분석\n중간\n\n\nGPT-4.1 mini\n균형 잡힌 성능과 비용을 원하는 사용자\nGPT-4o보다 더 좋은 성능, 지연 시간 절반\n높음\n\n\nGPT-4.1 nano\n짧은 대기 시간이 중요한 작업\n분류, 자동 완성, 100만 토큰 컨텍스트\n매우 높음\n\n\n\nGPT-4.1은 최고의 성능을 원하는 사용자를 위한 모델이에요. 복잡한 코딩 작업, 정확한 지시 이행이 필요한 작업, 긴 문서 분석 등에 적합해요.\n \nGPT-4.1 mini는 균형 잡힌 성능과 비용을 원하는 사용자에게 적합해요. GPT-4o보다 여러 벤치마크에서 더 좋은 성능을 보이면서도 지연 시간은 절반으로 줄고 비용은 83% 감소했다고 하니 정말 매력적이죠.\n \nGPT-4.1 nano는 짧은 대기 시간이 중요한 작업에 적합해요. 분류나 자동 완성과 같은 작업에 이상적이라고 해요. 100만 토큰의 컨텍스트 윈도우를 가지고 있으면서도 MMLU에서 80.1%, GPQA에서 50.3%의 높은 점수를 받았대요.\n저는 개인적으로 GPT-4.1 mini가 가성비 면에서 가장 좋은 선택일 것 같다는 생각이 들어요. 대부분의 일반적인 작업에 충분한 성능을 제공하면서도 비용은 상당히 저렴하니까요.\n \n\n\n\n자주 묻는 질문 (FAQ) ❓\nQ: GPT-4.1은 ChatGPT에서도 사용할 수 있나요?\nA: 아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.\nQ: GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?\nA: GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.\nQ: GPT-4.1 시리즈의 가격은 어떻게 되나요?\nA: GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.\nQ: GPT-4.5 Preview는 어떻게 되나요?\nA: GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.\nQ: GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?\nA: 2024년 6월까지의 정보를 담고 있습니다.\n \n \n \n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1은 ChatGPT에서도 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 가격은 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.5 Preview는 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"2024년 6월까지의 정보를 담고 있습니다.\"\n    }\n  }]\n}",
        "guid": "http://muzbox.tistory.com/483569",
        "categories": [
          "AI, 미래기술/AI 챗봇 및 언어 모델",
          "AI 개발",
          "gpt-4.1",
          "gpt-4.1 mini",
          "gpt-4.1 nano",
          "OpenAI",
          "긴 컨텍스트",
          "인공지능",
          "지시 이행",
          "컨텍스트 윈도우",
          "코딩 능력"
        ],
        "isoDate": "2025-04-16T01:06:48.000Z"
      },
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "ChatGPT의 GPT-4o 이미지 생성, DALL-E를 어떻게 뛰어넘었나?",
        "link": "http://muzbox.tistory.com/483568",
        "pubDate": "Tue, 15 Apr 2025 08:42:07 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483568#entry483568comment",
        "content": "<p data-ke-size=\"size16\">&nbsp;ChatGPT의 GPT-4o 이미지 생성 기능의 혁신적인 변화! DALL-E와는 무엇이 다른지, 실제 사용해보니 드러난 장단점과 창작계에 미칠 파장까지. AI 이미지 생성의 새 시대가 열렸다고? 디자이너라면 꼭 알아야 할 모든 것.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"><span data-url=\"https://blog.kakaocdn.net/dn/beQ5vI/btsNhu8ooKq/CucFTaHTYCcozipDc2eF1K/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/beQ5vI/btsNhu8ooKq/CucFTaHTYCcozipDc2eF1K/img.png\"><img src=\"https://blog.kakaocdn.net/dn/beQ5vI/btsNhu8ooKq/CucFTaHTYCcozipDc2eF1K/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbeQ5vI%2FbtsNhu8ooKq%2FCucFTaHTYCcozipDc2eF1K%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"ChatGPT의 GPT-4o 이미지 생성, DALL-E를 어떻게 뛰어넘었나?\" loading=\"lazy\" width=\"1280\" height=\"853\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">요즘 들어 SNS를 보면 지브리풍 일러스트부터 놀라울 정도로 사실적인 사진까지, 모두 ChatGPT로 만들었다는 이미지들이 넘쳐나고 있어요. \"뭐야, ChatGPT도 이제 이미지를 만들어?\" 라고 생각하시는 분들 많으실 텐데요. 네, 맞습니다. 2025년 3월 26일, OpenAI가 GPT-4o를 출시하면서 DALL-E를 대체하는 이미지 생성 기능을 통합했거든요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">저는 디자인 분야에서 일하다 보니 미드저니, 스테이블 디퓨전부터 DALL-E까지 거의 모든 AI 이미지 생성 도구를 업무에 활용해왔는데요. GPT-4o의 이미지 생성 기능을 처음 접했을 때는 정말 놀랐어요. 왜 그랬는지, 그리고 이 변화가 우리에게 어떤 의미인지 함께 알아볼까요?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>DALL-E에서 GPT-4o로, 무엇이 바뀌었나?  </b></span></h2>\n<p data-ke-size=\"size16\">이전까지 ChatGPT에서 이미지를 생성하려면 별도의 DALL-E 모델을 호출해야 했어요. 대화하다가 \"이 설명을 이미지로 만들어줘\"라고 하면 모드 전환이 일어나면서 DALL-E가 작동했죠. 하지만 이제는 GPT-4o 하나로 대화와 이미지 생성이 모두 가능해졌어요.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">주요 변화점  </span></h3>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>통합된 사용자 경험</b> - 대화 흐름 중에 자연스럽게 이미지 생성이 가능해졌어요. 모드 전환 없이 대화하듯 이미지를 요청하면 바로 만들어줍니다.</li>\n<li><b>향상된 응답 속도</b> - DALL-E는 이미지 생성에 10-20초가 걸렸는데, GPT-4o는 대략 절반 정도로 시간이 단축됐어요.</li>\n<li><b>텍스트 렌더링 성능 향상</b> - 이전 DALL-E의 큰 약점 중 하나가 이미지 속 텍스트 처리였는데, GPT-4o는 이 부분이 획기적으로 개선되었어요. 포스터나 책 표지 같은 텍스트가 포함된 이미지 생성이 훨씬 정확해졌답니다.</li>\n<li><b>스타일 일관성</b> - 다양한 예술 스타일을 요청했을 때 일관된 퀄리티를 유지하는 능력이 향상되었어요. 특히 '지브리풍'으로 유명해진 애니메이션 스타일 구현이 뛰어나죠.</li>\n</ol>\n<p data-ke-size=\"size16\">솔직히 말하자면, 순수하게 사진 같은 사실적 이미지만 놓고 보면 기존 DALL-E가 약간 더 나은 경우도 있었어요. 하지만 전반적인 성능과 사용성은 GPT-4o가 훨씬 뛰어납니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>실제 사용해보니 느낀 GPT-4o 이미지 생성의 강점  </b></span></h2>\n<p data-ke-size=\"size16\">실제로 제가 업무에 활용해보니 GPT-4o의 강점이 확실히 드러나더라고요.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">1. 맥락 이해 능력</span></h3>\n<p data-ke-size=\"size16\">제가 가장 놀란 부분은 대화 맥락을 기반으로 이미지를 생성한다는 점이에요. 예를 들어, 로고 디자인에 대해 길게 대화를 나눈 후 \"이걸 이미지로 만들어줘\"라고 하면 이전 대화 내용을 모두 고려한 이미지를 만들어줍니다. DALL-E는 그냥 그 한 문장만 고려했죠.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">2. 디테일 컨트롤</span></h3>\n<p data-ke-size=\"size16\">\"조금 더 밝게\", \"왼쪽 캐릭터의 표정을 더 행복하게\" 같은 세부 수정 요청에 훨씬 더 정확하게 반응해요. 이전에는 비슷한 프롬프트로 처음부터 다시 생성하는 경우가 많았는데, GPT-4o는 원하는 부분만 정확히 수정해주는 경우가 많아요.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">3. 텍스트와 이미지의 완벽한 조화</span></h3>\n<p data-ke-size=\"size16\">포스터나 인포그래픽처럼 텍스트가 포함된 이미지를 만들 때 정말 빛을 발해요. DALL-E에서는 \"Happy Birthday\"라는 간단한 문구조차 \"Ha9py Birtиday\" 같은 이상한 글자로 나오는 경우가 많았는데, GPT-4o는 거의 완벽하게 텍스트를 렌더링합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>아직 아쉬운 점들  </b></span></h2>\n<p data-ke-size=\"size16\">물론 완벽하진 않아요. 제가 실제 사용하면서 느낀 한계점도 있습니다:</p>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>복잡한 구도의 한계</b> - 여러 사람이 특정 동작을 취하고 있는 복잡한 장면을 요청하면 여전히 손이나 발이 이상하게 나오는 경우가 있어요.</li>\n<li><b>해상도 제한</b> - 현재 생성되는 이미지의 해상도가 제한적이라 고품질 인쇄물용으로 사용하기엔 부족해요.</li>\n<li><b>스타일 제한</b> - 특정 작가나 브랜드의 스타일을 정확하게 모방하는 데는 여전히 한계가 있습니다.</li>\n</ol>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>이 변화가 창작 산업에 미칠 영향  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4o의 이미지 생성 기능은 단순한 기술적 발전을 넘어 창작 방식 자체를 바꿀 잠재력이 있어요. 이제 누구나 쉽게 자신의 아이디어를 시각화할 수 있게 되었으니까요.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">디자이너와 일러스트레이터에게는?</span></h3>\n<p data-ke-size=\"size16\">솔직히 말해서, 불안함을 느끼는 디자이너분들 많으실 거예요. 하지만 저는 이걸 위협보다는 도구로 봐야 한다고 생각해요. 디자인 초안을 빠르게 만들거나, 클라이언트와 소통하는 과정에서 아이디어를 시각화하는 데 정말 유용하거든요.</p>\n<p data-ke-size=\"size16\">실제로 저는 로고 디자인 작업할 때 클라이언트에게 다양한 방향성을 빠르게 제시하기 위해 GPT-4o를 활용하고 있어요. 물론 최종 결과물은 직접 다듬지만, 아이디어 발상 과정이 훨씬 효율적으로 바뀌었답니다.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">마케팅과 콘텐츠 제작에는?</span></h3>\n<p data-ke-size=\"size16\">SNS 마케팅이나 블로그 콘텐츠 제작자들에게는 정말 혁명적인 변화에요. 이제 디자이너 없이도 괜찮은 퀄리티의 이미지를 즉석에서 만들 수 있으니까요. 특히 텍스트 렌더링이 개선되어 광고나 프로모션 이미지 제작이 훨씬 쉬워졌어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>GPT-4o 이미지 생성, 어떻게 활용해야 할까?  </b></span></h2>\n<p data-ke-size=\"size16\">제가 실제로 GPT-4o 이미지 생성을 활용하면서 터득한 팁을 몇 가지 공유할게요:</p>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>맥락이 풍부한 프롬프트 작성하기</b> - 단순히 \"고양이 그림\"보다는 \"푸른 하늘 아래 햇살을 받으며 창가에 앉아있는 티베트산 하얀 고양이, 스튜디오 조명, 소니 A7 카메라로 촬영한 느낌\"처럼 구체적으로 설명하세요.</li>\n<li><b>대화 맥락 활용하기</b> - 이미지를 생성하기 전에 원하는 스타일이나 분위기에 대해 충분히 설명하면 더 좋은 결과물을 얻을 수 있어요.</li>\n<li><b>반복 생성으로 완성도 높이기</b> - 첫 결과물에 만족하지 못했다면 \"이 이미지에서 배경을 더 밝게, 인물의 표정을 더 행복하게 수정해줘\"처럼 구체적인 피드백을 주세요.</li>\n<li><b>텍스트 활용하기</b> - GPT-4o는 텍스트 렌더링이 강점이니 포스터, 책 표지, 로고 등 텍스트가 포함된 이미지 생성에 적극 활용해보세요.</li>\n</ol>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blob\" data-origin-width=\"866\" data-origin-height=\"486\"><span data-url=\"https://blog.kakaocdn.net/dn/Hb7rL/btsNlgBaU4F/E9DvsnoyK3BIXSZdfToNnk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/Hb7rL/btsNlgBaU4F/E9DvsnoyK3BIXSZdfToNnk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/Hb7rL/btsNlgBaU4F/E9DvsnoyK3BIXSZdfToNnk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHb7rL%2FbtsNlgBaU4F%2FE9DvsnoyK3BIXSZdfToNnk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"ChatGPT의 GPT-4o 이미지 생성 시대\" loading=\"lazy\" width=\"866\" height=\"486\" data-filename=\"blob\" data-origin-width=\"866\" data-origin-height=\"486\"/></span></figure>\n</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>결론: 창작의 민주화가 시작됐다  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4o의 이미지 생성 기능은 DALL-E를 단순히 대체한 것이 아니라, AI 이미지 생성의 패러다임 자체를 바꾸고 있어요. 기술적으로는 더 정교해졌고, 사용자 경험 측면에서는 훨씬 더 접근성이 높아졌죠.</p>\n<p data-ke-size=\"size16\">물론 전문 디자이너나 사진작가의 창의적 작업을 완전히 대체하진 못하겠지만, 창작의 문턱을 크게 낮췄다는 점은 분명해요. 이제 \"난 그림을 못 그려\"라는 말은 더 이상 변명이 되지 않을지도 모르겠네요.</p>\n<p data-ke-size=\"size16\">여러분도 GPT-4o의 이미지 생성 기능을 사용해보셨나요? 어떤 경험을 하셨는지, 또 어떻게 활용하고 계신지 댓글로 공유해주세요!  </p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\"><b>자주 묻는 질문  </b></span></h2>\n<p data-ke-size=\"size16\"><b>Q: GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?</b></p>\n<p data-ke-size=\"size16\">A: OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4o 이미지 생성은 무료인가요?</b></p>\n<p data-ke-size=\"size16\">A: ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: DALL-E는 이제 완전히 사라진 건가요?</b></p>\n<p data-ke-size=\"size16\">A: 네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 생성된 이미지를 편집할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 생성된 이미지의 해상도는 어떻게 되나요?</b></p>\n<p data-ke-size=\"size16\">A: 현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.</p>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o 이미지 생성은 무료인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"DALL-E는 이제 완전히 사라진 건가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지를 편집할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지의 해상도는 어떻게 되나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.\"\n      }\n    }\n  ]\n}\n</script>",
        "contentSnippet": "ChatGPT의 GPT-4o 이미지 생성 기능의 혁신적인 변화! DALL-E와는 무엇이 다른지, 실제 사용해보니 드러난 장단점과 창작계에 미칠 파장까지. AI 이미지 생성의 새 시대가 열렸다고? 디자이너라면 꼭 알아야 할 모든 것.\n\n\n \n요즘 들어 SNS를 보면 지브리풍 일러스트부터 놀라울 정도로 사실적인 사진까지, 모두 ChatGPT로 만들었다는 이미지들이 넘쳐나고 있어요. \"뭐야, ChatGPT도 이제 이미지를 만들어?\" 라고 생각하시는 분들 많으실 텐데요. 네, 맞습니다. 2025년 3월 26일, OpenAI가 GPT-4o를 출시하면서 DALL-E를 대체하는 이미지 생성 기능을 통합했거든요.\n \n저는 디자인 분야에서 일하다 보니 미드저니, 스테이블 디퓨전부터 DALL-E까지 거의 모든 AI 이미지 생성 도구를 업무에 활용해왔는데요. GPT-4o의 이미지 생성 기능을 처음 접했을 때는 정말 놀랐어요. 왜 그랬는지, 그리고 이 변화가 우리에게 어떤 의미인지 함께 알아볼까요?\n \nDALL-E에서 GPT-4o로, 무엇이 바뀌었나?  \n이전까지 ChatGPT에서 이미지를 생성하려면 별도의 DALL-E 모델을 호출해야 했어요. 대화하다가 \"이 설명을 이미지로 만들어줘\"라고 하면 모드 전환이 일어나면서 DALL-E가 작동했죠. 하지만 이제는 GPT-4o 하나로 대화와 이미지 생성이 모두 가능해졌어요.\n주요 변화점  \n통합된 사용자 경험 - 대화 흐름 중에 자연스럽게 이미지 생성이 가능해졌어요. 모드 전환 없이 대화하듯 이미지를 요청하면 바로 만들어줍니다.\n향상된 응답 속도 - DALL-E는 이미지 생성에 10-20초가 걸렸는데, GPT-4o는 대략 절반 정도로 시간이 단축됐어요.\n텍스트 렌더링 성능 향상 - 이전 DALL-E의 큰 약점 중 하나가 이미지 속 텍스트 처리였는데, GPT-4o는 이 부분이 획기적으로 개선되었어요. 포스터나 책 표지 같은 텍스트가 포함된 이미지 생성이 훨씬 정확해졌답니다.\n스타일 일관성 - 다양한 예술 스타일을 요청했을 때 일관된 퀄리티를 유지하는 능력이 향상되었어요. 특히 '지브리풍'으로 유명해진 애니메이션 스타일 구현이 뛰어나죠.\n솔직히 말하자면, 순수하게 사진 같은 사실적 이미지만 놓고 보면 기존 DALL-E가 약간 더 나은 경우도 있었어요. 하지만 전반적인 성능과 사용성은 GPT-4o가 훨씬 뛰어납니다.\n \n실제 사용해보니 느낀 GPT-4o 이미지 생성의 강점  \n실제로 제가 업무에 활용해보니 GPT-4o의 강점이 확실히 드러나더라고요.\n1. 맥락 이해 능력\n제가 가장 놀란 부분은 대화 맥락을 기반으로 이미지를 생성한다는 점이에요. 예를 들어, 로고 디자인에 대해 길게 대화를 나눈 후 \"이걸 이미지로 만들어줘\"라고 하면 이전 대화 내용을 모두 고려한 이미지를 만들어줍니다. DALL-E는 그냥 그 한 문장만 고려했죠.\n2. 디테일 컨트롤\n\"조금 더 밝게\", \"왼쪽 캐릭터의 표정을 더 행복하게\" 같은 세부 수정 요청에 훨씬 더 정확하게 반응해요. 이전에는 비슷한 프롬프트로 처음부터 다시 생성하는 경우가 많았는데, GPT-4o는 원하는 부분만 정확히 수정해주는 경우가 많아요.\n3. 텍스트와 이미지의 완벽한 조화\n포스터나 인포그래픽처럼 텍스트가 포함된 이미지를 만들 때 정말 빛을 발해요. DALL-E에서는 \"Happy Birthday\"라는 간단한 문구조차 \"Ha9py Birtиday\" 같은 이상한 글자로 나오는 경우가 많았는데, GPT-4o는 거의 완벽하게 텍스트를 렌더링합니다.\n \n아직 아쉬운 점들  \n물론 완벽하진 않아요. 제가 실제 사용하면서 느낀 한계점도 있습니다:\n복잡한 구도의 한계 - 여러 사람이 특정 동작을 취하고 있는 복잡한 장면을 요청하면 여전히 손이나 발이 이상하게 나오는 경우가 있어요.\n해상도 제한 - 현재 생성되는 이미지의 해상도가 제한적이라 고품질 인쇄물용으로 사용하기엔 부족해요.\n스타일 제한 - 특정 작가나 브랜드의 스타일을 정확하게 모방하는 데는 여전히 한계가 있습니다.\n \n이 변화가 창작 산업에 미칠 영향  \nGPT-4o의 이미지 생성 기능은 단순한 기술적 발전을 넘어 창작 방식 자체를 바꿀 잠재력이 있어요. 이제 누구나 쉽게 자신의 아이디어를 시각화할 수 있게 되었으니까요.\n디자이너와 일러스트레이터에게는?\n솔직히 말해서, 불안함을 느끼는 디자이너분들 많으실 거예요. 하지만 저는 이걸 위협보다는 도구로 봐야 한다고 생각해요. 디자인 초안을 빠르게 만들거나, 클라이언트와 소통하는 과정에서 아이디어를 시각화하는 데 정말 유용하거든요.\n실제로 저는 로고 디자인 작업할 때 클라이언트에게 다양한 방향성을 빠르게 제시하기 위해 GPT-4o를 활용하고 있어요. 물론 최종 결과물은 직접 다듬지만, 아이디어 발상 과정이 훨씬 효율적으로 바뀌었답니다.\n마케팅과 콘텐츠 제작에는?\nSNS 마케팅이나 블로그 콘텐츠 제작자들에게는 정말 혁명적인 변화에요. 이제 디자이너 없이도 괜찮은 퀄리티의 이미지를 즉석에서 만들 수 있으니까요. 특히 텍스트 렌더링이 개선되어 광고나 프로모션 이미지 제작이 훨씬 쉬워졌어요.\n \nGPT-4o 이미지 생성, 어떻게 활용해야 할까?  \n제가 실제로 GPT-4o 이미지 생성을 활용하면서 터득한 팁을 몇 가지 공유할게요:\n맥락이 풍부한 프롬프트 작성하기 - 단순히 \"고양이 그림\"보다는 \"푸른 하늘 아래 햇살을 받으며 창가에 앉아있는 티베트산 하얀 고양이, 스튜디오 조명, 소니 A7 카메라로 촬영한 느낌\"처럼 구체적으로 설명하세요.\n대화 맥락 활용하기 - 이미지를 생성하기 전에 원하는 스타일이나 분위기에 대해 충분히 설명하면 더 좋은 결과물을 얻을 수 있어요.\n반복 생성으로 완성도 높이기 - 첫 결과물에 만족하지 못했다면 \"이 이미지에서 배경을 더 밝게, 인물의 표정을 더 행복하게 수정해줘\"처럼 구체적인 피드백을 주세요.\n텍스트 활용하기 - GPT-4o는 텍스트 렌더링이 강점이니 포스터, 책 표지, 로고 등 텍스트가 포함된 이미지 생성에 적극 활용해보세요.\n\n\n결론: 창작의 민주화가 시작됐다  \nGPT-4o의 이미지 생성 기능은 DALL-E를 단순히 대체한 것이 아니라, AI 이미지 생성의 패러다임 자체를 바꾸고 있어요. 기술적으로는 더 정교해졌고, 사용자 경험 측면에서는 훨씬 더 접근성이 높아졌죠.\n물론 전문 디자이너나 사진작가의 창의적 작업을 완전히 대체하진 못하겠지만, 창작의 문턱을 크게 낮췄다는 점은 분명해요. 이제 \"난 그림을 못 그려\"라는 말은 더 이상 변명이 되지 않을지도 모르겠네요.\n여러분도 GPT-4o의 이미지 생성 기능을 사용해보셨나요? 어떤 경험을 하셨는지, 또 어떻게 활용하고 계신지 댓글로 공유해주세요!  \n자주 묻는 질문  \nQ: GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?\nA: OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.\nQ: GPT-4o 이미지 생성은 무료인가요?\nA: ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.\nQ: DALL-E는 이제 완전히 사라진 건가요?\nA: 네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.\nQ: 생성된 이미지를 편집할 수 있나요?\nA: 현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.\nQ: 생성된 이미지의 해상도는 어떻게 되나요?\nA: 현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.\n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o 이미지 생성은 무료인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"DALL-E는 이제 완전히 사라진 건가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지를 편집할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지의 해상도는 어떻게 되나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.\"\n      }\n    }\n  ]\n}",
        "guid": "http://muzbox.tistory.com/483568",
        "categories": [
          "AI, 미래기술/AI 이미지 및 아트 생성",
          "AI 이미지",
          "ai 창작 도구",
          "ai 프롬프트 작성법",
          "chatgpt 그림 기능",
          "dall-e 대체",
          "gpt-4o 이미지 생성",
          "디자인 자동화",
          "이미지 생성 프롬프트",
          "지브리풍 ai",
          "텍스트 렌더링"
        ],
        "isoDate": "2025-04-14T23:42:07.000Z"
      }
    ]
  },
  {
    "name": "동우리의 블로그",
    "category": "개인",
    "posts": []
  },
  {
    "name": "하테나",
    "category": "개인",
    "posts": []
  },
  {
    "name": "늑돌이네 라지온",
    "category": "개인",
    "posts": []
  },
  {
    "name": "루리웹 - 루리웹 리뷰 게시판",
    "category": "게임",
    "posts": []
  },
  {
    "name": "Reasontobe",
    "category": "개인",
    "posts": []
  },
  {
    "name": "자유로운 생활",
    "category": "개인",
    "posts": []
  },
  {
    "name": "에스티마의 인터넷이야기 EstimaStory.com",
    "category": "개인",
    "posts": []
  },
  {
    "name": "나긋한 개발 - 데비안 리눅스와 프로그램 언어",
    "category": "개인",
    "posts": []
  },
  {
    "name": "일상을 여행처럼...",
    "category": "개인",
    "posts": []
  },
  {
    "name": "Just hack'em",
    "category": "개인",
    "posts": []
  },
  {
    "name": "C++ Truths",
    "category": "개인",
    "posts": []
  },
  {
    "name": "jacking75",
    "category": "개인",
    "posts": [
      {
        "title": "Visual Studio의 새로운 생산성 기능",
        "link": "https://jacking75.github.io/VS_20250416/",
        "pubDate": "Wed, 16 Apr 2025 00:00:00 +0900",
        "content": "<iframe width=\"1024\" height=\"1024\" src=\"https://docs.google.com/document/d/e/2PACX-1vTFg-bDiBWKSwkueR7UvfuAMhDRF9h-zLESCpCfJcleZlR4uNBrol_bOGeRN5Q6S7_l0EAozlgEncZG/pub?embedded=true\"></iframe>\n\n",
        "contentSnippet": "",
        "guid": "https://jacking75.github.io/VS_20250416/",
        "isoDate": "2025-04-15T15:00:00.000Z"
      },
      {
        "title": "DeepSeek-R1 로컬 실행 시 추천 모델(증류 모델)",
        "link": "https://jacking75.github.io/ai-llm_20250414/",
        "pubDate": "Mon, 14 Apr 2025 00:00:00 +0900",
        "content": "<iframe width=\"1024\" height=\"1024\" src=\"https://docs.google.com/document/d/e/2PACX-1vSIHfVUr4Phd-5HYiJu2sxaXF_WcjAXP2sgE9NzFk8OvawOBJC53dnCLlJtRj8SNUpmxDuM1seDAa6s/pub?embedded=true\"></iframe>\n\n",
        "contentSnippet": "",
        "guid": "https://jacking75.github.io/ai-llm_20250414/",
        "isoDate": "2025-04-13T15:00:00.000Z"
      }
    ]
  },
  {
    "name": "Joel on Software",
    "category": "개인",
    "posts": []
  },
  {
    "name": "벤자민로그",
    "category": "개인",
    "posts": []
  },
  {
    "name": "악보쓰는 프로그래머",
    "category": "개인",
    "posts": []
  },
  {
    "name": "쭌안아빠",
    "category": "개인",
    "posts": []
  },
  {
    "name": "A Gangster World",
    "category": "개인",
    "posts": []
  },
  {
    "name": "요우의 내맘대로 블로그",
    "category": "개인",
    "posts": []
  },
  {
    "name": "개발자스럽다",
    "category": "큐레이션",
    "posts": []
  },
  {
    "name": "Against All Odds.",
    "category": "개인",
    "posts": []
  },
  {
    "name": "움직이는 게임서버",
    "category": "개인",
    "posts": []
  },
  {
    "name": "이상욱",
    "category": "개인",
    "posts": []
  },
  {
    "name": "임철재",
    "category": "개인",
    "posts": []
  },
  {
    "name": "어쩐지 오늘은",
    "category": "개인",
    "posts": []
  },
  {
    "name": "oddpoet’s étude",
    "category": "개인",
    "posts": []
  },
  {
    "name": "0x00 - NULL",
    "category": "개인",
    "posts": []
  },
  {
    "name": "퇴근 후 서버다운",
    "category": "개인",
    "posts": [
      {
        "creator": "SIDNFT",
        "title": "유니티 베지어 커브 구현 사이트 찾았음",
        "link": "http://serverdown.tistory.com/1276",
        "pubDate": "Sun, 20 Apr 2025 01:08:22 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1276#entry1276comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"813\" data-origin-height=\"351\"><span data-url=\"https://blog.kakaocdn.net/dn/cdtSjT/btsNrp6Vvlm/v06SGcNFljCgm3KB0aoKlK/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cdtSjT/btsNrp6Vvlm/v06SGcNFljCgm3KB0aoKlK/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cdtSjT/btsNrp6Vvlm/v06SGcNFljCgm3KB0aoKlK/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcdtSjT%2FbtsNrp6Vvlm%2Fv06SGcNFljCgm3KB0aoKlK%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"813\" height=\"351\" data-origin-width=\"813\" data-origin-height=\"351\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이걸로 그림 그리면 따라 다니는 그런 게임을 만들 수 있을 것 같습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">소스코드 링크: <a href=\"https://leekangw.github.io/posts/49/\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://leekangw.github.io/posts/49/</a></p>\n<figure id=\"og_1745078837951\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"article\" data-og-title=\"[Unity] 베지어 곡선(Bezier Curves) 구현해보기\" data-og-description=\"게임을 개발하다보면 곡선을 그려야 할 때가 자주 있다.\" data-og-host=\"leekangw.github.io\" data-og-source-url=\"https://leekangw.github.io/posts/49/\" data-og-url=\"https://leekangw.github.io/posts/49/\" data-og-image=\"\"><a href=\"https://leekangw.github.io/posts/49/\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://leekangw.github.io/posts/49/\">\n<div class=\"og-image\" style=\"background-image: url();\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">[Unity] 베지어 곡선(Bezier Curves) 구현해보기</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">게임을 개발하다보면 곡선을 그려야 할 때가 자주 있다.</p>\n<p class=\"og-host\" data-ke-size=\"size16\">leekangw.github.io</p>\n</div>\n</a></figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">데모 영상: <a href=\"https://youtu.be/RzzFah7zOjU\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://youtu.be/RzzFah7zOjU</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=RzzFah7zOjU\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/yTWqK/hyYIcNeweX/KsEwyafA9CakXK6FbQjCv0/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/zxL8i/hyYJCyag14/7fJoKi0pCkYfusLmiQPgPk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"베지어 곡선 테스트\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/RzzFah7zOjU\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "이걸로 그림 그리면 따라 다니는 그런 게임을 만들 수 있을 것 같습니다.\n \n소스코드 링크: https://leekangw.github.io/posts/49/\n\n \n[Unity] 베지어 곡선(Bezier Curves) 구현해보기\n게임을 개발하다보면 곡선을 그려야 할 때가 자주 있다.\nleekangw.github.io\n\n \n데모 영상: https://youtu.be/RzzFah7zOjU",
        "guid": "http://serverdown.tistory.com/1276",
        "categories": [
          "프로그래밍/개발메모"
        ],
        "isoDate": "2025-04-19T16:08:22.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "nhn 에서 제공하는 유니티 도움 패키지",
        "link": "http://serverdown.tistory.com/1275",
        "pubDate": "Fri, 18 Apr 2025 20:07:08 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1275#entry1275comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"251\" data-origin-height=\"159\"><span data-url=\"https://blog.kakaocdn.net/dn/dCH4TC/btsNsbzlNgo/b9JutU9ABEPlDfpGNJpId0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/dCH4TC/btsNsbzlNgo/b9JutU9ABEPlDfpGNJpId0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/dCH4TC/btsNsbzlNgo/b9JutU9ABEPlDfpGNJpId0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdCH4TC%2FbtsNsbzlNgo%2Fb9JutU9ABEPlDfpGNJpId0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"251\" height=\"159\" data-origin-width=\"251\" data-origin-height=\"159\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">게임 만들라고 만든거 같군요 Game 이라고 적혀있네요</p>\n<p data-ke-size=\"size16\">편리하게 쓰라고 좋은기능 많이 만들어둔거 같습니다.</p>\n<p data-ke-size=\"size16\">셰이더도 있구요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://www.youtube.com/watch?v=qstN7DcLTBk\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=qstN7DcLTBk</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=qstN7DcLTBk\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/Gnf3E/hyYFAnDKK2/OaSsO644p5vRW7mxD3Adb0/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/bbrqV8/hyYIaV6GRg/LuajD521oknXb8BPh9HJak/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"[소스공유] 유니티 UI 작업 속도 100배 빨라지는 비기\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/qstN7DcLTBk\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">소스: <a href=\"https://github.com/nhn/gpm.unity\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://github.com/nhn/gpm.unity</a></p>\n<figure id=\"og_1744974377277\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"object\" data-og-title=\"GitHub - nhn/gpm.unity: A brand of NHN providing free services required for game development.\" data-og-description=\"A brand of NHN providing free services required for game development. - nhn/gpm.unity\" data-og-host=\"github.com\" data-og-source-url=\"https://github.com/nhn/gpm.unity\" data-og-url=\"https://github.com/nhn/gpm.unity\" data-og-image=\"https://scrap.kakaocdn.net/dn/G4FWT/hyYIgPyrnP/4lspSFygkbau9AIqKcNze1/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/5zxyy/hyYFFWLnOe/Mis84PtJXqfmhrRGz3gan0/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600\"><a href=\"https://github.com/nhn/gpm.unity\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://github.com/nhn/gpm.unity\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/G4FWT/hyYIgPyrnP/4lspSFygkbau9AIqKcNze1/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/5zxyy/hyYFFWLnOe/Mis84PtJXqfmhrRGz3gan0/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">GitHub - nhn/gpm.unity: A brand of NHN providing free services required for game development.</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">A brand of NHN providing free services required for game development. - nhn/gpm.unity</p>\n<p class=\"og-host\" data-ke-size=\"size16\">github.com</p>\n</div>\n</a></figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">사이즈 같은거 자동으로 ㄱ산해줘서 좋아요</p>",
        "contentSnippet": "게임 만들라고 만든거 같군요 Game 이라고 적혀있네요\n편리하게 쓰라고 좋은기능 많이 만들어둔거 같습니다.\n셰이더도 있구요\n \n영상: https://www.youtube.com/watch?v=qstN7DcLTBk\n\n\n\n \n소스: https://github.com/nhn/gpm.unity\n\n \nGitHub - nhn/gpm.unity: A brand of NHN providing free services required for game development.\nA brand of NHN providing free services required for game development. - nhn/gpm.unity\ngithub.com\n\n \n사이즈 같은거 자동으로 ㄱ산해줘서 좋아요",
        "guid": "http://serverdown.tistory.com/1275",
        "categories": [
          "프로그래밍/유니티 에셋 리뷰",
          "유니티"
        ],
        "isoDate": "2025-04-18T11:07:08.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "유니티 애니메이션 리깅 / 전갈꼬리 문어다리 거미로봇 얼굴시선 처리",
        "link": "http://serverdown.tistory.com/1274",
        "pubDate": "Fri, 18 Apr 2025 15:36:36 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1274#entry1274comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"236\" data-origin-height=\"191\"><span data-url=\"https://blog.kakaocdn.net/dn/bZUQf4/btsNrmubJYE/1KfVkZRFOGWmvQfoCKQpf1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/bZUQf4/btsNrmubJYE/1KfVkZRFOGWmvQfoCKQpf1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/bZUQf4/btsNrmubJYE/1KfVkZRFOGWmvQfoCKQpf1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbZUQf4%2FbtsNrmubJYE%2F1KfVkZRFOGWmvQfoCKQpf1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"236\" height=\"191\" data-origin-width=\"236\" data-origin-height=\"191\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://www.youtube.com/watch?v=aiuwSWYnqrU\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=aiuwSWYnqrU</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=aiuwSWYnqrU\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/bENwrZ/hyYHdGojLG/fRFkkhNIw8qHkkP3oYPqWk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/cxDTig/hyYIexptG3/xPU6AEEfPKANBLRWOUJgLK/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"게임 캐릭터에 생명을 불어넣는 방법 - Procedural Animation\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/aiuwSWYnqrU\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">나중에 써봐야지</p>",
        "contentSnippet": "영상: https://www.youtube.com/watch?v=aiuwSWYnqrU\n\n\n\n나중에 써봐야지",
        "guid": "http://serverdown.tistory.com/1274",
        "categories": [
          "프로그래밍/개발메모"
        ],
        "isoDate": "2025-04-18T06:36:36.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "유니티 애셋 / 살이 출렁이는 연출 /",
        "link": "http://serverdown.tistory.com/1273",
        "pubDate": "Fri, 18 Apr 2025 15:03:36 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1273#entry1273comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"452\" data-origin-height=\"352\"><span data-url=\"https://blog.kakaocdn.net/dn/cZjZeH/btsNrqppzJM/qYYKJyL77j21LgXcc2Istk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cZjZeH/btsNrqppzJM/qYYKJyL77j21LgXcc2Istk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cZjZeH/btsNrqppzJM/qYYKJyL77j21LgXcc2Istk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcZjZeH%2FbtsNrqppzJM%2FqYYKJyL77j21LgXcc2Istk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"452\" height=\"352\" data-origin-width=\"452\" data-origin-height=\"352\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://www.youtube.com/watch?v=VDyPjhugZSM\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=VDyPjhugZSM</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=VDyPjhugZSM\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/f9GRM/hyYIbHrOwm/3ApALqmedikjEP6pd3xSgk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/mEqaa/hyYIhHFeD2/KMiyKj17aQWz3Oz41y1v8K/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"[유니티 ]VertExmotion Pro, Lordenfel 에셋 리뷰 및 사용방법\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/VDyPjhugZSM\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">홍보영상: <a href=\"https://www.youtube.com/watch?v=_mSPXq_2saU\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=_mSPXq_2saU</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=_mSPXq_2saU\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/crUTib/hyYH4VR0kf/IoeKWdXjNjV1ERpQYMqr8k/img.jpg?width=1280&amp;height=720&amp;face=200_210_968_276,https://scrap.kakaocdn.net/dn/B2EvF/hyYIhnmAMJ/OtyS7yYyDE45zVmxSV1WW0/img.jpg?width=1280&amp;height=720&amp;face=200_210_968_276\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"Unity Asset Store Pack - VertExmotion Pro\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/_mSPXq_2saU\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">보잉 같은건가 싶기도 하고 ...</p>\n<p data-ke-size=\"size16\">아무튼 출렁임</p>",
        "contentSnippet": "영상: https://www.youtube.com/watch?v=VDyPjhugZSM\n\n\n\n \n \n홍보영상: https://www.youtube.com/watch?v=_mSPXq_2saU\n\n\n\n \n보잉 같은건가 싶기도 하고 ...\n아무튼 출렁임",
        "guid": "http://serverdown.tistory.com/1273",
        "categories": [
          "프로그래밍/유니티 에셋 리뷰"
        ],
        "isoDate": "2025-04-18T06:03:36.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "유니티 애니메이션 다운로드 및 관리 방방법 영상",
        "link": "http://serverdown.tistory.com/1272",
        "pubDate": "Fri, 18 Apr 2025 12:41:19 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1272#entry1272comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"180\" data-origin-height=\"168\"><span data-url=\"https://blog.kakaocdn.net/dn/drLRjD/btsNoZTtrgy/Ll1vPPJfDE3XfDI37Wifk0/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/drLRjD/btsNoZTtrgy/Ll1vPPJfDE3XfDI37Wifk0/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/drLRjD/btsNoZTtrgy/Ll1vPPJfDE3XfDI37Wifk0/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdrLRjD%2FbtsNoZTtrgy%2FLl1vPPJfDE3XfDI37Wifk0%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"180\" height=\"168\" data-origin-width=\"180\" data-origin-height=\"168\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">영상 1: <a href=\"https://www.youtube.com/watch?v=oFBGs4_jJ0Y\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=oFBGs4_jJ0Y</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=oFBGs4_jJ0Y\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/fEoYw/hyYIfb0brf/8I4YWM0W0wobjlG49MC0wk/img.jpg?width=1280&amp;height=720&amp;face=612_262_708_366,https://scrap.kakaocdn.net/dn/ceaU7g/hyYHgJQtVU/cXXUu7qTsspVmsv1UA2tf1/img.jpg?width=1280&amp;height=720&amp;face=612_262_708_366\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"고퀄리티 3D 모델 구하는 방법과 리깅 없이 애니메이션 넣기\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/oFBGs4_jJ0Y\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">영상 2: <a href=\"https://www.youtube.com/watch?v=5WyebyiOayk\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=5WyebyiOayk</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=5WyebyiOayk\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/cqcAPd/hyYH8Yfq0m/8HbfgMeFNGGga1B0FrYT30/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/bRRn9d/hyYFywxYCe/ivrsahKg6H5hppoxkhvav0/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"체력에 따라 애니메이션이 달라지는 방법\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/5WyebyiOayk\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">이 영상에 잘 나와있네요</p>\n<p data-ke-size=\"size16\">리소스 다운로드 방법</p>\n<p data-ke-size=\"size16\">휴머노이드로 전환</p>\n<p data-ke-size=\"size16\">애니메이션만 따로 빼서 저장</p>\n<p data-ke-size=\"size16\">등등이 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "영상 1: https://www.youtube.com/watch?v=oFBGs4_jJ0Y\n\n\n\n \n \n영상 2: https://www.youtube.com/watch?v=5WyebyiOayk\n\n\n\n이 영상에 잘 나와있네요\n리소스 다운로드 방법\n휴머노이드로 전환\n애니메이션만 따로 빼서 저장\n등등이 있습니다.",
        "guid": "http://serverdown.tistory.com/1272",
        "categories": [
          "프로그래밍/개발메모"
        ],
        "isoDate": "2025-04-18T03:41:19.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "목소리 좋은 게임 유튜버 발굴 / 긴옥희",
        "link": "http://serverdown.tistory.com/1271",
        "pubDate": "Fri, 18 Apr 2025 12:17:28 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1271#entry1271comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"441\" data-origin-height=\"253\"><span data-url=\"https://blog.kakaocdn.net/dn/n3hED/btsNl9QA3sR/LPRHlteo2KIa30hapgKkFK/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/n3hED/btsNl9QA3sR/LPRHlteo2KIa30hapgKkFK/img.png\"><img src=\"https://blog.kakaocdn.net/dn/n3hED/btsNl9QA3sR/LPRHlteo2KIa30hapgKkFK/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fn3hED%2FbtsNl9QA3sR%2FLPRHlteo2KIa30hapgKkFK%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"441\" height=\"253\" data-origin-width=\"441\" data-origin-height=\"253\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">마성은 아니고 귀여운 목소리로 사람들을 구독시키고 있는 채널을 찾았습니다.</p>\n<p data-ke-size=\"size16\">AI 로 만든거면 충격적이겠군요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">채널: <a href=\"https://www.youtube.com/@932-\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/@932-</a></p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://www.youtube.com/watch?v=nOKwht881UI\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=nOKwht881UI</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=nOKwht881UI\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/dDkQJH/hyYHhaTVlp/V9RHRcH3puXQsCok78MGn0/img.jpg?width=1280&amp;height=720&amp;face=710_116_762_174,https://scrap.kakaocdn.net/dn/i5sJY/hyYHapijQ8/K1BKJmICNh6GLo0ImhHf2K/img.jpg?width=1280&amp;height=720&amp;face=710_116_762_174\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"신작 좀비 아포칼립스 생존게임 | 인투 더 데드\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/nOKwht881UI\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">옹알옹알하는댓글에 목소리 좋다 고나리군요</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"548\" data-origin-height=\"473\"><span data-url=\"https://blog.kakaocdn.net/dn/biki5g/btsNlBsWMA4/XYKDSC02htVjQUN2bngXf0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/biki5g/btsNlBsWMA4/XYKDSC02htVjQUN2bngXf0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/biki5g/btsNlBsWMA4/XYKDSC02htVjQUN2bngXf0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbiki5g%2FbtsNlBsWMA4%2FXYKDSC02htVjQUN2bngXf0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"548\" height=\"473\" data-origin-width=\"548\" data-origin-height=\"473\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">중단만 안한다면</p>\n<p data-ke-size=\"size16\">크게될 채널 같아서 가져왓습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "마성은 아니고 귀여운 목소리로 사람들을 구독시키고 있는 채널을 찾았습니다.\nAI 로 만든거면 충격적이겠군요\n \n채널: https://www.youtube.com/@932-\n영상: https://www.youtube.com/watch?v=nOKwht881UI\n\n\n\n \n옹알옹알하는댓글에 목소리 좋다 고나리군요\n\n\n중단만 안한다면\n크게될 채널 같아서 가져왓습니다.",
        "guid": "http://serverdown.tistory.com/1271",
        "categories": [
          "유튜브",
          "긴옥희"
        ],
        "isoDate": "2025-04-18T03:17:28.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "게임 광고 300만원 태운 개발자 스토리 / 바코 BACO",
        "link": "http://serverdown.tistory.com/1270",
        "pubDate": "Thu, 17 Apr 2025 16:20:25 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1270#entry1270comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"225\" data-origin-height=\"225\"><span data-url=\"https://blog.kakaocdn.net/dn/mJi32/btsNpo6VAcy/qTS1Wp0WcYIkA7Wd2uHXK0/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/mJi32/btsNpo6VAcy/qTS1Wp0WcYIkA7Wd2uHXK0/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/mJi32/btsNpo6VAcy/qTS1Wp0WcYIkA7Wd2uHXK0/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmJi32%2FbtsNpo6VAcy%2FqTS1Wp0WcYIkA7Wd2uHXK0%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"225\" height=\"225\" data-origin-width=\"225\" data-origin-height=\"225\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://www.youtube.com/watch?v=oIWW0aJHGaQ\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=oIWW0aJHGaQ</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=oIWW0aJHGaQ\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/TELyx/hyYIj6ssHh/3v0pJlEFsmmE0zv2glzsMk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/b9Sx1o/hyYIahnjdc/rOe2vMITtAWZ3HHMDuNLr1/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"게임 앱 만들어서 300만원 광고해보기 [EP 25]\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/oIWW0aJHGaQ\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">제 이야기는 아니고 영상 이야기</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">중요한것은&nbsp;</p>\n<p data-ke-size=\"size16\">광고를 태워야해서 홍보페이지를 만들어야합니다.</p>\n<p data-ke-size=\"size16\">미리미리 영상을 잘 준비해둬야한다는 뜻입니다.</p>\n<p data-ke-size=\"size16\">광고를 하든 안하든 멋진 연출이이 나오도록 만들어야겠습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "영상: https://www.youtube.com/watch?v=oIWW0aJHGaQ\n\n\n\n \n제 이야기는 아니고 영상 이야기\n \n중요한것은 \n광고를 태워야해서 홍보페이지를 만들어야합니다.\n미리미리 영상을 잘 준비해둬야한다는 뜻입니다.\n광고를 하든 안하든 멋진 연출이이 나오도록 만들어야겠습니다.",
        "guid": "http://serverdown.tistory.com/1270",
        "categories": [
          "프로그래밍/개발메모"
        ],
        "isoDate": "2025-04-17T07:20:25.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "Brick Away / 블록분해 v1 게임 제작 시작",
        "link": "http://serverdown.tistory.com/1269",
        "pubDate": "Thu, 17 Apr 2025 15:45:56 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1269#entry1269comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"512\" data-origin-height=\"512\"><span data-url=\"https://blog.kakaocdn.net/dn/cWhjbX/btsNmHeIczZ/Qgw6luFF7rBmHwsQeiHkt0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cWhjbX/btsNmHeIczZ/Qgw6luFF7rBmHwsQeiHkt0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cWhjbX/btsNmHeIczZ/Qgw6luFF7rBmHwsQeiHkt0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcWhjbX%2FbtsNmHeIczZ%2FQgw6luFF7rBmHwsQeiHkt0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"512\" height=\"512\" data-origin-width=\"512\" data-origin-height=\"512\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">갑자기 만들고 싶어졌습니다.</p>\n<p data-ke-size=\"size16\">기존에 Tap Away 가 그래픽이 밝아서 제 눈이 아파서 불편사항을 고쳐보려고</p>\n<p data-ke-size=\"size16\">만들기 시작했습니다.</p>\n<p data-ke-size=\"size16\">여기까지 만드는데 4시간 정도 걸린거 같군요</p>\n<p data-ke-size=\"size16\">시간 잘 가네</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://www.youtube.com/watch?v=KgW9pFfxSJA\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=KgW9pFfxSJA</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=KgW9pFfxSJA\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/cbNrBD/hyYIfXhRaw/HQk5SBDC7ZkrCpriDdIQI1/img.jpg?width=480&amp;height=360&amp;face=0_0_480_360,https://scrap.kakaocdn.net/dn/szEpP/hyYFx5oAUC/OyYIyKwsMB0VGeifTLgii0/img.jpg?width=480&amp;height=360&amp;face=0_0_480_360\" data-video-width=\"480\" data-video-height=\"360\" data-video-origin-width=\"480\" data-video-origin-height=\"360\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"brick away v1\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/KgW9pFfxSJA\" width=\"480\" height=\"360\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">별로 만들어진게 없습니다.&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">플레이:&nbsp; <a href=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1</a></p>\n<figure id=\"og_1744871969875\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"Brick Away V1 on Unity Play\" data-og-description=\"touch brick\" data-og-host=\"play.unity.com\" data-og-source-url=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\" data-og-url=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\" data-og-image=\"https://scrap.kakaocdn.net/dn/eD9g4/hyYIb8qipm/3KwknF0cKVuaIWfUfkkkaK/img.png?width=512&amp;height=512&amp;face=0_0_512_512,https://scrap.kakaocdn.net/dn/c3QxpG/hyYFFWDwEX/2dVkEIJKybPWSv8IPaaGK1/img.png?width=512&amp;height=512&amp;face=0_0_512_512\"><a href=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/eD9g4/hyYIb8qipm/3KwknF0cKVuaIWfUfkkkaK/img.png?width=512&amp;height=512&amp;face=0_0_512_512,https://scrap.kakaocdn.net/dn/c3QxpG/hyYFFWDwEX/2dVkEIJKybPWSv8IPaaGK1/img.png?width=512&amp;height=512&amp;face=0_0_512_512');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">Brick Away V1 on Unity Play</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">touch brick</p>\n<p class=\"og-host\" data-ke-size=\"size16\">play.unity.com</p>\n</div>\n</a></figure>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "갑자기 만들고 싶어졌습니다.\n기존에 Tap Away 가 그래픽이 밝아서 제 눈이 아파서 불편사항을 고쳐보려고\n만들기 시작했습니다.\n여기까지 만드는데 4시간 정도 걸린거 같군요\n시간 잘 가네\n \n영상: https://www.youtube.com/watch?v=KgW9pFfxSJA\n\n\n\n별로 만들어진게 없습니다. \n \n플레이:  https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\n\n \nBrick Away V1 on Unity Play\ntouch brick\nplay.unity.com",
        "guid": "http://serverdown.tistory.com/1269",
        "categories": [
          "블록 분해 게임 (자작)"
        ],
        "isoDate": "2025-04-17T06:45:56.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "Unbeatable Network / 갓챠맨 크라우즈 Gatchaman Crowds / 애니 음악 / OST",
        "link": "http://serverdown.tistory.com/1268",
        "pubDate": "Thu, 17 Apr 2025 14:56:49 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1268#entry1268comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"686\" data-origin-height=\"386\"><span data-url=\"https://blog.kakaocdn.net/dn/uyG8r/btsNpq4wnMF/Ngd0L7D3L3RUNYhZYcR6oK/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/uyG8r/btsNpq4wnMF/Ngd0L7D3L3RUNYhZYcR6oK/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/uyG8r/btsNpq4wnMF/Ngd0L7D3L3RUNYhZYcR6oK/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuyG8r%2FbtsNpq4wnMF%2FNgd0L7D3L3RUNYhZYcR6oK%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"686\" height=\"386\" data-origin-width=\"686\" data-origin-height=\"386\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">와 지금보니 11년 전 곡이군요</p>\n<p data-ke-size=\"size16\">갓챠맨 크라우즈 애니에 들어간 브금이라고 하는데</p>\n<p data-ke-size=\"size16\">당시엔 눈에 들어오지도 않던 애니이고 진행도&nbsp; 내용도 좀 이상한 애니였습니다.</p>\n<p data-ke-size=\"size16\">가차맨 붙으면 보통 독수리 오형제 가 나왔는데</p>\n<p data-ke-size=\"size16\">좀 다른 컨셉으로 나왔습니다.</p>\n<p data-ke-size=\"size16\">외게인이 나오고 신비한 힘으로 그걸 막는 사람들이 5명 나오나 그랬던거 같습니다.</p>\n<p data-ke-size=\"size16\">능력도 내용도 이해도 안되었던건 기억이 나고</p>\n<p data-ke-size=\"size16\">비주얼 퀄리티가 놓았습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">비슷한 시기에 취성의 가르간티아도 나왔는데</p>\n<p data-ke-size=\"size16\">그것은 매우 추천하는 작품입니다. 모든면에서 뛰어났었죠</p>\n<p data-ke-size=\"size16\">당시에 어떤 경쟁장 때문에 묻혔던거 같은데 그게 무었인지 기억에 없네요 뭔가 역사적인게 같이 나왔던거 같은데 ...</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">아래는 <span style=\"text-align: start;\">갓챠맨 크라우즈 애니에서 유일하게 건진 브금인데 좋습니다.</span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">표지가 사람 머리였군요 멀리서보니 파도 치는 바다 금인가 했는데</span></p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">원본 영상: <a href=\"https://www.youtube.com/watch?v=Z-vtOKppCjc\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=Z-vtOKppCjc</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=Z-vtOKppCjc\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/3kLJJ/hyYIizHBuU/mhd3ABoR3P6GNzaTuwaf2k/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/bpkFV1/hyYH8jyu8n/0E4hL6FpKJKu5QNQ0II0bk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"Gatchaman Crowds OST (Full) - 20 Unbeatable Network\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/Z-vtOKppCjc\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">피아노 영상: <a href=\"https://www.youtube.com/watch?v=YmTgA-QZk1k\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=YmTgA-QZk1k</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=YmTgA-QZk1k\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/8epQ7/hyYIkddtd1/IVCY9SQ8GAyz8cpQ9ItjCk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/d1DHNU/hyYG67RppG/Aa4AMCOVikEduMzYIf7KyK/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"Unbeatable Network - Gatchaman Crowds OST [Piano]\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/YmTgA-QZk1k\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "와 지금보니 11년 전 곡이군요\n갓챠맨 크라우즈 애니에 들어간 브금이라고 하는데\n당시엔 눈에 들어오지도 않던 애니이고 진행도  내용도 좀 이상한 애니였습니다.\n가차맨 붙으면 보통 독수리 오형제 가 나왔는데\n좀 다른 컨셉으로 나왔습니다.\n외게인이 나오고 신비한 힘으로 그걸 막는 사람들이 5명 나오나 그랬던거 같습니다.\n능력도 내용도 이해도 안되었던건 기억이 나고\n비주얼 퀄리티가 놓았습니다.\n \n비슷한 시기에 취성의 가르간티아도 나왔는데\n그것은 매우 추천하는 작품입니다. 모든면에서 뛰어났었죠\n당시에 어떤 경쟁장 때문에 묻혔던거 같은데 그게 무었인지 기억에 없네요 뭔가 역사적인게 같이 나왔던거 같은데 ...\n \n아래는 갓챠맨 크라우즈 애니에서 유일하게 건진 브금인데 좋습니다.\n표지가 사람 머리였군요 멀리서보니 파도 치는 바다 금인가 했는데\n \n원본 영상: https://www.youtube.com/watch?v=Z-vtOKppCjc\n\n\n\n \n \n피아노 영상: https://www.youtube.com/watch?v=YmTgA-QZk1k",
        "guid": "http://serverdown.tistory.com/1268",
        "categories": [
          "유튜브"
        ],
        "isoDate": "2025-04-17T05:56:49.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "기동전사 건담 지쿠악스 나왔군요 / 애니",
        "link": "http://serverdown.tistory.com/1267",
        "pubDate": "Thu, 17 Apr 2025 14:00:37 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1267#entry1267comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"200\" data-origin-height=\"282\"><span data-url=\"https://blog.kakaocdn.net/dn/wfFSI/btsNldZBaTS/wt9QtV5xs3g6GEW1RTiZN1/img.webp\" data-phocus=\"https://blog.kakaocdn.net/dn/wfFSI/btsNldZBaTS/wt9QtV5xs3g6GEW1RTiZN1/img.webp\"><img src=\"https://blog.kakaocdn.net/dn/wfFSI/btsNldZBaTS/wt9QtV5xs3g6GEW1RTiZN1/img.webp\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FwfFSI%2FbtsNldZBaTS%2Fwt9QtV5xs3g6GEW1RTiZN1%2Fimg.webp\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"200\" height=\"282\" data-origin-width=\"200\" data-origin-height=\"282\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"1184\" data-origin-height=\"421\"><span data-url=\"https://blog.kakaocdn.net/dn/cu4Yqs/btsNo6yqzhS/4mnAGQ1aR8fvgIk4JvsYj1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cu4Yqs/btsNo6yqzhS/4mnAGQ1aR8fvgIk4JvsYj1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cu4Yqs/btsNo6yqzhS/4mnAGQ1aR8fvgIk4JvsYj1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcu4Yqs%2FbtsNo6yqzhS%2F4mnAGQ1aR8fvgIk4JvsYj1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"1184\" height=\"421\" data-origin-width=\"1184\" data-origin-height=\"421\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">나왔군요 티비판</p>\n<p data-ke-size=\"size16\">이거 이름을 어떻게 쓰는지가 궁금했는데</p>\n<p data-ke-size=\"size16\">지쿠악스 군요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">건담이긴한데 에반게리온으로 유명한 안노히데아키 가 참여했고</p>\n<p data-ke-size=\"size16\">감독은 다른 사람입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">안노는 워낙 유명하지만 이분이 확장에 강하지만 마무리가 안되는 문제가 있다고 합니다.</p>\n<p data-ke-size=\"size16\">감독은 그 일을 마무리할 사람으로 보이구요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">츠루마키 카즈야 : <a href=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC</a></p>\n<figure id=\"og_1744865987716\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"article\" data-og-title=\"츠루마키 카즈야\" data-og-description=\"일본 애니메이션 감독 겸 애니메이터 이자 기업인 . 現 스튜디오 카라 의 이사직을 맡고 있다. 애칭은 맛\" data-og-host=\"namu.wiki\" data-og-source-url=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\" data-og-url=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\" data-og-image=\"https://scrap.kakaocdn.net/dn/badVUW/hyYG1yJJ9i/SbVkbi0mUFyQsRBj6OlZk0/img.jpg?width=260&amp;height=390&amp;face=63_116_179_243\"><a href=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/badVUW/hyYG1yJJ9i/SbVkbi0mUFyQsRBj6OlZk0/img.jpg?width=260&amp;height=390&amp;face=63_116_179_243');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">츠루마키 카즈야</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">일본 애니메이션 감독 겸 애니메이터 이자 기업인 . 現 스튜디오 카라 의 이사직을 맡고 있다. 애칭은 맛</p>\n<p class=\"og-host\" data-ke-size=\"size16\">namu.wiki</p>\n</div>\n</a></figure>\n<p data-ke-size=\"size16\">역사에 남을 사람이니 미리 기억해 둡시다.</p>\n<p data-ke-size=\"size16\">아직은 이름이 잘 알려지진 않은거 같군요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "나왔군요 티비판\n이거 이름을 어떻게 쓰는지가 궁금했는데\n지쿠악스 군요\n \n건담이긴한데 에반게리온으로 유명한 안노히데아키 가 참여했고\n감독은 다른 사람입니다.\n \n안노는 워낙 유명하지만 이분이 확장에 강하지만 마무리가 안되는 문제가 있다고 합니다.\n감독은 그 일을 마무리할 사람으로 보이구요\n \n츠루마키 카즈야 : https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\n\n \n츠루마키 카즈야\n일본 애니메이션 감독 겸 애니메이터 이자 기업인 . 現 스튜디오 카라 의 이사직을 맡고 있다. 애칭은 맛\nnamu.wiki\n\n역사에 남을 사람이니 미리 기억해 둡시다.\n아직은 이름이 잘 알려지진 않은거 같군요",
        "guid": "http://serverdown.tistory.com/1267",
        "categories": [
          "유튜브",
          "건담",
          "애니"
        ],
        "isoDate": "2025-04-17T05:00:37.000Z"
      }
    ]
  },
  {
    "name": "coolspeed",
    "category": "개인",
    "posts": []
  },
  {
    "name": "오늘도 끄적끄적",
    "category": "개인",
    "posts": []
  },
  {
    "name": "dx11 Vanica's Lifelog - 夢が夢で終わらないように",
    "category": "개인",
    "posts": []
  },
  {
    "name": "초코사랑",
    "category": "개인",
    "posts": []
  },
  {
    "name": "ZeroCho Blog",
    "category": "개인",
    "posts": []
  },
  {
    "name": "imays게임엔진개발자",
    "category": "개인",
    "posts": []
  },
  {
    "name": "RSS feed for hurinmon Blog",
    "category": "개인",
    "posts": []
  },
  {
    "name": "기억보단 기록을",
    "category": "개인",
    "posts": [
      {
        "creator": "향로 (기억보단 기록을)",
        "title": "Vlad Mihalcea와의 인연",
        "link": "http://jojoldu.tistory.com/825",
        "pubDate": "Thu, 17 Apr 2025 11:23:28 +0900",
        "author": "향로 (기억보단 기록을)",
        "comments": "http://jojoldu.tistory.com/825#entry825comment",
        "content": "<blockquote data-ke-style=\"style1\">\n<p data-ke-size=\"size16\">유튜브나 블로그를 하다 보면 예상치 못한 인연들이 생긴다.<br />지금까지 10년 가까운 시간을 블로그를 하면서 큰 동력이 된 사건이기도 하다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">운이 좋게도 2014년부터 다녔던 회사는 Hibernate를 사용하는 회사였고, 그 당시 iBatis, MyBatis를 쓰는 것이 당연한 상황에서 Hibernate를 실무에서 사용해볼 수 있었다.<br />다만, 처음 사용해보는 기술이니 이걸 더 잘 쓰기 위해서 공부를 하고 싶은데 공부할 수 있는 컨텐츠가 없었다.<br />한국어로 된 컨텐츠의 대부분은 iBatis, MyBatis였기 때문이다.</p>\n<p data-ke-size=\"size16\">다행히 기선님이 번역해주신 <a href=\"https://product.kyobobook.co.kr/detail/S000001514367\">개빈 킹의 하이버네이트 완벽가이드</a>가 있었지만 나 같은 초보 개발자에겐 너무나 어렵게 느껴져 한줄 한줄 밑줄 그어가며 이해하려고 노력했다.<br /><a href=\"https://www.slideshare.net/slideshow/devon-2012-b4-orm/14729452\">영한님의 Java ORM에 대한 DevOn 발표 자료</a>도 발견하게 되고 이후엔 <a href=\"https://product.kyobobook.co.kr/detail/S000000935744\">영한님의 책</a> 까지 보면서 Java ORM에 대해 훨씬 쉽게 다가갈 수 있었고 실무를 하는데 있어서 충분히 많은 지식을 쌓을 수 있었다.</p>\n<p data-ke-size=\"size16\">이후에도 계속 JPA, Hibernate를 실무에서 계속 사용할 수 있었는데, 구글링 할때마다 항상 만나는 블로그와 스택오버플로우의 답변 유저가 있었다.<br />그게 바로 <a href=\"https://vladmihalcea.com/\">Vlad Mihalcea</a>였다.</p>\n<blockquote data-ke-style=\"style2\">\n<p data-ke-size=\"size16\">나중에 알고 보니 그는 <a href=\"https://blogs.oracle.com/java/post/new-java-champions-in-2017\">자바 챔피언</a>이자 <a href=\"https://github.com/hibernate/hibernate-orm/graphs/contributors\">Hibernate Top Committer</a> 였다는 것에 \"역시...\" 라는 생각을 했다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">당시에는 \"와 역시 해외는 어마어마한 개발자들이 많구나. 영어 공부 진짜 열심히 해야겠다\" 라는 생각을 하면서 열심히 그의 글을 탐닉했다.<br />새로운 글이 올라오면 항상 챙겨보고 그게 진짜 맞는지 성능 테스트를 진행해보고 효과를 확인 한뒤에는 회사에 적용하는 등 그의 지식을 어떻게든 내 것으로 다 흡수하고 싶었다.<br />그의 책 <a href=\"https://www.amazon.com/High-Performance-Java-Persistence-Vlad-Mihalcea/dp/973022823X\">High-Performance Java Persistence</a>는 사무실 책상 위에 항상 펼쳐져 있었다.</p>\n<p data-ke-size=\"size16\">그렇게 몇년의 경력이 쌓이던 중,<br />2018년 갑자기 블로그의 트래픽이 폭발적으로 늘어나는 일이 있었다.</p>\n<p data-ke-size=\"size16\">어디서 이렇게 유입된 건지 찾아보다가 <a href=\"https://in.relation.to/2018/05/25/hibernate-community-newsletter-2018-10/\">Hibernate 공식 커뮤니티 뉴스레터 2018년 10호</a>에서 내가 작성한 <a href=\"https://jojoldu.tistory.com/295\">\"Spring Boot Data JPA 2.0 에서 id Auto_increment 문제 해결\"</a>을 소개한 것을 발견했다.<br /><b>전세계 Java 개발자들이 구독하고 있는 Hibernate 뉴스레터에서 언급된 것</b>이다.<br />그 뉴스레터는 내가 매일 방문하던 Vlad Mihalcea가 작성한 것이기에 믿기지 않는 순간이였다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blog.png\" data-origin-width=\"712\" data-origin-height=\"810\"><span data-url=\"https://blog.kakaocdn.net/dn/SE2FP/btsNnL9SEW3/r52BG4bmdXPwgFYZJk7iM0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/SE2FP/btsNnL9SEW3/r52BG4bmdXPwgFYZJk7iM0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/SE2FP/btsNnL9SEW3/r52BG4bmdXPwgFYZJk7iM0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSE2FP%2FbtsNnL9SEW3%2Fr52BG4bmdXPwgFYZJk7iM0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"712\" height=\"810\" data-filename=\"blog.png\" data-origin-width=\"712\" data-origin-height=\"810\"/></span></figure>\n</p>\n<blockquote data-ke-style=\"style2\">\n<p data-ke-size=\"size16\">이때의 기억이 강렬해서 \"와 블로그 진짜 오래오래 해야겠다\" 라는 다짐을 했었다.<br />그리고 10년 넘게 블로그를 운영하게 되었다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">그 날 이후로는 기술적인 글 외에도, Vlad Mihalcea 라는 개발자에 대해서도 관심을 가지기 시작했다.<br />그의 기술적인 노하우 뿐만 아니라,<br />'이 사람은 도대체 어떤 커리어를 밟아왔을까?'<br />'어떻게 자바 챔피언이 되었을까?'<br />'어떻게 이렇게 한 분야에서 세계적인 전문가가 되었을까?' 등등.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li><a href=\"https://vladmihalcea.com/how-to-become-a-java-champion/\">How to become a Java Champion</a></li>\n</ul>\n<p data-ke-size=\"size16\">책 외에 또 배울 수 있는 것들이 없을까 싶어 <a href=\"https://vladmihalceastore.teachable.com/\">그의 온라인 스토어</a>에서 판매하는 온라인 강의들도 찾아서 들었다.<br />Java Persistence 에서의 성능 개선 노하우나 Java 환경에서의 SQL 성능 개선 등 <b>자바 개발자 뿐만 아니라 ORM을 사용하는 개발자로서 필요한 대부분의 성능 개선 노하우</b>를 얻을 수 있었다.</p>\n<p data-ke-size=\"size16\">ORM과 SQL 양 쪽에 맞는 가장 적절한 성능 튜닝 사례들을 배울 수 있었고, 이때 배운 지식들은 수십억건의 데이터들 사이에서도 복잡한 도메인들을 처리하는데 큰 힘이 되었다.</p>\n<p data-ke-size=\"size16\">다만, 강의를 수강하는게 수월하지는 않았다.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li>영어로만 강의가 제공되어서 하나의 강의를 수강하는데 하나하나를 번역해서 보는데 너무 많은 힘이 들었고</li>\n<li>결제 오류가 빈번해서 결제하기가 쉽지 않았고</li>\n<li>강의를 수강하는데 있어서의 편의 기능이 많이 부족했다. (모바일 플레이어, 자막 등등)</li>\n</ul>\n<p data-ke-size=\"size16\">그래도 좋았다.<br />이것마저 없으면 그의 양질의 컨텐츠를 볼 수 있는 방법이 없는데, 이렇게라도 볼 수 있으니 말이다.</p>\n<p data-ke-size=\"size16\">이렇게 쌓인 노하우는 이후에 전 직장 첫번째 컨퍼런스에서 아낌없이 쏟아낼 수 있었다.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li><a href=\"https://www.youtube.com/watch?v=zMAX7g6rO_Y\">[우아콘2020] 수십억건에서 QUERYDSL 사용하기</a></li>\n</ul>\n<p data-ke-size=\"size16\">이 세션은 <a href=\"https://www.youtube.com/watch?v=BnS6343GTkY\">(갓)영한님의 세션</a> 다음으로 가장 높은 조회수가 나와서 많은 개발자분들이 좋아해주셨다.<br />그동안의 공부와 경험이 전혀 잘못되지 않았다는 것을 느끼게 해주었다.</p>\n<p data-ke-size=\"size16\">이런 경험으로 성장을 해왔기에,<br /><b>현재 회사로 이직하고 나서 우리팀 백엔드 개발자분들에게 Vlad의 강의를 너무 소개해주고 싶었다</b>.<br />꼭 JPA 뿐만 아니라 모든 ORM과 SQL을 사용하는 개발자들에게 필수적인 내용을 담고 있기 때문이다.<br />우리 같이 Node.js가 주력인 개발팀에는 언어나 프레임워크에 상관없이 이런 강의가 대단히 필요하다.</p>\n<p data-ke-size=\"size16\">하지만, 위에서 언급한 \"언어의 장벽이나 결제, 학습 편의성\" 등을 생각하니 \"<b>우리 팀 분들에게도 나처럼 힘들게 공부하시라</b>\" 라고 이야기하기 어려웠다.</p>\n<p data-ke-size=\"size16\">어떻게든 우리팀에 이 지식들을 가장 편하게 전달하고 싶었다.<br />어떡하는게 좋을까....?</p>\n<hr data-ke-style=\"style1\" />\n<p data-ke-size=\"size16\">그래서 Vlad Mihalcea에게 연락을 드렸다.<br /><b>당신의 강의를 한국어로, 일본어로, 베트남어로 듣고 싶다고</b>.<br />Vlad는 너무나 쿨하게, 너무나 멋지게 이 협업을 받아들여 주셨다.</p>\n<p data-ke-size=\"size16\">그리고 드디어!<br /><b>Vlad Mihalcea의 공식 강의 2개가 인프런에 오픈</b>되었다.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li>  <a href=\"https://inf.run/5bS4d\">High-Performance Java Persistence</a></li>\n<li>  <a href=\"https://inf.run/A24MX\">High-Performance SQL</a></li>\n</ul>\n<blockquote data-ke-style=\"style2\">\n<p data-ke-size=\"size16\">  이 강의들은 한국어, 일본어, 베트남어, 영어로 자막 및 더빙이 제공됩니다.<br />즉, 아시아권 개발자 누구나 언어 장벽 없이 수강하실 수 있도록 준비되어 있습니다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">더욱 감사한 것은 <b>오픈 기간 동안40% 할인까지도</b> 동의해주셨다.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li><a href=\"https://www.inflearn.com/tag-curation/common_tag/vlad2504?utm_source=jojoldu&amp;utm_medium=earned&amp;utm_campaign=traffic_push-lecture_vlad2504&amp;utm_content=instructor_&amp;utm_term=250417\">Vlad Mihalcea 님의 오픈 이벤트</a></li>\n</ul>\n<p data-ke-size=\"size16\">\"실무에서 성능과 구조 모두를 고려해야 하는 상황에서 무엇을 기준으로 선택할 것인가\" 를 알려주는 강의를 이제 우리 팀원들에게도 알려줄 수 있게 되어서 너무나 기뻤다.</p>\n<p data-ke-size=\"size16\">우리 팀 외에도 특히 다음과 같은 분들께 추천드리고 싶다:</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li>JPA, Hibernate 등을 사용하지만 내부 구조를 분석하고 근본적인 이해를 높이고 싶거나</li>\n<li>실무 환경의 Java Data Access 계층에서 발생하는 성능 문제를 해결하는 방법을 배우고 싶거나</li>\n<li>ORM 을 적극적으로 쓰는 환경에서의 SQL 성능 개선 방법을 배우고 싶거나</li>\n</ul>\n<p data-ke-size=\"size16\">이런 분들이라면 이번 Vlad의 강의를 적극 추천하고 싶다.<br />전세계 Java 개발자들이 Vlad의 컨텐츠를 좋아하고 강의를 듣는 이유가 무엇인지 잘 알 수 있다.</p>\n<p data-ke-size=\"size16\">지금 Java 개발을 시작하는 분들은 나처럼 영어 문장 하나 하나를 직접 번역해가며, 여러 해외카드들을 교체해가며 결제하는 등의 불편함 없이 배울 수 있게 되었다는 것이 훨씬 기쁘다.</p>\n<p data-ke-size=\"size16\">Vlad 외에도 세상엔 너무나 훌륭한 개발자분들과 그들의 강의들이 있다.<br />이 강의들을 모두 다 <b>언어와 결제, 학습의 제약 없이</b> 듣는 것을 꿈꾸고 있다.<br />그리고 출간을 준비하고 있는 <b>High-Performance Java Persistence 2판</b>도 인프런에서 만나볼 수 있게 되기를 기대한다.</p>",
        "contentSnippet": "유튜브나 블로그를 하다 보면 예상치 못한 인연들이 생긴다.\n지금까지 10년 가까운 시간을 블로그를 하면서 큰 동력이 된 사건이기도 하다.\n \n운이 좋게도 2014년부터 다녔던 회사는 Hibernate를 사용하는 회사였고, 그 당시 iBatis, MyBatis를 쓰는 것이 당연한 상황에서 Hibernate를 실무에서 사용해볼 수 있었다.\n다만, 처음 사용해보는 기술이니 이걸 더 잘 쓰기 위해서 공부를 하고 싶은데 공부할 수 있는 컨텐츠가 없었다.\n한국어로 된 컨텐츠의 대부분은 iBatis, MyBatis였기 때문이다.\n다행히 기선님이 번역해주신 개빈 킹의 하이버네이트 완벽가이드가 있었지만 나 같은 초보 개발자에겐 너무나 어렵게 느껴져 한줄 한줄 밑줄 그어가며 이해하려고 노력했다.\n영한님의 Java ORM에 대한 DevOn 발표 자료도 발견하게 되고 이후엔 영한님의 책 까지 보면서 Java ORM에 대해 훨씬 쉽게 다가갈 수 있었고 실무를 하는데 있어서 충분히 많은 지식을 쌓을 수 있었다.\n이후에도 계속 JPA, Hibernate를 실무에서 계속 사용할 수 있었는데, 구글링 할때마다 항상 만나는 블로그와 스택오버플로우의 답변 유저가 있었다.\n그게 바로 Vlad Mihalcea였다.\n나중에 알고 보니 그는 자바 챔피언이자 Hibernate Top Committer 였다는 것에 \"역시...\" 라는 생각을 했다.\n당시에는 \"와 역시 해외는 어마어마한 개발자들이 많구나. 영어 공부 진짜 열심히 해야겠다\" 라는 생각을 하면서 열심히 그의 글을 탐닉했다.\n새로운 글이 올라오면 항상 챙겨보고 그게 진짜 맞는지 성능 테스트를 진행해보고 효과를 확인 한뒤에는 회사에 적용하는 등 그의 지식을 어떻게든 내 것으로 다 흡수하고 싶었다.\n그의 책 High-Performance Java Persistence는 사무실 책상 위에 항상 펼쳐져 있었다.\n그렇게 몇년의 경력이 쌓이던 중,\n2018년 갑자기 블로그의 트래픽이 폭발적으로 늘어나는 일이 있었다.\n어디서 이렇게 유입된 건지 찾아보다가 Hibernate 공식 커뮤니티 뉴스레터 2018년 10호에서 내가 작성한 \"Spring Boot Data JPA 2.0 에서 id Auto_increment 문제 해결\"을 소개한 것을 발견했다.\n전세계 Java 개발자들이 구독하고 있는 Hibernate 뉴스레터에서 언급된 것이다.\n그 뉴스레터는 내가 매일 방문하던 Vlad Mihalcea가 작성한 것이기에 믿기지 않는 순간이였다.\n\n\n\n이때의 기억이 강렬해서 \"와 블로그 진짜 오래오래 해야겠다\" 라는 다짐을 했었다.\n그리고 10년 넘게 블로그를 운영하게 되었다.\n그 날 이후로는 기술적인 글 외에도, Vlad Mihalcea 라는 개발자에 대해서도 관심을 가지기 시작했다.\n그의 기술적인 노하우 뿐만 아니라,\n'이 사람은 도대체 어떤 커리어를 밟아왔을까?'\n'어떻게 자바 챔피언이 되었을까?'\n'어떻게 이렇게 한 분야에서 세계적인 전문가가 되었을까?' 등등.\nHow to become a Java Champion\n책 외에 또 배울 수 있는 것들이 없을까 싶어 그의 온라인 스토어에서 판매하는 온라인 강의들도 찾아서 들었다.\nJava Persistence 에서의 성능 개선 노하우나 Java 환경에서의 SQL 성능 개선 등 자바 개발자 뿐만 아니라 ORM을 사용하는 개발자로서 필요한 대부분의 성능 개선 노하우를 얻을 수 있었다.\nORM과 SQL 양 쪽에 맞는 가장 적절한 성능 튜닝 사례들을 배울 수 있었고, 이때 배운 지식들은 수십억건의 데이터들 사이에서도 복잡한 도메인들을 처리하는데 큰 힘이 되었다.\n다만, 강의를 수강하는게 수월하지는 않았다.\n영어로만 강의가 제공되어서 하나의 강의를 수강하는데 하나하나를 번역해서 보는데 너무 많은 힘이 들었고\n결제 오류가 빈번해서 결제하기가 쉽지 않았고\n강의를 수강하는데 있어서의 편의 기능이 많이 부족했다. (모바일 플레이어, 자막 등등)\n그래도 좋았다.\n이것마저 없으면 그의 양질의 컨텐츠를 볼 수 있는 방법이 없는데, 이렇게라도 볼 수 있으니 말이다.\n이렇게 쌓인 노하우는 이후에 전 직장 첫번째 컨퍼런스에서 아낌없이 쏟아낼 수 있었다.\n[우아콘2020] 수십억건에서 QUERYDSL 사용하기\n이 세션은 (갓)영한님의 세션 다음으로 가장 높은 조회수가 나와서 많은 개발자분들이 좋아해주셨다.\n그동안의 공부와 경험이 전혀 잘못되지 않았다는 것을 느끼게 해주었다.\n이런 경험으로 성장을 해왔기에,\n현재 회사로 이직하고 나서 우리팀 백엔드 개발자분들에게 Vlad의 강의를 너무 소개해주고 싶었다.\n꼭 JPA 뿐만 아니라 모든 ORM과 SQL을 사용하는 개발자들에게 필수적인 내용을 담고 있기 때문이다.\n우리 같이 Node.js가 주력인 개발팀에는 언어나 프레임워크에 상관없이 이런 강의가 대단히 필요하다.\n하지만, 위에서 언급한 \"언어의 장벽이나 결제, 학습 편의성\" 등을 생각하니 \"우리 팀 분들에게도 나처럼 힘들게 공부하시라\" 라고 이야기하기 어려웠다.\n어떻게든 우리팀에 이 지식들을 가장 편하게 전달하고 싶었다.\n어떡하는게 좋을까....?\n그래서 Vlad Mihalcea에게 연락을 드렸다.\n당신의 강의를 한국어로, 일본어로, 베트남어로 듣고 싶다고.\nVlad는 너무나 쿨하게, 너무나 멋지게 이 협업을 받아들여 주셨다.\n그리고 드디어!\nVlad Mihalcea의 공식 강의 2개가 인프런에 오픈되었다.\n  High-Performance Java Persistence\n  High-Performance SQL\n  이 강의들은 한국어, 일본어, 베트남어, 영어로 자막 및 더빙이 제공됩니다.\n즉, 아시아권 개발자 누구나 언어 장벽 없이 수강하실 수 있도록 준비되어 있습니다.\n더욱 감사한 것은 오픈 기간 동안40% 할인까지도 동의해주셨다.\nVlad Mihalcea 님의 오픈 이벤트\n\"실무에서 성능과 구조 모두를 고려해야 하는 상황에서 무엇을 기준으로 선택할 것인가\" 를 알려주는 강의를 이제 우리 팀원들에게도 알려줄 수 있게 되어서 너무나 기뻤다.\n우리 팀 외에도 특히 다음과 같은 분들께 추천드리고 싶다:\nJPA, Hibernate 등을 사용하지만 내부 구조를 분석하고 근본적인 이해를 높이고 싶거나\n실무 환경의 Java Data Access 계층에서 발생하는 성능 문제를 해결하는 방법을 배우고 싶거나\nORM 을 적극적으로 쓰는 환경에서의 SQL 성능 개선 방법을 배우고 싶거나\n이런 분들이라면 이번 Vlad의 강의를 적극 추천하고 싶다.\n전세계 Java 개발자들이 Vlad의 컨텐츠를 좋아하고 강의를 듣는 이유가 무엇인지 잘 알 수 있다.\n지금 Java 개발을 시작하는 분들은 나처럼 영어 문장 하나 하나를 직접 번역해가며, 여러 해외카드들을 교체해가며 결제하는 등의 불편함 없이 배울 수 있게 되었다는 것이 훨씬 기쁘다.\nVlad 외에도 세상엔 너무나 훌륭한 개발자분들과 그들의 강의들이 있다.\n이 강의들을 모두 다 언어와 결제, 학습의 제약 없이 듣는 것을 꿈꾸고 있다.\n그리고 출간을 준비하고 있는 High-Performance Java Persistence 2판도 인프런에서 만나볼 수 있게 되기를 기대한다.",
        "guid": "http://jojoldu.tistory.com/825",
        "categories": [
          "생각정리",
          "hibernate",
          "high-performance java persistence",
          "high-performance sql",
          "java champion",
          "JPA",
          "Vlad Mihalcea"
        ],
        "isoDate": "2025-04-17T02:23:28.000Z"
      }
    ]
  },
  {
    "name": "WestwoodForever's Dev Log",
    "category": "개인",
    "posts": []
  },
  {
    "name": "허니몬(Honeymon)의 자바guru",
    "category": "개인",
    "posts": []
  },
  {
    "name": "Wolf Loves Fox :: 일상",
    "category": "개인",
    "posts": []
  },
  {
    "name": "Game Programmer Life",
    "category": "개인",
    "posts": []
  },
  {
    "name": "IT 프리랜서 이야기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "yuchi's dev",
    "category": "개인",
    "posts": []
  },
  {
    "name": "만화로 나누는 자유/오픈소스 소프트웨어 이야기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "신현석(Hyeonseok Shin)",
    "category": "개인",
    "posts": []
  },
  {
    "name": "한상곤 - Sigmadream",
    "category": "개인",
    "posts": []
  },
  {
    "name": "개발자 울이 노트",
    "category": "개인",
    "posts": []
  },
  {
    "name": "즐거운 개발자 :: 네이버  블로그",
    "category": "개인",
    "posts": []
  },
  {
    "name": "황제펭귄의 게임개발이야기 [여기는 한국]",
    "category": "개인",
    "posts": []
  },
  {
    "name": "LINE ENGINEERING",
    "category": "기업",
    "posts": [
      {
        "title": "코드 품질 개선 기법 8편: 실상과 허상",
        "link": "https://techblog.lycorp.co.jp/ko/techniques-for-improving-code-quality-8",
        "pubDate": "Fri, 18 Apr 2025 02:00:00 GMT",
        "content": "안녕하세요. 커뮤니케이션 앱 LINE의 모바일 클라이언트를 개발하고 있는 Ishikawa입니다.저희 회사는 높은 개발 생산성을 유지하기 위해 코드 품질 및 개발 문화 개선에 힘쓰고...",
        "contentSnippet": "안녕하세요. 커뮤니케이션 앱 LINE의 모바일 클라이언트를 개발하고 있는 Ishikawa입니다.저희 회사는 높은 개발 생산성을 유지하기 위해 코드 품질 및 개발 문화 개선에 힘쓰고...",
        "guid": "https://techblog.lycorp.co.jp/ko/techniques-for-improving-code-quality-8",
        "isoDate": "2025-04-18T02:00:00.000Z"
      }
    ]
  },
  {
    "name": "뱅크샐러드 블로그",
    "category": "기업",
    "posts": []
  },
  {
    "name": "우아한형제들 기술 블로그",
    "category": "기업",
    "posts": []
  },
  {
    "name": "TOAST Meetup",
    "category": "기업",
    "posts": []
  },
  {
    "name": "ZUM 기술 블로그",
    "category": "기업",
    "posts": []
  },
  {
    "name": "SK Planet",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Spoqa tech blog",
    "category": "기업",
    "posts": [
      {
        "title": "단지 권한 기능을 추가해달라고 했을 뿐인데(feat. 인증 기능 개선)",
        "link": "https://spoqa.github.io/2025/04/18/improve-auth.html",
        "pubDate": "2025-04-18T00:00:00.000Z",
        "author": "남경호",
        "content": "<p>안녕하세요. 스포카 백엔드팀 프로그래머 남경호입니다.</p>\n\n<p>개발자라면 누구나 오랫동안 미뤄두었던 과제가 하나쯤 있을 것입니다. 업무의 우선순위가 낮거나 긴급한 과제들에 밀려 지속적으로 백로그에 쌓여 있던 작업 말이죠. 최근 저희팀에서 왜 오랜 시간 미뤄두었던 인증 방식 개선 작업을 진행하게 되었는지, 그 과정에서 얻은 여러 경험을 여러분께 공유하고자 합니다.</p>\n\n<h1 id=\"배경\">배경</h1>\n\n<p>스포카 블로그를 꾸준히 보신 분이라면, <a href=\"https://spoqa.github.io/2022/04/15/all-new-server.html\" target=\"\\_blank\">서버 언어 전환 이야기</a> 글에서 <a href=\"https://en.wikipedia.org/wiki/JSON_Web_Token\" target=\"\\_blank\">JWT</a> 관련 문제를 언급하며 향후 개선할 예정이라고 소개했던 내용을 기억하실 겁니다.</p>\n\n<p><img src=\"/images/improve-auth/jwt.png\" alt=\"jwt\" /></p>\n\n<p>약 3년이 흐른 지금, 드디어 저희가 인증 방식 개선을 진행하게 된 가장 큰 이유는 바로 키친보드 매장 앱에 권한관리 기능이 추가되었기 때문입니다.</p>\n\n<p><img src=\"/images/improve-auth/request-work.png\" alt=\"request-work\" /></p>\n\n<p>키친보드 매장 앱은 식자재 주문부터 거래대금 결제까지 다양한 기능을 제공합니다. 이 과정에서 사장님은 직원이 매장의 월 거래 내역 등 민감한 정보를 조회하지 못하도록 권한을 제어할 필요가 생겼는데요. 기존 JWT 인증은 무 상태(stateless) 특성상 권한 변경 시 즉각적으로 클라이언트의 인증 상태를 관리할 수 없다는 한계가 있었습니다.</p>\n\n<p>그래서 저희는 권한 기능을 추가하기에 앞서 인증 방식을 먼저 개선하기로 하였습니다.</p>\n\n<h1 id=\"인증-방식-개선-방법\">인증 방식 개선 방법</h1>\n\n<h2 id=\"refresh-token-도입\">Refresh Token 도입</h2>\n\n<p>앞서 이야기했듯이, JWT 기반의 인증 방식은 서버가 사용자의 상태를 저장하지 않습니다. 덕분에 서버의 확장성이 높고 서버 부하를 줄일 수 있다는 장점이 있지만, 한번 발급된 토큰을 서버에서 직접 제어할 수 없다는 단점이 있습니다.</p>\n\n<p>이러한 특성은 보안 문제로 연결될 수 있는데요. 만약 인증을 통해 발급받은 토큰이 탈취된다면, 서버가 이 토큰을 제어할 수 없으므로 악의적인 사용자는 손쉽게 탈취된 토큰을 이용하여 정상 사용자처럼 서비스를 이용할 수 있게 됩니다. 보통 이러한 보안 위험을 방지하기 위해 Access Token의 만료 시간을 짧게 설정하지만, 이 경우 사용자가 자주 로그인해야 하는 번거로움이 발생하게 됩니다.</p>\n\n<p>이와 같은 문제를 해결할 수 있는 대표적인 방법의 하나가 바로 <a href=\"https://auth0.com/docs/secure/tokens/refresh-tokens\" target=\"\\_blank\">Refresh Token</a> 의 도입입니다. Refresh Token은 Access Token과 달리 서버가 상태를 관리하는 토큰으로, Access Token을 갱신하는 데 사용됩니다. 앞서 말씀드린 대로, Access Token의 탈취 위험을 낮추기 위해 Access Token의 만료 시간을 짧게 설정하는 것이 좋은데요. 이때 Refresh Token을 활용하면 사용자가 Access Token의 만료 시점마다 다시 로그인하지 않아도 편리하게 새로운 Access Token을 발급받을 수 있습니다.</p>\n\n<p>다음 그림에서 Access Token과 Refresh Token의 인증 과정을 자세히 확인할 수 있습니다.</p>\n\n<p><img src=\"/images/improve-auth/auth-flow-with-refresh-token.png\" alt=\"auth-flow-with-refresh-token\" /></p>\n\n<ol>\n  <li>사용자가 로그인을 요청하면 서버는 Access Token과 Refresh Token을 발급합니다.</li>\n  <li>사용자는 발급받은 유효한 Access Token을 이용해 API를 호출하고, 서버는 요청된 데이터를 정상적으로 응답합니다.</li>\n  <li>사용자가 만료된 Access Token을 가지고 API 요청을 하면 서버는 401 인증 에러를 반환합니다. 이때 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받고, 갱신된 Access Token으로 API를 재요청하여 정상적으로 데이터를 받을 수 있습니다.</li>\n  <li>하지만 만약 사용자의 Refresh Token까지 만료된 상태라면, 서버는 최종적으로 401 인증 에러를 반환하여 사용자의 다시 로그인을 요구합니다.</li>\n</ol>\n\n<p>위 과정을 통해 일반적으로 Access Token의 만료 시간을 짧게 설정하여 Access Token의 탈취 위험을 최소화하고, Refresh Token을 통해 사용자 편의성 또한 유지할 수 있습니다.</p>\n\n<p>아래 그림을 통해 Access Token의 탈취로 인한 공격 시나리오로 Access Token의 만료시간이 짧으면 짧을수록 보안 위험도가 감소하게 됩니다.</p>\n\n<p><img src=\"/images/improve-auth/malicous-case1.png\" alt=\"malicous-case1\" /></p>\n\n<p>이처럼 Refresh Token을 적절히 도입하고 관리하면 토큰 탈취로 인한 보안 위험을 효과적으로 감소시킬 뿐만 아니라 사용자가 매번 로그인해야 하는 문제도 해결할 수 있으므로 사용성도 함께 챙길 수 있게 됩니다.</p>\n\n<h2 id=\"refresh-token-rotation\">Refresh Token Rotation</h2>\n\n<p>한편, Access Token에 대한 탈취 위험은 Refresh Token도 동일한 것 아닌가? 라는 질문을 할 수 있을 것 같습니다. 맞습니다. Refresh Token이 탈취당하면 Access Token을 갱신할 수 있고 갱신된 Access Token을 통해 악의적 사용자는 손쉽게 탈취한 사용자인 척 서비스를 이용할 수 있게 됩니다.</p>\n\n<p>이러한 문제를 해결하기 위해 우리는 <a href=\"https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation\" target=\"\\_blank\">Refresh Token Rotation</a> 을 도입하기로 합니다. Refresh Token Rotation은 아래와 같이 Refresh Token을 이용해 Access Token을 갱신할 때 Refresh Token도 함께 갱신하여 Refresh Token 탈취 시 발생할 수 있는 위험을 회피합니다.</p>\n\n<p><img src=\"/images/improve-auth/malicous-case2.png\" alt=\"malicous-case2\" /></p>\n\n<h1 id=\"이슈\">이슈</h1>\n\n<h2 id=\"클라이언트의-네트워크-이슈\">클라이언트의 네트워크 이슈</h2>\n\n<p>앞서 저희는 Refresh Token Rotation을 이용하여 Refresh Token 탈취에 대한 위험성을 회피하고자 하였습니다. 이렇게 하면 Refresh Token을 이용하여 Access Token을 갱신 요청할 때 요청한 Refresh Token도 새롭게 발급되어 더 이상 Refresh Token을 사용할 수 없게 되는데요. 보안 수준은 강화되었지만, 클라이언트 개발자분들이 한가지 우려 점을 제기해 주셨습니다.</p>\n\n<p>모바일 기기 특성상 지하실이나 엘리베이터안과같이 네트워크가 원활하지 않은 곳에서 사용할 가능성이 존재하는데요. 이때 아래 그림과 같이 첫 번째 요청한 Refresh Token을 재요청하는 경우가 발생할 수 있습니다. 하지만 Refresh Token을 매번 갱신하기 때문에 동일한 Refresh Token으로 여러번 Access Token을 갱신요청하게 된다면 두번째 요청부터는  인증 에러가 발생하게 됩니다.</p>\n\n<p><img src=\"/images/improve-auth/network-issue-case.png\" alt=\"network-issue-case\" /></p>\n\n<p>그래서 저희는 <a href=\"https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation#automatic-reuse-detection\" target=\"\\_blank\">Token Family 방식</a> 을 사용하여 요청 시마다 기존 Refresh Token을 지우지 않고 과거 토큰을 저장해 두었다가 첫 번째 요청으로 새롭게 발급된 토큰 또는 모종의 이유로 인해 갱신하지 못한 기존 토큰으로 토큰 갱신 요청을 할 수 있도록 구현하여 Refresh Token을 재사용할 수 있도록 하였습니다.</p>\n\n<p><img src=\"/images/improve-auth/token-family-flow.png\" alt=\"token-family-flow\" /></p>\n\n<p>이로써 클라이언트는 네트워크 이슈가 발생해도 Refresh Token을 갱신할 수 있게 되었습니다.</p>\n\n<p><img src=\"/images/improve-auth/resolved-network-issue-flow.png\" alt=\"resolved-network-issue-flow\" /></p>\n\n<h2 id=\"인증-토큰의-하위-호환\">인증 토큰의 하위 호환</h2>\n\n<p>한편, 저희는 JWT를 다루는 라이브러리로 <a href=\"https://github.com/spoqa/jjwt\" target=\"\\_blank\">JJWT</a> 를 사용하고 있습니다. 앞서 JWT는 상태를 가지지 않기 때문에 사용자가 사용하는 Access Token을 서버에서 제어할 수 없다고 말씀드렸었는데요. 그래서 Access Token의 만료 시간을 두어 새롭게 Access Token을 발급받도록 하여 우회적으로 제어할 수 있습니다. Access Token을 만료시키는 또 다른 방법은, 해당 토큰을 생성할 때 사용된 암호키를 변경하는 것입니다. 저희는 그래서 클라이언트에서 사용하는 Access Token을 만료시키고 새롭게 변경된 권한을 사용하는 Access Token으로 사용하도록 하기 위해 암호키를 바꾸기로 하였습니다. 다만 여기서 발생하는 문제가 바로 앱의 업데이트 타이밍이었습니다.</p>\n\n<p>개발자라면 다들 잘 아시겠지만, 서버와 앱은 동일한 시점에 개발이 완료되더라도 배포되는 시점이 다를 수 있습니다. 서버는 배포하는 즉시 배포가 되지만 앱은 심사 과정이 필요하고 배포가 되더라도 앱스토어에 배포된 버전이 전파되기까지 1일 이상 소요될 수 있습니다. 그러다 보니 Access Token을 변경하기 위해 키를 변경하게 되면 서버가 배포된 이후부터 앱이 업데이트되기 전까지 사용자가 서비스를 이용할 수 없다는 문제가 생길 수 있습니다. 그래서 저희는 과거 버전의 앱에서도 새롭게 배포된 서버의 인증을 문제없이 사용할 수 있도록 방법을 모색해야 했습니다.</p>\n\n<h3 id=\"jjwt-버전-변경\">JJWT 버전 변경</h3>\n\n<p>한편, 저희는 비밀키를 바꾸는 김에, 과거에 사용하던 서명 알고리즘(HS256)에 비해 보안성이 강화된 서명 알고리즘(PS256)을 변경하기로 합니다. 그러다 보니 JJWT라이브러리 버전을 업그레이드해야 했는데요. Gradle에 아래처럼 동일한 라이브러리를 서로 다른 버전으로 사용하는 경우 패키지 충돌이 발생하여 신규 버전에서 제공하는 함수를 사용할 수 없게 됩니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 구버전</span>\n<span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt:0.9.1\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\">// 신규버전</span>\n<span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-api:0.12.6\"</span><span class=\"p\">)</span>\n<span class=\"nf\">runtimeOnly</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-impl:0.12.6\"</span><span class=\"p\">)</span>\n<span class=\"nf\">runtimeOnly</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-jackson:0.12.6\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><img src=\"/images/improve-auth/jjwt-version-conflict.png\" alt=\"jjwt-version-conflict\" /></p>\n\n<p>이러한 문제를 해결하기 위해 저희는 <a href=\"https://jitpack.io/\" target=\"\\_blank\">Jitpack</a> 을 사용하기로 합니다. JitPack은 GitHub에 호스팅된 라이브러리를 쉽게 빌드하고 배포할 수 있게 해주는 Maven/Gradle 용 리포지터리 서비스입니다. GitHub 저장소를 바탕으로 라이브러리를 빌드하므로, 별도의 중앙 저장소(예: Maven Central) 등록 과정을 거치지 않아도 된다는 장점이 있습니다. 그리고 오픈소스 저장소에, 한에 무료로 사용할 수 있다는 점도 장점입니다.</p>\n\n<p>저희는 JJWT 라이브러리를 fork하여 <a href=\"https://github.com/spoqa/jjwt\" target=\"\\_blank\">Spoqa용 JJWT Github 저장소</a> 를 생성하였습니다. 그런 다음 충돌 패키지 충돌이 발생하지 않도록 패키지명을 변경해 주었습니다.</p>\n\n<p><img src=\"/images/improve-auth/changed-package-commit.png\" alt=\"changed-package-commit\" /></p>\n\n<p>그런 다음 Release를 생성해 주면, 아래와 같이 Jitpack에서 조회할 수 있게 됩니다.</p>\n\n<p><img src=\"/images/improve-auth/jitpack.png\" alt=\"jitpack\" /></p>\n\n<p>마지막으로 아래와 같이 Gradle에 의존성을 추가해주면, 패키지명이 변경된 JJWT라이브러리를 사용할 수 있게 됩니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"com.github.spoqa:jjwt:1.0.2\"</span><span class=\"p\">)</span>\n<span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"javax.xml.bind:jaxb-api:2.3.1\"</span><span class=\"p\">)</span>\n\n<span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-api:0.12.6\"</span><span class=\"p\">)</span>\n<span class=\"nf\">runtimeOnly</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-impl:0.12.6\"</span><span class=\"p\">)</span>\n<span class=\"nf\">runtimeOnly</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-jackson:0.12.6\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<h3 id=\"composite-패턴-vs-tokenmanager\">Composite 패턴 vs TokenManager</h3>\n\n<p>저희는 Jitpack으로 생성한 과거버전의 JJWT를 의존하는 구현체를 아래와 같이 <code class=\"language-plaintext highlighter-rouge\">LegacyJwtProcessor</code>로 변경하고 신규 버전을 사용하는 <code class=\"language-plaintext highlighter-rouge\">JwtProcessor</code>를 새롭게 생성하였습니다. 그런 다음 아래와 같이 인증 로직에 과거 버전의 Access Token과 신규 버전의 Access Token을 모두 수용할 수 있도록 구현하였습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Component</span>\n<span class=\"kd\">class</span> <span class=\"nc\">JwtAuthenticationProvider</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">legacyJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">LegacyJwtProcessor</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">jwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">AuthenticationProvider</span> <span class=\"p\">{</span>\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">authenticate</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Authentication</span><span class=\"p\">):</span> <span class=\"nc\">Authentication</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(!</span><span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">))</span> <span class=\"k\">return</span> <span class=\"k\">null</span>\n\n        <span class=\"kd\">val</span> <span class=\"py\">principal</span> <span class=\"p\">=</span>\n            <span class=\"k\">try</span> <span class=\"p\">{</span>\n                <span class=\"n\">jwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">.</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">())</span>\n            <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nc\">AuthenticationException</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">legacyJwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">.</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">())</span>\n            <span class=\"p\">}</span>\n\n        <span class=\"k\">return</span> <span class=\"nc\">JwtUserAuthenticationToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Class</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;):</span> <span class=\"nc\">Boolean</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">authentication</span> <span class=\"p\">==</span> <span class=\"nc\">JwtPreAuthenticationToken</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이렇게 구현하면 앱이 배포되기 전에 서버가 먼저 배포되어도 기존 버전을 사용하는 사용자가 정상적으로 로그인을 유지할 수 있게 됩니다.</p>\n\n<p>한편, 인증 로직을 구현하는 곳 말고도 LegacyJwtProcessor를 사용하는 곳이 다수 존재하였는데요. 그러다 보니 새롭게 만들어진 JwtProcessor로 전환하는 것을 누락할 가능성이 존재하였습니다. 다행히 기능 테스트가 있어 놓친 구현을 바로잡을 순 있었지만, 코드의 응집성 측면에서는 좋은 코드는 아니라 생각하였습니다.</p>\n\n<p>그래서 Composite 패턴을 사용해서 아래와 같이 구현해 볼지 생각을 하였습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">interface</span> <span class=\"nc\">JwtProcessor</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">generateToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">CompositeJwtProcessor</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">newJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">legacyJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n<span class=\"p\">):</span> <span class=\"nc\">JwtProcessor</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">generateToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">try</span> <span class=\"p\">{</span>\n            <span class=\"n\">jwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nc\">AuthenticationException</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">legacyJwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">NewJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">generateToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"err\">legacy</span><span class=\"nc\">JwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">generateToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">CompositeJwtProcessor</code>를 이용하면 아래와 같이 <code class=\"language-plaintext highlighter-rouge\">JwtAuthenticationProvider</code>는 더 이상 <code class=\"language-plaintext highlighter-rouge\">legacyJwtProcessor</code>를 알지 않아도 되고 추후 <code class=\"language-plaintext highlighter-rouge\">legacyJwtProcessor</code>가 제거되어도 영향범위는 <code class=\"language-plaintext highlighter-rouge\">CompositeJwtProcessor</code>로 한정되기 때문에 응집도 높은 코드를 유지할 수 있게 됩니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Component</span>\n<span class=\"kd\">class</span> <span class=\"nc\">JwtAuthenticationProvider</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">compositeJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">AuthenticationProvider</span> <span class=\"p\">{</span>\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">authenticate</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Authentication</span><span class=\"p\">):</span> <span class=\"nc\">Authentication</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(!</span><span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">))</span> <span class=\"k\">return</span> <span class=\"k\">null</span>\n\n        <span class=\"kd\">val</span> <span class=\"py\">principal</span> <span class=\"p\">=</span> <span class=\"n\">compositeJwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">.</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">())</span>\n\n        <span class=\"k\">return</span> <span class=\"nc\">JwtUserAuthenticationToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n    \n    <span class=\"c1\">// 생략...</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>다른 방법으로는 TokenManager라는 상위 수준의 클래스를 만들어 응집도를 높이는 방법도 생각해 보았습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">class</span> <span class=\"nc\">TokenManager</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">jwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">legacyJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">LegacyJwtProcessor</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">refreshTokenService</span><span class=\"p\">:</span> <span class=\"nc\">RefreshTokenService</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">try</span> <span class=\"p\">{</span>\n            <span class=\"n\">jwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nc\">AuthenticationException</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">legacyJwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">fun</span> <span class=\"nf\">generateAccessToken</span><span class=\"p\">(</span><span class=\"n\">userPrincipal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">fun</span> <span class=\"nf\">generateRefreshToken</span><span class=\"p\">(</span><span class=\"n\">entity</span><span class=\"p\">:</span> <span class=\"nc\">RefreshToken</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">fun</span> <span class=\"nf\">replaceRefreshToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">RefreshTokenUserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이렇게 하면 Token을 Composite 패턴을 사용한 것과 같이 하위호환을 지키는 코드와 함께 토큰과 관련된 다른 기능들도 해당 클래스로 모을 수 있어 응집도를 상당히 높일 수 있게 됩니다.</p>\n\n<p>어떤 방식이 더 나은 방식이라고 말씀드리긴 어려울 것 같습니다. 다만, 저희는 LegacyJwtProcessor는 앱 배포 이후에 제거될 클래스이므로 불필요하게 Composite 패턴을 사용하기보다 TokenManager를 생성하여 코드 응집도를 높이는 방법으로 결정하게 되었습니다.</p>\n\n<h3 id=\"spring-security---preauthorize\">Spring Security - PreAuthorize</h3>\n\n<p>저희는 인증과 인가를 위해 Spring Security를 사용하고 있습니다. JWT를 통해 인증된 사용자는 UserPrincipal이라는 인증된 사용자로 변환되고 UserPrinciapl이 가진 authorities를 통해 권한 처리를 하고 있습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Component</span>\n<span class=\"kd\">class</span> <span class=\"nc\">AccessTokenAuthenticationProvider</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">tokenManager</span><span class=\"p\">:</span> <span class=\"nc\">TokenManager</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">AuthenticationProvider</span> <span class=\"p\">{</span>\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">authenticate</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Authentication</span><span class=\"p\">):</span> <span class=\"nc\">Authentication</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(!</span><span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">))</span> <span class=\"k\">return</span> <span class=\"k\">null</span>\n\n        <span class=\"kd\">val</span> <span class=\"py\">principal</span> <span class=\"p\">=</span> <span class=\"n\">tokenManager</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">.</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">())</span>\n        <span class=\"k\">return</span> <span class=\"nc\">AccessTokenAuthenticationToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Class</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;):</span> <span class=\"nc\">Boolean</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">authentication</span> <span class=\"p\">==</span> <span class=\"nc\">AccessTokenPreAuthenticationToken</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">AccessTokenAuthenticationToken</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">AbstractAuthenticationToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"n\">authorities</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nf\">init</span> <span class=\"p\">{</span>\n        <span class=\"k\">super</span><span class=\"p\">.</span><span class=\"nf\">setAuthenticated</span><span class=\"p\">(</span><span class=\"k\">true</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">()</span> <span class=\"p\">=</span> <span class=\"n\">principal</span>\n\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">getCredentials</span><span class=\"p\">()</span> <span class=\"p\">=</span> <span class=\"k\">null</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>사용자는 아래와 같이 <code class=\"language-plaintext highlighter-rouge\">@Secured</code>를 통해 권한을 검증받고 API를 호출할 수 있습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@DgsMutation</span>\n<span class=\"nd\">@Secured</span><span class=\"p\">(</span><span class=\"nc\">STORE_ADMIN</span><span class=\"p\">,</span> <span class=\"nc\">STORE_MANAGER</span><span class=\"p\">,</span> <span class=\"nc\">VENDOR</span><span class=\"p\">)</span>\n<span class=\"k\">fun</span> <span class=\"nf\">createOrderSheet</span><span class=\"p\">(</span>\n    <span class=\"nd\">@InputArgument</span> <span class=\"n\">input</span><span class=\"p\">:</span> <span class=\"nc\">CreateOrderSheetInput</span><span class=\"p\">,</span>\n<span class=\"p\">):</span> <span class=\"nc\">CreateOrderSheet</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 생략...</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">@Secured</code>는 단순한 권한 Role 기반 접근을 제어하기에 적절합니다. 이전까지 키친보드는 관리자, 매장 사용자, 유통사 사용자로 명확하게 Role이 나뉘어져 있었기 때문에 <code class=\"language-plaintext highlighter-rouge\">@Secured</code>는 요구사항을 충분히 충족하면서 단순하게 구현할 방법이었습니다.</p>\n\n<p>하지만 새로운 요구사항이 추가되면서 매장 사용자는 매장 관리자, 매장 직원으로 권한이 분리되게 되었는데요. 이에 따라 매장 사용자 모두 접근을 할 수 있는 API에는 아래와 같이 <code class=\"language-plaintext highlighter-rouge\">@Secured(STORE_ADMIN, STORE_MANAGER)</code> 표현해야 하는 불편함이 있게 됩니다. 거기다 만약 <code class=\"language-plaintext highlighter-rouge\">STORE_INTERN</code>이 추가된다면 매장 사용자 권한을 가져야 하는 API를 모두 찾아서 바꿔줘야 하니 상당히 번거로운 작업이 될 것이고 자칫 권한 변경을 누락할 수 있는 위험성 또한 내포하고 있습니다.</p>\n\n<p>이와 같은 문제를 해소하기 위해 Spring Security에서는 <code class=\"language-plaintext highlighter-rouge\">@PreAuthorize</code>를 이용하여 유연하게 권한을 체크하는 기능을 제공합니다. 그래서 저희는 아래와 같이 매장 사용자 여부를 확인하는 서비스 함수를 만들어 <a href=\"https://docs.spring.io/spring-framework/reference/core/expressions.html\" target=\"\\_blank\">SpEL</a> 을 이용해 권한을 체크하도록 함으로써 권한을 일일이 나열하지 않고 새로운 권한이 생기더라도 유연하게 대처할 수 있도록 하였습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@PostMapping</span><span class=\"p\">(</span><span class=\"s\">\"/replace-store\"</span><span class=\"p\">)</span>\n<span class=\"nd\">@PreAuthorize</span><span class=\"p\">(</span><span class=\"s\">\"@authorizationExpressionHelper.isManager()\"</span><span class=\"p\">)</span>\n<span class=\"k\">fun</span> <span class=\"nf\">replaceStore</span><span class=\"p\">(</span><span class=\"nd\">@RequestBody</span> <span class=\"n\">request</span><span class=\"p\">:</span> <span class=\"nc\">ReplaceStoreRequest</span><span class=\"p\">):</span> <span class=\"nc\">ReplaceStoreResponse</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 생략...</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Service</span>\n<span class=\"kd\">class</span> <span class=\"nc\">AuthorizationExpressionHelper</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">isManager</span><span class=\"p\">():</span> <span class=\"nc\">Boolean</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nc\">PrincipalProvider</span><span class=\"p\">.</span><span class=\"n\">userPrincipal</span><span class=\"p\">.</span><span class=\"n\">isManager</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h1 id=\"마무리\">마무리</h1>\n\n<p>지금까지 저희가 권한 기능을 추가하기 위해 인증 로직을 어떻게 개선하였고 개선하면서 겪었던 이슈들을 공유해 보았습니다. 단순히 권한을 추가해 달라는 요구사항에서 시작되었지만, 그동안 우리가 가지고 있던 기술 부채도 해결함과 동시에 기술적인 여러 고민을 할 수 있어서 개인적으로 배운 게 많은 프로젝트였습니다.</p>\n\n<p>모쪼록 인증 기능 구현에 관심이 있으시거나 예정인 분들께 도움이 되었으면 합니다.</p>\n\n<p>긴 글 읽어주셔서 감사합니다.</p>\n",
        "contentSnippet": "안녕하세요. 스포카 백엔드팀 프로그래머 남경호입니다.\n개발자라면 누구나 오랫동안 미뤄두었던 과제가 하나쯤 있을 것입니다. 업무의 우선순위가 낮거나 긴급한 과제들에 밀려 지속적으로 백로그에 쌓여 있던 작업 말이죠. 최근 저희팀에서 왜 오랜 시간 미뤄두었던 인증 방식 개선 작업을 진행하게 되었는지, 그 과정에서 얻은 여러 경험을 여러분께 공유하고자 합니다.\n배경\n스포카 블로그를 꾸준히 보신 분이라면, 서버 언어 전환 이야기 글에서 JWT 관련 문제를 언급하며 향후 개선할 예정이라고 소개했던 내용을 기억하실 겁니다.\n\n약 3년이 흐른 지금, 드디어 저희가 인증 방식 개선을 진행하게 된 가장 큰 이유는 바로 키친보드 매장 앱에 권한관리 기능이 추가되었기 때문입니다.\n\n키친보드 매장 앱은 식자재 주문부터 거래대금 결제까지 다양한 기능을 제공합니다. 이 과정에서 사장님은 직원이 매장의 월 거래 내역 등 민감한 정보를 조회하지 못하도록 권한을 제어할 필요가 생겼는데요. 기존 JWT 인증은 무 상태(stateless) 특성상 권한 변경 시 즉각적으로 클라이언트의 인증 상태를 관리할 수 없다는 한계가 있었습니다.\n그래서 저희는 권한 기능을 추가하기에 앞서 인증 방식을 먼저 개선하기로 하였습니다.\n인증 방식 개선 방법\nRefresh Token 도입\n앞서 이야기했듯이, JWT 기반의 인증 방식은 서버가 사용자의 상태를 저장하지 않습니다. 덕분에 서버의 확장성이 높고 서버 부하를 줄일 수 있다는 장점이 있지만, 한번 발급된 토큰을 서버에서 직접 제어할 수 없다는 단점이 있습니다.\n이러한 특성은 보안 문제로 연결될 수 있는데요. 만약 인증을 통해 발급받은 토큰이 탈취된다면, 서버가 이 토큰을 제어할 수 없으므로 악의적인 사용자는 손쉽게 탈취된 토큰을 이용하여 정상 사용자처럼 서비스를 이용할 수 있게 됩니다. 보통 이러한 보안 위험을 방지하기 위해 Access Token의 만료 시간을 짧게 설정하지만, 이 경우 사용자가 자주 로그인해야 하는 번거로움이 발생하게 됩니다.\n이와 같은 문제를 해결할 수 있는 대표적인 방법의 하나가 바로 Refresh Token 의 도입입니다. Refresh Token은 Access Token과 달리 서버가 상태를 관리하는 토큰으로, Access Token을 갱신하는 데 사용됩니다. 앞서 말씀드린 대로, Access Token의 탈취 위험을 낮추기 위해 Access Token의 만료 시간을 짧게 설정하는 것이 좋은데요. 이때 Refresh Token을 활용하면 사용자가 Access Token의 만료 시점마다 다시 로그인하지 않아도 편리하게 새로운 Access Token을 발급받을 수 있습니다.\n다음 그림에서 Access Token과 Refresh Token의 인증 과정을 자세히 확인할 수 있습니다.\n\n사용자가 로그인을 요청하면 서버는 Access Token과 Refresh Token을 발급합니다.\n사용자는 발급받은 유효한 Access Token을 이용해 API를 호출하고, 서버는 요청된 데이터를 정상적으로 응답합니다.\n사용자가 만료된 Access Token을 가지고 API 요청을 하면 서버는 401 인증 에러를 반환합니다. 이때 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받고, 갱신된 Access Token으로 API를 재요청하여 정상적으로 데이터를 받을 수 있습니다.\n하지만 만약 사용자의 Refresh Token까지 만료된 상태라면, 서버는 최종적으로 401 인증 에러를 반환하여 사용자의 다시 로그인을 요구합니다.\n위 과정을 통해 일반적으로 Access Token의 만료 시간을 짧게 설정하여 Access Token의 탈취 위험을 최소화하고, Refresh Token을 통해 사용자 편의성 또한 유지할 수 있습니다.\n아래 그림을 통해 Access Token의 탈취로 인한 공격 시나리오로 Access Token의 만료시간이 짧으면 짧을수록 보안 위험도가 감소하게 됩니다.\n\n이처럼 Refresh Token을 적절히 도입하고 관리하면 토큰 탈취로 인한 보안 위험을 효과적으로 감소시킬 뿐만 아니라 사용자가 매번 로그인해야 하는 문제도 해결할 수 있으므로 사용성도 함께 챙길 수 있게 됩니다.\nRefresh Token Rotation\n한편, Access Token에 대한 탈취 위험은 Refresh Token도 동일한 것 아닌가? 라는 질문을 할 수 있을 것 같습니다. 맞습니다. Refresh Token이 탈취당하면 Access Token을 갱신할 수 있고 갱신된 Access Token을 통해 악의적 사용자는 손쉽게 탈취한 사용자인 척 서비스를 이용할 수 있게 됩니다.\n이러한 문제를 해결하기 위해 우리는 Refresh Token Rotation 을 도입하기로 합니다. Refresh Token Rotation은 아래와 같이 Refresh Token을 이용해 Access Token을 갱신할 때 Refresh Token도 함께 갱신하여 Refresh Token 탈취 시 발생할 수 있는 위험을 회피합니다.\n\n이슈\n클라이언트의 네트워크 이슈\n앞서 저희는 Refresh Token Rotation을 이용하여 Refresh Token 탈취에 대한 위험성을 회피하고자 하였습니다. 이렇게 하면 Refresh Token을 이용하여 Access Token을 갱신 요청할 때 요청한 Refresh Token도 새롭게 발급되어 더 이상 Refresh Token을 사용할 수 없게 되는데요. 보안 수준은 강화되었지만, 클라이언트 개발자분들이 한가지 우려 점을 제기해 주셨습니다.\n모바일 기기 특성상 지하실이나 엘리베이터안과같이 네트워크가 원활하지 않은 곳에서 사용할 가능성이 존재하는데요. 이때 아래 그림과 같이 첫 번째 요청한 Refresh Token을 재요청하는 경우가 발생할 수 있습니다. 하지만 Refresh Token을 매번 갱신하기 때문에 동일한 Refresh Token으로 여러번 Access Token을 갱신요청하게 된다면 두번째 요청부터는  인증 에러가 발생하게 됩니다.\n\n그래서 저희는 Token Family 방식 을 사용하여 요청 시마다 기존 Refresh Token을 지우지 않고 과거 토큰을 저장해 두었다가 첫 번째 요청으로 새롭게 발급된 토큰 또는 모종의 이유로 인해 갱신하지 못한 기존 토큰으로 토큰 갱신 요청을 할 수 있도록 구현하여 Refresh Token을 재사용할 수 있도록 하였습니다.\n\n이로써 클라이언트는 네트워크 이슈가 발생해도 Refresh Token을 갱신할 수 있게 되었습니다.\n\n인증 토큰의 하위 호환\n한편, 저희는 JWT를 다루는 라이브러리로 JJWT 를 사용하고 있습니다. 앞서 JWT는 상태를 가지지 않기 때문에 사용자가 사용하는 Access Token을 서버에서 제어할 수 없다고 말씀드렸었는데요. 그래서 Access Token의 만료 시간을 두어 새롭게 Access Token을 발급받도록 하여 우회적으로 제어할 수 있습니다. Access Token을 만료시키는 또 다른 방법은, 해당 토큰을 생성할 때 사용된 암호키를 변경하는 것입니다. 저희는 그래서 클라이언트에서 사용하는 Access Token을 만료시키고 새롭게 변경된 권한을 사용하는 Access Token으로 사용하도록 하기 위해 암호키를 바꾸기로 하였습니다. 다만 여기서 발생하는 문제가 바로 앱의 업데이트 타이밍이었습니다.\n개발자라면 다들 잘 아시겠지만, 서버와 앱은 동일한 시점에 개발이 완료되더라도 배포되는 시점이 다를 수 있습니다. 서버는 배포하는 즉시 배포가 되지만 앱은 심사 과정이 필요하고 배포가 되더라도 앱스토어에 배포된 버전이 전파되기까지 1일 이상 소요될 수 있습니다. 그러다 보니 Access Token을 변경하기 위해 키를 변경하게 되면 서버가 배포된 이후부터 앱이 업데이트되기 전까지 사용자가 서비스를 이용할 수 없다는 문제가 생길 수 있습니다. 그래서 저희는 과거 버전의 앱에서도 새롭게 배포된 서버의 인증을 문제없이 사용할 수 있도록 방법을 모색해야 했습니다.\nJJWT 버전 변경\n한편, 저희는 비밀키를 바꾸는 김에, 과거에 사용하던 서명 알고리즘(HS256)에 비해 보안성이 강화된 서명 알고리즘(PS256)을 변경하기로 합니다. 그러다 보니 JJWT라이브러리 버전을 업그레이드해야 했는데요. Gradle에 아래처럼 동일한 라이브러리를 서로 다른 버전으로 사용하는 경우 패키지 충돌이 발생하여 신규 버전에서 제공하는 함수를 사용할 수 없게 됩니다.\n\n// 구버전\nimplementation(\"io.jsonwebtoken:jjwt:0.9.1\")\n\n// 신규버전\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\n\n이러한 문제를 해결하기 위해 저희는 Jitpack 을 사용하기로 합니다. JitPack은 GitHub에 호스팅된 라이브러리를 쉽게 빌드하고 배포할 수 있게 해주는 Maven/Gradle 용 리포지터리 서비스입니다. GitHub 저장소를 바탕으로 라이브러리를 빌드하므로, 별도의 중앙 저장소(예: Maven Central) 등록 과정을 거치지 않아도 된다는 장점이 있습니다. 그리고 오픈소스 저장소에, 한에 무료로 사용할 수 있다는 점도 장점입니다.\n저희는 JJWT 라이브러리를 fork하여 Spoqa용 JJWT Github 저장소 를 생성하였습니다. 그런 다음 충돌 패키지 충돌이 발생하지 않도록 패키지명을 변경해 주었습니다.\n\n그런 다음 Release를 생성해 주면, 아래와 같이 Jitpack에서 조회할 수 있게 됩니다.\n\n마지막으로 아래와 같이 Gradle에 의존성을 추가해주면, 패키지명이 변경된 JJWT라이브러리를 사용할 수 있게 됩니다.\n\nimplementation(\"com.github.spoqa:jjwt:1.0.2\")\nimplementation(\"javax.xml.bind:jaxb-api:2.3.1\")\n\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\nComposite 패턴 vs TokenManager\n저희는 Jitpack으로 생성한 과거버전의 JJWT를 의존하는 구현체를 아래와 같이 LegacyJwtProcessor로 변경하고 신규 버전을 사용하는 JwtProcessor를 새롭게 생성하였습니다. 그런 다음 아래와 같이 인증 로직에 과거 버전의 Access Token과 신규 버전의 Access Token을 모두 수용할 수 있도록 구현하였습니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val jwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal =\n            try {\n                jwtProcessor.getPrincipal(authentication.principal.toString())\n            } catch (e: AuthenticationException) {\n                legacyJwtProcessor.getPrincipal(authentication.principal.toString())\n            }\n\n        return JwtUserAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == JwtPreAuthenticationToken::class.java\n    }\n}\n\n\n이렇게 구현하면 앱이 배포되기 전에 서버가 먼저 배포되어도 기존 버전을 사용하는 사용자가 정상적으로 로그인을 유지할 수 있게 됩니다.\n한편, 인증 로직을 구현하는 곳 말고도 LegacyJwtProcessor를 사용하는 곳이 다수 존재하였는데요. 그러다 보니 새롭게 만들어진 JwtProcessor로 전환하는 것을 누락할 가능성이 존재하였습니다. 다행히 기능 테스트가 있어 놓친 구현을 바로잡을 순 있었지만, 코드의 응집성 측면에서는 좋은 코드는 아니라 생각하였습니다.\n그래서 Composite 패턴을 사용해서 아래와 같이 구현해 볼지 생각을 하였습니다.\n\ninterface JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String\n    fun getPrincipal(token: String): UserPrincipal\n}\n\nclass CompositeJwtProcessor(\n    private val newJwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: JwtProcessor,\n): JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n}\n\nclass NewJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\nclass legacyJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\n\nCompositeJwtProcessor를 이용하면 아래와 같이 JwtAuthenticationProvider는 더 이상 legacyJwtProcessor를 알지 않아도 되고 추후 legacyJwtProcessor가 제거되어도 영향범위는 CompositeJwtProcessor로 한정되기 때문에 응집도 높은 코드를 유지할 수 있게 됩니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val compositeJwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = compositeJwtProcessor.getPrincipal(authentication.principal.toString())\n\n        return JwtUserAuthenticationToken(principal)\n    }\n    \n    // 생략...\n}\n\n\n다른 방법으로는 TokenManager라는 상위 수준의 클래스를 만들어 응집도를 높이는 방법도 생각해 보았습니다.\n\n@Service\nclass TokenManager(\n    private val jwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val refreshTokenService: RefreshTokenService,\n) {\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n\n    fun generateAccessToken(userPrincipal: UserPrincipal): String {\n        // 생략...\n    }\n\n    fun generateRefreshToken(entity: RefreshToken): String {\n        // 생략...\n    }\n\n    fun replaceRefreshToken(principal: RefreshTokenUserPrincipal): String {\n        // 생략...\n    }\n}\n\n\n이렇게 하면 Token을 Composite 패턴을 사용한 것과 같이 하위호환을 지키는 코드와 함께 토큰과 관련된 다른 기능들도 해당 클래스로 모을 수 있어 응집도를 상당히 높일 수 있게 됩니다.\n어떤 방식이 더 나은 방식이라고 말씀드리긴 어려울 것 같습니다. 다만, 저희는 LegacyJwtProcessor는 앱 배포 이후에 제거될 클래스이므로 불필요하게 Composite 패턴을 사용하기보다 TokenManager를 생성하여 코드 응집도를 높이는 방법으로 결정하게 되었습니다.\nSpring Security - PreAuthorize\n저희는 인증과 인가를 위해 Spring Security를 사용하고 있습니다. JWT를 통해 인증된 사용자는 UserPrincipal이라는 인증된 사용자로 변환되고 UserPrinciapl이 가진 authorities를 통해 권한 처리를 하고 있습니다.\n\n@Component\nclass AccessTokenAuthenticationProvider(\n    private val tokenManager: TokenManager,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = tokenManager.getPrincipal(authentication.principal.toString())\n        return AccessTokenAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == AccessTokenPreAuthenticationToken::class.java\n    }\n}\n\nclass AccessTokenAuthenticationToken(\n    private val principal: UserPrincipal,\n) : AbstractAuthenticationToken(principal.authorities) {\n    init {\n        super.setAuthenticated(true)\n    }\n\n    override fun getPrincipal() = principal\n\n    override fun getCredentials() = null\n}\n\n\n사용자는 아래와 같이 @Secured를 통해 권한을 검증받고 API를 호출할 수 있습니다.\n\n@DgsMutation\n@Secured(STORE_ADMIN, STORE_MANAGER, VENDOR)\nfun createOrderSheet(\n    @InputArgument input: CreateOrderSheetInput,\n): CreateOrderSheet {\n    // 생략...\n}\n\n\n@Secured는 단순한 권한 Role 기반 접근을 제어하기에 적절합니다. 이전까지 키친보드는 관리자, 매장 사용자, 유통사 사용자로 명확하게 Role이 나뉘어져 있었기 때문에 @Secured는 요구사항을 충분히 충족하면서 단순하게 구현할 방법이었습니다.\n하지만 새로운 요구사항이 추가되면서 매장 사용자는 매장 관리자, 매장 직원으로 권한이 분리되게 되었는데요. 이에 따라 매장 사용자 모두 접근을 할 수 있는 API에는 아래와 같이 @Secured(STORE_ADMIN, STORE_MANAGER) 표현해야 하는 불편함이 있게 됩니다. 거기다 만약 STORE_INTERN이 추가된다면 매장 사용자 권한을 가져야 하는 API를 모두 찾아서 바꿔줘야 하니 상당히 번거로운 작업이 될 것이고 자칫 권한 변경을 누락할 수 있는 위험성 또한 내포하고 있습니다.\n이와 같은 문제를 해소하기 위해 Spring Security에서는 @PreAuthorize를 이용하여 유연하게 권한을 체크하는 기능을 제공합니다. 그래서 저희는 아래와 같이 매장 사용자 여부를 확인하는 서비스 함수를 만들어 SpEL 을 이용해 권한을 체크하도록 함으로써 권한을 일일이 나열하지 않고 새로운 권한이 생기더라도 유연하게 대처할 수 있도록 하였습니다.\n\n@PostMapping(\"/replace-store\")\n@PreAuthorize(\"@authorizationExpressionHelper.isManager()\")\nfun replaceStore(@RequestBody request: ReplaceStoreRequest): ReplaceStoreResponse {\n    // 생략...\n}\n\n@Service\nclass AuthorizationExpressionHelper {\n    fun isManager(): Boolean {\n        return PrincipalProvider.userPrincipal.isManager\n    }\n}\n\n\n마무리\n지금까지 저희가 권한 기능을 추가하기 위해 인증 로직을 어떻게 개선하였고 개선하면서 겪었던 이슈들을 공유해 보았습니다. 단순히 권한을 추가해 달라는 요구사항에서 시작되었지만, 그동안 우리가 가지고 있던 기술 부채도 해결함과 동시에 기술적인 여러 고민을 할 수 있어서 개인적으로 배운 게 많은 프로젝트였습니다.\n모쪼록 인증 기능 구현에 관심이 있으시거나 예정인 분들께 도움이 되었으면 합니다.\n긴 글 읽어주셔서 감사합니다.",
        "id": "https://spoqa.github.io/2025/04/18/improve-auth.html",
        "isoDate": "2025-04-18T00:00:00.000Z"
      }
    ]
  },
  {
    "name": "팀 왈도 번역팀",
    "category": "게임",
    "posts": []
  },
  {
    "name": "근원님",
    "category": "개인",
    "posts": []
  },
  {
    "name": "호돌맨",
    "category": "개인",
    "posts": []
  },
  {
    "name": "박우빈",
    "category": "개인",
    "posts": []
  },
  {
    "name": "문다영",
    "category": "개인",
    "posts": []
  },
  {
    "name": "유수민",
    "category": "개인",
    "posts": []
  },
  {
    "name": "안건주",
    "category": "개인",
    "posts": []
  },
  {
    "name": "손현호",
    "category": "개인",
    "posts": []
  },
  {
    "name": "STARTUP BIBLE",
    "category": "개인",
    "posts": [
      {
        "creator": "Kihong Bae",
        "title": "돈 버는 습관",
        "link": "https://www.thestartupbible.com/2025/04/profit-making-as-a-habit.html",
        "pubDate": "Wed, 16 Apr 2025 21:26:00 +0000",
        "content:encodedSnippet": "얼마 전에 우리의 오래된 투자사의 이사회 미팅에 참석했다. 아주 힘든 사업을 하고 있는데, 10년 전 창업할 땐, 창업가들도 이렇게 힘든 사업인 줄 몰랐고, 투자자들도 이렇게 힘든 사업인 줄 몰랐다. 그동안 실수도 많이 했고, 돈도 많이 까먹으면서 개고생했는데, 이제 회사가 어느 정도 안정적인 운영 방법을 찾았고, 그동안 마이너스 나는 사업을 하다가 작년부터 손익분기점을 넘으면서 흑자를 만들고 있다. 나도 이런 창업가들과 오랫동안 같이 일하다 보면 정말 많은 것을 느끼고 배운다. 사업에 대해서도 많이 배우지만, 실제론 인생에 대해서 정말 많이 배운다. 이런 힘든 사업을 무에서 시작해서 돈을 버는 과정을 옆에서 보다 보면, 가끔은 제삼자인 내가 토할 정도로 힘든 사업을 이분들은 어떻게 저렇게 버티면서 묵묵히 앞으로 나갈까,,,라는 존경심이 항상 생긴다. 어쨌든, 창업가 예찬은 다른 포스팅을 통해서 따로 하겠다.\n같은 이사회 멤버인 다른 투자자분이 이 회사가 드디어 돈을 벌기 시작한 것을 보고, “흑자를 내는 것도 습관입니다. 앞으로 계속 이 습관을 유지하세요.”라는 말씀을 했는데, 나도 이 말에 너무 격하게 공감했다. 사람은 습관의 동물이다. 일주일, 한 달, 일 년, 십 년의 반복을 통해서 만든 습관은 생활을 변하게 하고, 결국엔 인생을 바꿔놓는다. 습관을 만드는 것도 어렵고, 이후에 유지하는 것도 쉽지 않지만, 내 경험에 의하면 만드는 게 더 어렵다. 일단 한번 잘 만들어 놓으면, 몸이 기억하기 때문에 언제든지 이 습관을 불러 올 수 있다.\n회사가 돈 버는 것도 마찬가지다. 돈 버는 습관을 만드는 건 정말 어렵다. 하지만, 쓸데없는 짓 하지 않고, 거창한 스타트업 놀이하지 말고, 겉만 번지르르한 사업을 하지 않고, 그냥 매일, 일주일, 한 달, 일 년, 십 년 동안 어떻게 해서든지 돈을 벌기 위해서 노력하다 보면 돈 버는 게 습관화되고, 흑자를 내는 것도 습관이 된다. 한 번 만든 흑자는 두 번의 흑자를 만들고, 이는 평생의 흑자로 이어질 수 있는, 창업가들의 인생과 회사의 미래를 바꾸는 계기가 될 수 있다.\n얼마 전에 ‘슈퍼 마리오 효과‘라는 글을 썼는데, 돈을 버는 것도 이와 비슷한 맥락에서 생각해 볼 수 있다. 돈을 벌기 위해 수많은 시도를 해야 하고, 이를 계속 반복하다 보면, 실수를 많이 할 것이다. 실수하면, 우리 몸은 이 실수를 고치기 위해서 노력한다. 이 과정을 계속 반복하다 보면, 그리고 운이 좀 따른다면, 돈 버는 사업이 만들어지고, 이를 또한 계속 반복하다 보면 흑자가 만들어진다. 한 번 온몸으로 경험한 흑자 만드는 방법은 몸에 습관처럼 남기 때문에, 앞으로 이를 계속 반복할 가능성이 커진다.\n이는 마치 운동선수의 우승과 비슷하다. 이겨본 놈이 계속 이길 수 있다는 말을 우린 자주 하는데, 시합에서 한 번 이긴 선수는 승리의 자신감이 생기는데, 이 자신감은 뇌 일부분을 자극하고, 이 부분이 자극받으면 반복적으로 우승할 수 있다.\n흑자를 내는 것도 습관이다. 스타트업 놀이 말고, 돈 버는 걸 습관으로 만들어라.",
        "dc:creator": "Kihong Bae",
        "comments": "https://www.thestartupbible.com/2025/04/profit-making-as-a-habit.html#respond",
        "content": "얼마 전에 우리의 오래된 투자사의 이사회 미팅에 참석했다. 아주 힘든 사업을 하고 있는데, 10년 전 창업할 땐, 창업가들도 이렇게 힘든 사업인 줄 몰랐고, 투자자들도 이렇게 힘든 사업인 줄 몰랐다. 그동안 실수도 많이 했고, 돈도 많이 까먹으면서 개고생했는데, 이제 회사가 어느 정도 안정적인 운영 방법을 찾았고, 그동안 마이너스 나는 사업을 하다가 작년부터 손익분기점을 넘으면서 흑자를 만들고(...)",
        "contentSnippet": "얼마 전에 우리의 오래된 투자사의 이사회 미팅에 참석했다. 아주 힘든 사업을 하고 있는데, 10년 전 창업할 땐, 창업가들도 이렇게 힘든 사업인 줄 몰랐고, 투자자들도 이렇게 힘든 사업인 줄 몰랐다. 그동안 실수도 많이 했고, 돈도 많이 까먹으면서 개고생했는데, 이제 회사가 어느 정도 안정적인 운영 방법을 찾았고, 그동안 마이너스 나는 사업을 하다가 작년부터 손익분기점을 넘으면서 흑자를 만들고(...)",
        "guid": "https://www.thestartupbible.com/?p=9428",
        "categories": [
          "Uncategorized",
          "FoundersAtWork",
          "hustle",
          "inspiring",
          "sports",
          "Strong"
        ],
        "isoDate": "2025-04-16T21:26:00.000Z"
      },
      {
        "creator": "Kihong Bae",
        "title": "면접의 허상",
        "link": "https://www.thestartupbible.com/2025/04/stop-wasting-too-much-energy-on-interviews.html",
        "pubDate": "Sun, 13 Apr 2025 21:33:00 +0000",
        "content:encodedSnippet": "이 세상을 세상답게 돌아가게 하는 단 한 가지만 꼽으라면, 그건 ‘사람’이라고 할 수 있다. 사람이 사람과 일하고, 사람이 사람과 교류하면서 이 세상은 돌아가고, 더 좋은 세상으로 발전한다. 회사도 마찬가지다. 특히, 스타트업에서 가장 중요하고, 절대로 타협할 수 없는 단 한 가지만 선택하면, 그건 당연히 사람이다. 대표이사는 시간의 50%는 좋은 사람을 채용하는 데 사용해야 하고, 나머지 50%는 있는 사람들이 퇴사하지 않도록 하는 데 사용해야 한다. 지금 내가 채용하는 사람이 우리 회사 그 자체라는 점을 항상 명심해야 한다.\n그래서 우린 면접에 많은 공을 들인다. 면접의 방법도 갈수록 진화하고 있고, 더 좋은 사람을 채용하기 위한 노력의 하나로 면접의 횟수와 시간이 계속 늘어나고 있다. 얼마 전에 아는 분이 외국계 대기업의 시니어 매니저 레벨의 직책에 지원했는데, 6개월 동안 12번의 면접을 했다고 한다. 그런데 막판에 떨어졌다. 면접의 종류도 코딩하기, 케이스 풀기부터 술 마시기까지 정말 다양하게 세분되고 있다. 대기업들은 회사에 가장 적합한 인재 채용을 위한 면접 매뉴얼을 개발하기 위해 수억 원의 돈을 쓰면서 외부 컨설팅까지 받는다.\n그래서 우린 이런 고도화 된 면접 방법을 통해서 정말 더 좋은 사람을 채용하고 있을까? 개인적으로 봤을 땐, 아닌 것 같다. 내 개인적인 경험을 이야기해 보면, 면접을 아무리 잘해도, 이분이 실무는 정말 못 했던 적도 있고, 혼자서는 일을 잘 하는데 팀원들과 같이 했을 땐 팀워크 능력은 현저하게 떨어졌던 적도 있었다. 그리고 이건 내 주변의, 나보다 훨씬 더 많은 사람들을 면접하고 채용하는 매니저들도 비슷한 이야기를 한다. 면접을 20번 해도 그 사람이 실제로 일을 잘하는진 알 수 없고, 실제로 일을 잘해도, 우리 회사에서 일을 잘할 수 있을진 알 수가 없다.\n이게 면접의 현실이다. 면접은 단기간 안에 극적으로 향상할 수 있는 기술이기도 하고 – 입시 학원처럼, 면접 학원도 있다 – 일은 못 해도 말발만 살아 있으면, 면접에선 100점을 받을 수도 있기 때문이다.\n그럼 도대체 사람을 어떻게 채용해야 할까? 내가 아는 세 가지 방법이 있다.\n첫 번째 방법은, 일단 내가 잘 아는 사람만 채용하는 방법이다. 오래된 친구, 대학교 룸메이트, 동아리 선후배, 직장 동료나 선후배가 좋은 사례다. 우리가 투자한 회사 중 이렇게 오랫동안 서로를 알고 지낸 분들이 공동 창업가나 동료로 일하는 곳들이 큰 불협화음 없이 잘하는 걸 자주 경험한다. 하지만, 사람의 네트워크라는 게 한계가 있고, 회사가 성장하면 잘 아는 사람의 인재풀은 바닥나기 때문에 이 방법은 회사 규모가 작을 때만 작동한다.\n두 번째는, 6개월의 수습 기간을 갖고, 이후에 정식 채용을 결정하는 것이다. 면접을 아무리 잘해도 이분이 실제 일을 잘하는진 현장에서 확인해야 하는데, 2개월 정도의 수습은 약간 애매하다. 2개월 정도는 일을 잘하는 척 연기할 수도 있다. 하지만, 6개월을 연기하긴 어렵다. 6개월 같이 일해보면, 이분이 정말 일을 잘하는 분인지 충분히 파악된다. 또한, 일을 잘하는 분도 본인이 회사와 케미가 맞는지 판단해 봐야 하므로 6개월 정도의 수습 기간을 권장한다. 이런 제안에 격하게 반대하는 후보라면, 그리고 그 이유로 자존심과 모욕감 등을 언급하면 이건 적신호다.\n마지막 방법은, 채용보단 보상에 대한 방법이다. 내가 전에 이 글에서 이야기했는데, 면접을 기반으로 직책과 연봉을 결정하는 게 너무 어렵고 위험한 방법이기 때문에, 입사 시 ‘one 직책 one 연봉’ 제도를 도입하는 것이다. 이게 무슨 말이냐 하면, 컴공과를 막 졸업한 25살 엔지니어든, 15년 개발 경력이 있는 엔지니어든, 새로운 회사에 입사할 때 직책이 둘 다 시니어 소프트웨어 엔지니어라면, 이 두 분의 입사 연봉은 무조건 동일하게 가는 전략이다. 같은 직책이라도 과거의 경험이 많으면 연봉이 더 높고, 특히나 면접 때 말을 잘하면 연봉이 훨씬 더 높아지는 게 현대 사회의 채용 전략인데, 나는 이건 완전히 틀렸다고 본다. 경력이 많다고 그 일을 잘하는 건 절대로 아니고 – 오히려 그 반대의 경험을 정말 많이 했다 – 면접 때 말발에서 이기는 사람이 일을 더 잘하는 게 절대로 아니다. 그래서 입사할 땐 모두 다 연봉을 동일하게 가져가지만, 일 년 후 업무 평가에서 실제로 일을 더 잘하는 사람에게 연봉을 드라마틱하게 인상해 주는 방법이 좋은 사람을 계속 회사에 남게 하고, 아닌 사람은 퇴사하게 할 수 있는 좋은 방법이라고 생각한다.\n정답은 아니지만, 위 3개의 방법을 적절하게 활용하면 피곤한 면접 횟수는 줄일 수 있고, 더 좋은 인재를 채용할 수 있다. 실은, 어쩌면 한국은 사람을 해고하는 게 너무 힘들어서 안 내보낼 사람을 채용하기 위해서 면접을 더 중시하고, 더 신중하게 생각할지도 모르겠다. 한국의 경직된 해고 정책은 반드시 바꿔야 한다고 나는 개인적으로 생각한다.\n어쨌든, 이렇게 면접하고, 다양한 채용 방법을 사용하는 이유는 좋은 사람을 확보하기 위해서다. 좋은 사람이란 일을 잘하는 사람인데, 일을 잘하는 사람이란, 일이 주어지면, 그 일을 직접 할 수 있는 사람이다. 일이 주어지면, 그 일을 하기 위해서 사람을 또 채용하는 사람이 아니라.",
        "dc:creator": "Kihong Bae",
        "comments": "https://www.thestartupbible.com/2025/04/stop-wasting-too-much-energy-on-interviews.html#comments",
        "content": "이 세상을 세상답게 돌아가게 하는 단 한 가지만 꼽으라면, 그건 ‘사람’이라고 할 수 있다. 사람이 사람과 일하고, 사람이 사람과 교류하면서 이 세상은 돌아가고, 더 좋은 세상으로 발전한다. 회사도 마찬가지다. 특히, 스타트업에서 가장 중요하고, 절대로 타협할 수 없는 단 한 가지만 선택하면, 그건 당연히 사람이다. 대표이사는 시간의 50%는 좋은 사람을 채용하는 데 사용해야 하고, 나머지 50%는(...)",
        "contentSnippet": "이 세상을 세상답게 돌아가게 하는 단 한 가지만 꼽으라면, 그건 ‘사람’이라고 할 수 있다. 사람이 사람과 일하고, 사람이 사람과 교류하면서 이 세상은 돌아가고, 더 좋은 세상으로 발전한다. 회사도 마찬가지다. 특히, 스타트업에서 가장 중요하고, 절대로 타협할 수 없는 단 한 가지만 선택하면, 그건 당연히 사람이다. 대표이사는 시간의 50%는 좋은 사람을 채용하는 데 사용해야 하고, 나머지 50%는(...)",
        "guid": "https://www.thestartupbible.com/?p=9426",
        "categories": [
          "Uncategorized",
          "FoundersAtWork",
          "general",
          "people",
          "strategy",
          "스타트업 바이블 1",
          "스타트업 바이블 2",
          "스타트업 바이블 QA"
        ],
        "isoDate": "2025-04-13T21:33:00.000Z"
      }
    ]
  },
  {
    "name": "매거진 입맛",
    "category": "큐레이션",
    "posts": []
  },
  {
    "name": "요즘 IT",
    "category": "큐레이션",
    "posts": []
  },
  {
    "name": "지마켓 기술 블로그",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Kimchi hill",
    "category": "큐레이션",
    "posts": []
  },
  {
    "name": "Hudi.blog",
    "category": "개인",
    "posts": []
  },
  {
    "name": "토스",
    "category": "기업",
    "posts": [
      {
        "title": "치킨은 어떻게 우리나라의 소울푸드가 됐을까?",
        "link": "https://blog.toss.im/article/behindthemoney-11",
        "pubDate": "Fri, 18 Apr 2025 03:34:00 GMT",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}치킨값이 또 올랐다\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1kxrhf3{white-space:pre-wrap;}만 원 짜리 세장. 이제 그 정도는 있어야 치킨 한 마리를 먹을 수 있다. 치킨 브랜드들이 2,000~3,000원씩 앞다투어 가격을 올리며 ‘치킨 인플레이션’이 다시 화제다. 치킨값이 오를 때마다 뉴스는 빠르게 보도하고, 우리는 분노한다. \n치킨값에 유독 여론이 뜨거운 것은 그만큼 치킨이 우리 삶에서 중요한 음식이자 문화가 되었음을 말해준다. 그런데 우리는 어쩌다 이렇게까지 치킨을 사랑하게 된 걸까? 한국 치킨의 대중화는 단순 우연이 아닌 경제성장과 맞물린 문화·산업적 산물이기도 하다.\n통닭이 치킨이 되기까지\n.css-16cuouw{white-space:pre-wrap;color:var(--adaptiveGrey800);background-color:#3fd59936;}부위별로 조각내 튀긴 ‘치킨’의 시작은 70년대로 거슬러 올라간다. 한국 최초의 치킨 프랜차이즈로 알려진 ‘림스치킨’은 1975년 설립되어 1977년 명동 신세계백화점에 1호점을 열었다. 요즘으로 치면 더현대같은 핫플레이스에 입점한 셈일 것이다. 당시의 정확한 가격은 찾기 어렵지만, 대략 2,000원 정도였다고 한다.\n닭은 네 조각으로 잘라 ‘3G 파우더’를 묻혀 튀겼다. 마늘(Garlic), 생강(Ginger), 인삼(Ginseng)이 들어가 ‘3G 파우더’라고 불렀다. 지금 기준에서 보면 특별할 게 없지만, 림스치킨이 등장하기 전까지 한국에는 닭을 조각내거나 튀김옷을 입힌 치킨이 흔치 않았다. 1980년대까지만 하더라도 전기구이 통닭이 일반적이었기 때문이다.\n치킨을 만들기 위해서는 튀김가루를 묻히고, 물반죽을 입힌 후, 다시 튀김가루를 묻히는 등 전용 가루 씽크대인 ‘브레딩 테이블’이 필요했는데 설비 투자에 만만치 않은 돈이 필요했다. 더구나 통닭을 적당한 크기로 자르고 튀기는 과정 또한 전용 튀김 용기가 필요했고 기름도 훨씬 많이 써야만 했다. \n이러한 이유로 옛 영화나 드라마에서 흔히 볼 수 있는 ‘월급날 아빠가 사 오는 누런 종이봉투에 통째로 담긴 닭 한 마리’. 이 기름 한 방울 없이 구워낸 전기구이 통닭이 국민적인 인기를 누리고 있던 시대, 치킨은 혜성처럼 등장했다.\n닭이 튀김옷을 입을 수 있었던 이유\n치킨이 처음부터 서민 음식이었던 것은 아니다. 짜장면 한 그릇에 600~700원, 경양식집 돈가스는 1,300~1,400원 하던 1988년. 치킨 한 마리는 약 4,000~5,000원으로 짜장면과 돈가스보다 몇 배나 비쌌다. 심지어 짜장면과 돈가스도 생일이나 졸업식, 소풍 등 특별한 날에나 맛볼 수 있는 귀한 음식이었다.\n그럼에도 불구하고 치킨의 시대는 다가오고 있었다. 배경에는 1980년대 경제적 고도성장이 있다. 경제가 빠르게 성장하며 양계 산업 또한 번성했기 때문이다. 1970년, 1.4kg이었던 국민 1인당 닭고기 소비량은 1980년, 6.9kg으로 급격히 증가했다. 10년 사이 닭고기 소비량이 5배나 늘어난 것이다.\n사실 닭고기가 한국의 입맛을 사로잡은 역사는 길지 않다. 조선 시대 백성들이 가장 사랑하던 고기는 소고기였고, 조선 후기에도 닭보다는 꿩사냥이 흔했다. 닭을 체계적으로 사육하는 시설이 들어선 것은 일제 강점기였고, 1960년대가 되어 과학적인 영농을 통해 대량생산이 가능한 단계에 들어서게 됐다. \n그리고 1980년대 경제성장의 성과를 고기를 구워먹는 것으로 누렸던 우리 국민들은 기름을 사용한 음식에 빠르게 적응해 나갔다. 치킨부터 삼겹살까지 현대 한국인의 육류 소비는 대부분 산업화 이후의 새로운 식습관이었다.\n양념치킨의 등장\n특히 1986~1988년까지, GDP 성장률은 3년 연속 두 자릿수를 찍으며 한국 경제는 고도성장을 이루었다. 경제성장과 함께 닭을 향한 한국인의 입맛 또한 나날이 발전했다. 엠보형 치킨, 크리스피형 치킨, 민무늬형 치킨 등 다양한 튀김옷 스타일이 개발되었고 ‘림스치킨’을 통해 이제 통닭이 아닌 ‘치킨’이라는 이름으로 상품화가 이루어졌다. 그리고 마침내 양념치킨이 등장한다.\n.css-1odxvuk{white-space:pre-wrap;font-style:italic;}1984년 당시, 대구먹자골목에서는 통닭과 찍어 먹는 소스를 함께 내주곤 했었습니다. 대전에서 페리카나를 운영하고 있던 페리카나 치킨 창립자 양희권 회장은 찍어 먹는 소스를 보고 문득 소스를 찍어 먹는 대신 치킨에 버무리면 어떨까라는 생각이 들었다고 합니다... 한국인의 입맛에 가장 잘 맞는 고추장, 마늘, 양파, 물엿, 마요네즈 등을 사용해서 양념을 개발하였으며 양념 소스를 묻혔을 때 맛이 더 잘 배는 얇은 튀김옷의 후라이드를 고수하여 양념치킨의 맛을 현재까지 유지할 수 있도록 노력하고 있습니다.\n- 페리카나 양념치킨 홈페이지 \n변화는 과감했다. 통닭에 튀김옷을 입힌 지 10년 만에 한국인들은 우리만의 치킨 제조법을 발전시켰다. 1984년 대구먹자골목에서는 고추장소스를 듬뿍 발라 양념치킨을 만들어냈다. ‘맛이 더 잘 배는 얇은 튀김옷’과 양념소스의 결합. 이때부터 한국의 치킨 산업은 독자적인 길을 걷기 시작한다. \n그리고 고추장에서 시작한 양념치킨은 곧 전국으로 퍼져 다양한 치킨 브랜드로 확대된다. 멕시칸 치킨, 처갓집 양념통닭, 이서방 양념통닭, 스모프 양념통닭 등 전문 브랜드들이 줄줄이 생기며 치킨이 ‘브랜드’로서 대중에게 각인되기 시작했다.\nIMF와 치킨 프랜차이즈의 질주\n90년대 교촌치킨(1991), 지코바(1994), BBQ(1995) 등 대표 브랜드가 등장하며 본격적으로 치킨 프랜차이즈 사업이 시작되었다. 꼭 치킨뿐만은 아니었다. 88년 압구정에 1호점을 내며 한국에 상륙한 맥도날드는 1990년대가 되어 국민 소비 수준이 높아지며 매장 수도 급속도로 늘어갔다. 종로김밥, 김가네 같은 브랜드 역시 이 무렵 등장했으니 90년대는 프랜차이즈 시대라고 해도 과언이 아닐 것이다.\n프랜차이즈 시대는 ‘치킨’이 단순한 음식에서 산업, 창업 모델로 진화한 시기이기도 하다. 특히, 1997년 외환위기는 아이러니하게도 치킨 산업에 기회가 되었다. 20세기 말의 대한민국은 휘청였고, 수많은 가장들이 거리로 몰려나왔다. 이들은 치킨집 창업을 통해 제2의 인생을 시작했다. 치킨집에 대한 서민적 이미지가 극대화된 것 도 이 시기이며, 자조적 농담처럼 말하는 ‘기승전치킨집’의 실제 사례이기도 하다. BBQ는 IMF 이후 치킨 프랜차이즈 열풍을 몰아 창업 4년 만인 1997년 가맹점 1,000개를 돌파했다. 류승룡 배우가 수많은 치킨집 사장님 연기를 하게 된 것은 결코 우연이 아니었다.\n한국인에게 치킨은 간식, 술안주 그 이상\n2000년대에 들어서며 치킨은 단순한 음식이 아닌 콘텐츠로 자리 잡았다. 사장님 부부가 직접 닭을 튀기고 배달까지 하는 동네 치킨집은 비교적 저렴한 가격으로 사랑받고, 간장 치킨, 파닭 같은 새로운 메뉴와 컨셉을 앞세운 신생 브랜드들도 빠르게 인기를 끌었다.\n브랜드들은 소녀시대, 전지현 같은 유명 연예인을 모델로 내세워 공격적인 마케팅에 나섰고, BBQ는 ‘치킨대학’을 만들어 창업 경험이 없는 일반인을 위한 외식 교육까지 시작했다. 치킨은 예능 프로그램의 소재가 되기도 하며 하나의 콘텐츠로 확장되었다.\n한국인에게 치킨은 단순한 간식이나 술안주가 아닐 것이다. 한 달 간 고생한 나와 가족에게 주는 소소한 보상이 되기도 하고, 고된 하루를 위로하는 낙이 되기도 하며, 누군가의 삶을 다시 일으킨 창업 아이템이 되기도 한다. 특정한 음식이 이토록 한국인의 삶과 문화를 대변한 적이 있었을까? 아마 김장문화 이후로, 치킨만큼 한국인의 애환과 삶을 상징하는 음식도 드물 것이다.\n최근에는 파리, 뉴욕 등에서 한국치킨이 유행하고 있다는 소식이 심심치 않게 들려온다. 불과 50년 만에 한국은 치킨 선진국이 되었고, 글로벌 시장에서도 주목받고 있다. 앞으로는 또 어떤 변화가 일어날까. 치킨처럼, 혹은 그 이상으로 또 다른 음식이 새로운 문화와 산업으로 진화할 수 있을까? 맛을 향한 한국인의 집요한 사랑은 앞으로도 수많은 이야기를 만들어갈 것이다.\n.css-1ifza5r{border:0;margin-top:0;margin-bottom:0;height:1px;opacity:1;background:var(--tHairlineBackground);margin:0;}\nEdit 이지영 Graphic 이은호",
        "content": "치킨으로 읽는 한국 경제와 문화",
        "contentSnippet": "치킨으로 읽는 한국 경제와 문화",
        "guid": "https://blog.toss.im/article/behindthemoney-11",
        "isoDate": "2025-04-18T03:34:00.000Z"
      },
      {
        "title": "2025 청년 목돈 마련 위한 정책 총정리: 청년 도약계좌부터 장병 내일 준비적금까지 ",
        "link": "https://blog.toss.im/article/money-policies-39",
        "pubDate": "Fri, 18 Apr 2025 01:29:00 GMT",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}1.청년 도약계좌\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1kxrhf3{white-space:pre-wrap;}19~34세 청년이 목돈을 만들 수 있도록 정부가 지원하는 금융 상품입니다. 5년(60개월) 동안 매월 70만 원 한도 내에서 자유롭게 납입하면 매월 최대 33,000원을 정부가 지원해요.\n.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n대상: 개인소득(연소득 총급여 기준 7,500만 원 이하) 및 가구소득(기준 중위소득 250%이하)를 충족하는 19~34세 이하 청년\n.css-18442ym{font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}.css-jfs1hr{white-space:pre-wrap;font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}연령 계산 시 병역이행기간은 포함되지 않아요.(최대 6년)\n지원내용: 본인 납입액(월 최대 70만 원)에 대한 정부 기여금 지원(월 최대 3만 3,000원) 및 이자소득 비과세\n연소득 총급여 기준 6,000만 원 이상은 비과세만 지원해요.\n신청방법: 청년도약계좌 협약은행* 앱에서 비대면 신청\n*국민, 신한, 우리, 하나, 농협, 기업, 부산, 광주, iM, 경남, 전북\n\n\n\n2. 장병 내일 준비적금\n병역의무를 이행 중인 장병들이 목돈을 모을 수 있도록 돕는 상품이에요. 월 최대 55만 원을 적금할 수 있고, 정부가 납입 금액의 100%를 추가 지원 해줍니다.\n\n\n대상: 장병내일준비적금 가입 후 만기해지한 병역의무이행자\n지원내용: 본인 저축액(월 최대 55만 원)+5% 수준 은행이자(비과세)+원금의 100%매칭 지원금(비과세)\n지원시기: 병역의무이행자의 전역(소집해제)으로 장병 내일 준비적금 만기 해지 시\n신청방법: .css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}나라사랑포털, 사회복무포털, e-병무지갑 앱을 통해 ‘가입 자격 확인서’ 발급 후 은행*에 가입신청\n*농협, 신한, 우리, 하나, 기업, 국민, 수협, 대구, 부산, 광주, 제주, 전북, 경남, 우정사업본부\n\n\n\n3. 청년 일자리 도약 장려금\n중소기업에서 18개월 이상 장기근속한 청년에게 2년간 최대 480만 원을 지원합니다.\n\n\n대상: 5인 이상의 제조업 등 빈일자리 업종*의 우선지원대상기업 및 해당 기업에 취업 후 18개월 이상 재직한 청년\n*제조업, 조선업, 뿌리산업, 보건복지업, 해운업, 수산업 등\n지원 내용: 근로자에게 18개월 이상 재직 시, 2년간 최대 480만 원 지원 (18개월, 24개월 차 각 240만 원씩 지원)\n신청방법: 고용24에서 기업이 신청 가능\n문의\n\n고용24에서 청년일자리도약장려금 운영기관 검색 > 사업장 소재지의 운영기관 문의\n고용노동부 고객상담센터(1350)\n\n\n\n\n4. 청년 내일저축계좌\n저축한 금액보다 더 많은 지원금을 적립해 청년이 목돈을 마련할 수 있도록 지원합니다.\n\n\n대상\n\n19~34세 청년 (수급자·차상위자는 15~39세까지 허용)\n근로·사업소득: 월 50만 원 초과~250만 원 이하(수급자·차상위자는 월 10만 원 이상)\n가구소득: 기준 중위소득 100% 이하\n\n\n지원내용: 본인 저축액(월 10만 원 이상) + 근로소득장려금(정부지원금 10만 원)*\n*수급자·차상위 청년은 정부지원금 30만 원\n신청방법: 복지로포털 또는 주소지 행정복지센터\n문의: 보건복지상담센터(129), 자산형성지원콜센터(1522-3690)\n\n.css-1ifza5r{border:0;margin-top:0;margin-bottom:0;height:1px;opacity:1;background:var(--tHairlineBackground);margin:0;}\nEdit 이지영 Graphic 조수희 이제현",
        "content": "목돈 마련을 위한 대표적인 청년정책 모아보기  ",
        "contentSnippet": "목돈 마련을 위한 대표적인 청년정책 모아보기",
        "guid": "https://blog.toss.im/article/money-policies-39",
        "isoDate": "2025-04-18T01:29:00.000Z"
      },
      {
        "title": "토스, 보험사와 동일한 자동차 보험료로 비교·추천",
        "link": "https://blog.toss.im/article/automobile_",
        "pubDate": "Fri, 18 Apr 2025 00:00:00 GMT",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}내일부터 토스 앱에서 보험사와 동일한 자동차 보험료 확인 가능\n조회만 해도 토스포인트 50원 지급...토스페이로 결제 시 일부 상품에 한해 최대 3만 원 할인 지원\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n\n토스(운영사 비바리퍼블리카, 대표 이승건)가 19일부터 자사 앱에서 각 보험사 온라인 채널(CM)과 동일한 자동차 보험료를 안내한다고 밝혔다.\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}\n이는 금융위원회의 ‘자동차보험 비교추천 서비스 2.0’ 정책에 따라 구현된 서비스로, 토스가 업계에서 가장 먼저 선보였다. 이번 개편으로 소비자는 보험사 온라인 채널과 토스에서 동일한 요율의 자동차 보험료를 비교하고 가입할 수 있다.\n토스는 삼성화재다이렉트보험, DB손해보험, 현대해상다이렉트보험, KB손해보험, 메리츠화재보험, 캐롯손해보험, AXA다이렉트보험, 하나손해보험, 흥국화재보험, 롯데손해보험 등 총 10곳의 주요 보험사와 제휴를 맺고 있어, 다양한 상품을 한눈에 비교하고 추천받을 수 있다.\n보험료 비교뿐 아니라 다양한 할인 특약도 토스 앱에서 바로 확인 가능하다. △대중교통 △내비게이션 앱 △자동차 부속품 △자녀 유무 등 운전자 조건에 따라 달라지는 할인 항목들을 손쉽게 선택할 수 있으며, 특히 토스 만보기를 이용 중이라면 별도 앱 설치 없이 걸음 수 기반 할인도 받을 수 있다.\n‘차 보험 비교하기’ 서비스를 이용하는 고객을 위한 추가 혜택도 마련됐다. 보험료를 조회하는 고객에게는 최초 1회에 한해 토스포인트 50원을 지급하며, 신차 구매자와 보험 갱신 대상자, 4월 21일 이전에 보험 비교·추천 서비스를 이용한 사용자 모두가 대상이다. 토스에서 자동차 보험을 비교한 뒤 토스페이로 결제하면 일부 상품에 한해 최대 3만 원까지 보험료 할인을 받을 수 있다.\n이 서비스는 토스 앱 > 전체 탭 > 자동차 > ‘차 보험 비교하기’ 또는 토스 앱 > 검색(돋보기) > ‘차 보험 비교하기’로 이용 가능하다.\n토스 관계자는 “자동차 보험은 운전을 하는 대한민국 운전자라면 누구나 가입해야 하는 의무 보험으로, 전체 국민의 약 절반이 매년 보험을 가입하고 있다”며 “앞으로도 보다 편리한 비교·추천 서비스와 풍성한 혜택을 제공할 수 있도록 지속적으로 서비스를 고도화해 나가겠다”고 밝혔다.",
        "content": "19일부터 일괄 적용",
        "contentSnippet": "19일부터 일괄 적용",
        "guid": "https://blog.toss.im/article/automobile_",
        "isoDate": "2025-04-18T00:00:00.000Z"
      }
    ]
  },
  {
    "name": "모나미",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김진홍",
    "category": "개인",
    "posts": []
  }
]