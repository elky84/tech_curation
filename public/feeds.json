[
  {
    "name": "ㅍㅍㅅㅅ",
    "category": "큐레이팅",
    "posts": []
  },
  {
    "name": "C++ Team Blog",
    "category": "기업",
    "posts": [
      {
        "creator": "Sy Brand",
        "title": "Pure Virtual C++ 2025: Full Schedule",
        "link": "https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2025-full-schedule/",
        "pubDate": "Tue, 15 Apr 2025 12:15:38 +0000",
        "content:encodedSnippet": "Pure Virtual C++ is our free, one-day, virtual conference for the whole C++ community. This year, it is running on the 30th April. We’re pleased to announce the schedule of live talks:\n14:00 UTC: Welcome to v1.0 of the meta::[[verse]]! with Inbal Levi\n14:30 UTC: Proxy: Next Generation Polymorphism with Mingxin Wang\n15:00 UTC: Making unfamiliar C++ code familiar with GitHub Copilot with Sinem Akinci\n15:30 UTC: C++ Modules Myth Busting with Cameron DaCamara\n16:00 UTC: constexpr everything?! with Hana Dusíková\nYou can find abstracts for all the talks and register for the conference with the button below.\nKeep an eye out for on-demand pre-conference content coming soon on YouTube.\nRegister for Free\n\nThe post Pure Virtual C++ 2025: Full Schedule appeared first on C++ Team Blog.",
        "dc:creator": "Sy Brand",
        "comments": "https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2025-full-schedule/#respond",
        "content": "<p>Pure Virtual C++ is our free, one-day, virtual conference for the whole C++ community. This year, it is running on the 30th April. We&#8217;re pleased to announce the schedule of live talks: 14:00 UTC: Welcome to v1.0 of the meta::[[verse]]! with Inbal Levi 14:30 UTC: Proxy: Next Generation Polymorphism with Mingxin Wang 15:00 UTC: Making [&#8230;]</p>\n<p>The post <a href=\"https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2025-full-schedule/\">Pure Virtual C++ 2025: Full Schedule</a> appeared first on <a href=\"https://devblogs.microsoft.com/cppblog\">C++ Team Blog</a>.</p>\n",
        "contentSnippet": "Pure Virtual C++ is our free, one-day, virtual conference for the whole C++ community. This year, it is running on the 30th April. We’re pleased to announce the schedule of live talks: 14:00 UTC: Welcome to v1.0 of the meta::[[verse]]! with Inbal Levi 14:30 UTC: Proxy: Next Generation Polymorphism with Mingxin Wang 15:00 UTC: Making […]\nThe post Pure Virtual C++ 2025: Full Schedule appeared first on C++ Team Blog.",
        "guid": "https://devblogs.microsoft.com/cppblog/?p=35386",
        "categories": [
          "C++"
        ],
        "isoDate": "2025-04-15T12:15:38.000Z"
      }
    ]
  },
  {
    "name": "Facebook Engineering",
    "category": "기업",
    "posts": []
  },
  {
    "name": "eBay Tech Blog",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Twitter Blog",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Visual Studio Blog",
    "category": "기업",
    "posts": [
      {
        "creator": "Merrie McGaw, Shyam Gupta",
        "title": "Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer",
        "link": "https://devblogs.microsoft.com/visualstudio/toolbox-support-for-explicit-assembly-references-in-windows-forms-out-of-process-designer/",
        "pubDate": "Thu, 17 Apr 2025 14:45:27 +0000",
        "content:encodedSnippet": "Visual Studio 17.14 Preview 3 introduces a new feature that enhances the Windows Forms out-of-process designer experience for .NET Framework projects. This release brings Toolbox support for Explicit Assembly References, addressing a long-standing need in legacy application development and migration workflows.\n\nWhat Are Explicit Assembly References?\nExplicit Assembly References are stand-alone assemblies directly referenced in your project. They are not pulled in through NuGet packages, project references, or the Global Assembly Cache (GAC). These assemblies often represent legacy .NET Framework components, especially those compiled for 32-bit, which are not easily upgraded to modern .NET and may exist outside of package management.\nUntil now, the Toolbox in the Windows Forms designer only displayed controls sourced from NuGet packages or project references. This created a limitation for developers working with long-standing legacy codebases. Explicit Assembly References were invisible to the Toolbox, leading to a fragmented experience and reduced productivity, particularly during modernization efforts.\nWhy This Matters\nDevelopers relying on legacy Windows Forms controls often face challenges due to this limitation. The traditional approach of using the “Choose Items…” dialog in the Toolbox for in-process designer fails entirely for 32-bit assemblies as those assemblies cannot be loaded in 64-bit Visual Studio.\nIn response, we have extended Toolbox support to automatically fetch controls’ information from Explicit Assembly References. This allows developers to use their legacy controls within the modern out-of-process designer, removing a key blocker in migration and maintenance workflows.\nHow It Works\nWhen you launch the Windows Forms out-of-process designer for a .NET Framework project, the designer now automatically scans all references in the solution. It identifies Explicit Assembly References without loading them into Visual Studio itself. Leveraging the Roslyn APIs, the designer analyzes metadata to extract Toolbox item information from these assemblies.\nThis approach ensures that eligible controls appear in the Toolbox—ready for drag-and-drop just like those from NuGet or project references.\nImportant Caveats\nThe out-of-process designer uses a new extensibility model, which clearly separates design time and runtime assemblies. This separation is crucial for enabling advanced design time scenarios like custom CodeDomSerializer usage, specialized UITypeEditor implementations, and custom TypeConverter behaviors.\nExplicit Assembly References do not support this separation. As a result, all such assemblies are treated as runtime only, which limits their design time functionality. While basic Toolbox and control instantiation scenarios will work, advanced behaviors may not function as expected.\nFor the best experience, especially when working with custom design-time features, we strongly recommend using NuGet packages that follow the specified layout for runtime and design-time separation.\nConfiguring the Feature\nThis feature is enabled by default starting with Visual Studio 17.14 Preview 3 for .NET Framework projects. If needed, you can toggle this functionality via Visual Studio → Tools → Options → Preview Features\n\nWe’re currently rolling out this feature exclusively for .NET Framework projects, but we plan to extend this support to .NET projects in future Visual Studio releases.\nLooking Ahead\nToolbox support for Explicit Assembly References simplifies working with legacy controls and helps pave the way for smoother migration to .NET. Once this feature expands to .NET projects, it will serve as a powerful bridge during modernization efforts.\nWhile we are happy to offer this capability, we continue to emphasize that for the richest and most predictable design-time experience, the recommended path remains through well-structured NuGet packages aligned with the new extensibility model.\nReady to try it out? Download Visual Studio 17.14 Preview 3 and open your Windows Forms .NET Framework project in the out-of-process designer. Your legacy controls will now appear in the Toolbox, ready for use!\nCheck out the new Visual Studio Hub\nStay connected with everything Visual Studio in one place! Visit the Visual Studio Hub for the latest release notes, YouTube videos, social updates, and community discussions.\nAppreciation for your feedback\nYour feedback helps us improve Visual Studio, making it an even more powerful tool for developers. We are immensely grateful for your contributions and look forward to your continued support. By sharing your thoughts, ideas, and any issues you encounter through Developer Community, you help us improve and shape the future of Visual Studio.\nThe post Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer appeared first on Visual Studio Blog.",
        "dc:creator": "Merrie McGaw, Shyam Gupta",
        "comments": "https://devblogs.microsoft.com/visualstudio/toolbox-support-for-explicit-assembly-references-in-windows-forms-out-of-process-designer/#respond",
        "content": "<p>Visual Studio 17.14 Preview 3 introduces a new feature that enhances the Windows Forms out-of-process designer experience for .NET Framework projects. This release brings Toolbox support for Explicit Assembly References, addressing a long-standing need in legacy application development and migration workflows. What Are Explicit Assembly References? Explicit Assembly References are stand-alone assemblies directly referenced in [&#8230;]</p>\n<p>The post <a href=\"https://devblogs.microsoft.com/visualstudio/toolbox-support-for-explicit-assembly-references-in-windows-forms-out-of-process-designer/\">Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer</a> appeared first on <a href=\"https://devblogs.microsoft.com/visualstudio\">Visual Studio Blog</a>.</p>\n",
        "contentSnippet": "Visual Studio 17.14 Preview 3 introduces a new feature that enhances the Windows Forms out-of-process designer experience for .NET Framework projects. This release brings Toolbox support for Explicit Assembly References, addressing a long-standing need in legacy application development and migration workflows. What Are Explicit Assembly References? Explicit Assembly References are stand-alone assemblies directly referenced in […]\nThe post Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer appeared first on Visual Studio Blog.",
        "guid": "https://devblogs.microsoft.com/visualstudio/?p=253042",
        "categories": [
          "Visual Studio",
          "Windows Forms",
          "Assembly References",
          "designer",
          "out-of-process",
          "Toolbox",
          "WinForms"
        ],
        "isoDate": "2025-04-17T14:45:27.000Z"
      },
      {
        "creator": "Katie Savage",
        "title": "GitHub Copilot Highlights in Visual Studio 17.14 Preview 3 (Available Now)",
        "link": "https://devblogs.microsoft.com/visualstudio/github-copilot-highlights-in-visual-studio-17-14-preview-3-available-now/",
        "pubDate": "Wed, 16 Apr 2025 18:24:10 +0000",
        "content:encodedSnippet": "Visual Studio 17.14 Preview 3 is now available!\nDownload Visual Studio Preview\n\nThe GitHub Copilot experience in Visual Studio is continuously updated to provide the latest advancements in AI-assisted development. The following features and improvements have been recently released in Visual Studio version 17.14 Preview 3. (Remember, preview versions of Visual Studio can be run side by side with the main releases)\n\nA guided Walkthrough for getting started\nIf you’re new to GitHub Copilot in Visual Studio and are looking for a quick, guided way to get started, this feature is for you. Head to the GitHub Copilot badge dropdown and select GitHub Copilot Walkthrough. This will launch the walkthrough as a new tab in your workspace.\nThis five-step walkthrough will show you how to get Copilot for free, introduce you to AI-powered code completions, Copilot Chat, show you how to provide Copilot with specific context about your solution, and introduce you to the multi-file editing power of Copilot Edits. Once you complete these steps, you should be ready to start using and experimenting with Copilot.\ndocument.createElement('video');\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/WalkthroughP3.mp4\n\nImproved model access and Code Mapping\nIt’s also now easier than ever to access the latest models like Claude 3.7 from within Visual Studio. Instead of needing to adjust your settings, you can now enable any of the available models from github.com directly through Visual Studio. When you select your model within Copilot Chat, you will be prompted to enable your chosen model.\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/ModelApprovalP3.mp4\n\nHow and where Copilot inserts its code suggestions into your code in the right place has also gotten an upgrade in this release with improvements to what we call “Code Mapping”.\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/CodeMappingP3.mp4\n\nCopilot can suggest the next edit and fix pasted code automatically\nWe also have some exciting updates coming to the Code Completion experience that will allow Copilot to better understand your intention as you’re writing code and enhance its ability to assist you with editing your code. The feature is called Next Edit Suggestions, which helps developers by providing contextual suggestions for code edits based on previous changes.\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/NESP3.mp4\n\nAnother feature to watch out for is adaptive paste which automatically adjusts code you paste into Visual Studio to fit the context of your existing code, minimizing the need for manual modifications. This feature also supports scenarios such as minor error fixes, code styling, formatting, human and code language translation, and fill-in-the-blank or continue-the-pattern tasks.\nhttps://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/AdaptivePasteP3.mp4\n\nLearn more about these features in the preview 3 release notes: Visual Studio 2022 Preview Release Notes | Microsoft Learn\nTry the latest Preview\nIf you’d like to see any of these features in action and stay up to date with the latest Copilot updates, try out the preview version of Visual Studio.\nCheck out the new Visual Studio Hub\nStay connected with everything Visual Studio in one place! Visit the Visual Studio Hub for the latest release notes, YouTube videos, social updates, and community discussions.\nAppreciation for your feedback\nYour feedback helps us improve Visual Studio, making it an even more powerful tool for developers. We are immensely grateful for your contributions and look forward to your continued support. By sharing your thoughts, ideas, and any issues you encounter through Developer Community, you help us improve and shape the future of Visual Studio.\nThe post GitHub Copilot Highlights in Visual Studio 17.14 Preview 3 (Available Now) appeared first on Visual Studio Blog.",
        "enclosure": {
          "url": "https://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2025/04/WalkthroughP3.mp4",
          "length": "9841988",
          "type": "video/mp4"
        },
        "dc:creator": "Katie Savage",
        "comments": "https://devblogs.microsoft.com/visualstudio/github-copilot-highlights-in-visual-studio-17-14-preview-3-available-now/#comments",
        "content": "<p>Visual Studio 17.14 Preview 3 is now available! The GitHub Copilot experience in Visual Studio is continuously updated to provide the latest advancements in AI-assisted development. The following features and improvements have been recently released in Visual Studio version 17.14 Preview 3. (Remember, preview versions of Visual Studio can be run side by side with [&#8230;]</p>\n<p>The post <a href=\"https://devblogs.microsoft.com/visualstudio/github-copilot-highlights-in-visual-studio-17-14-preview-3-available-now/\">GitHub Copilot Highlights in Visual Studio 17.14 Preview 3 (Available Now)</a> appeared first on <a href=\"https://devblogs.microsoft.com/visualstudio\">Visual Studio Blog</a>.</p>\n",
        "contentSnippet": "Visual Studio 17.14 Preview 3 is now available! The GitHub Copilot experience in Visual Studio is continuously updated to provide the latest advancements in AI-assisted development. The following features and improvements have been recently released in Visual Studio version 17.14 Preview 3. (Remember, preview versions of Visual Studio can be run side by side with […]\nThe post GitHub Copilot Highlights in Visual Studio 17.14 Preview 3 (Available Now) appeared first on Visual Studio Blog.",
        "guid": "https://devblogs.microsoft.com/visualstudio/?p=252998",
        "categories": [
          "Copilot",
          "Visual Studio"
        ],
        "isoDate": "2025-04-16T18:24:10.000Z"
      }
    ]
  },
  {
    "name": "Instagram Engineering",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Dropbox Tech Blog",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Joshua",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권재명",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김석기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김선영",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권진호",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강대명",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권정혁",
    "category": "개인",
    "posts": []
  },
  {
    "name": "줌구",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김수보",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김시은",
    "category": "개인",
    "posts": [
      {
        "creator": "기술블로그",
        "title": "다시 개발을 시작했더니, 세상이 바뀌어 있었다.",
        "link": "https://brunch.co.kr/@@2MrI/866",
        "pubDate": "Sat, 12 Apr 2025 10:42:03 GMT",
        "author": "기술블로그",
        "content": "오랜만에 다시 개발을 시작했다. 실무에서 손을 뗀 지는 꽤 되었고, 딸아이가 태어난 이후 병원 치료에 집중해야 했기 때문에 자연스럽게 업무 시간도 줄어들었다. 나는 개발팀 리더는 실무에 깊이 관여하지 않아도 된다는 나름의 철학을 갖고 있었기에, 그 상황을 받아들이는 데 큰 저항은 없었다. 주기적으로 경영진과의 팀의 방향성을 설계하고, 개발조직이&nbsp;최고의 성과",
        "contentSnippet": "오랜만에 다시 개발을 시작했다. 실무에서 손을 뗀 지는 꽤 되었고, 딸아이가 태어난 이후 병원 치료에 집중해야 했기 때문에 자연스럽게 업무 시간도 줄어들었다. 나는 개발팀 리더는 실무에 깊이 관여하지 않아도 된다는 나름의 철학을 갖고 있었기에, 그 상황을 받아들이는 데 큰 저항은 없었다. 주기적으로 경영진과의 팀의 방향성을 설계하고, 개발조직이 최고의 성과",
        "guid": "https://brunch.co.kr/@@2MrI/866",
        "isoDate": "2025-04-12T10:42:03.000Z"
      }
    ]
  },
  {
    "name": "곽민수",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김민서",
    "category": "개인",
    "posts": []
  },
  {
    "name": "I am not Okay",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권창현",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권기호",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김수민",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강태욱",
    "category": "개인",
    "posts": [
      {
        "title": "OpenAI 코딩 멀티 에이전트 Codex 오픈소스 도구 사용법",
        "link": "http://daddynkidsmakers.blogspot.com/2025/04/openai-codex.html",
        "pubDate": "2025-04-17T07:04:00.000Z",
        "author": "Daddy Maker",
        "content": "<div style=\"text-align: left;\">이 글은&nbsp;OpenAI가 개발한 코딩 멀티 에이전트 Codex 사용법을 간략히 소개한다.&nbsp;</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">현재 시점에서 14시간 전에 OpenAI o3, o4, codex 가 공개되었다. 모두 멀티 AI 에이전트 기능을 충실히 구현한 영상을 데모가 업로드되었고, 특히, 자동화 코딩을 지원하는 codex(코덱스) 가 로컬 컴퓨터에서 실행 가능한 형태로 공개된 점이 인상적이었다.&nbsp;</div><div class=\"separator\" style=\"clear: both; text-align: center;\"><iframe allowfullscreen=\"\" class=\"BLOG_video_class\" height=\"266\" src=\"https://www.youtube.com/embed/sq8GBPUb3rk\" width=\"320\" youtube-src-id=\"sq8GBPUb3rk\"></iframe></div><div class=\"separator\" style=\"clear: both; text-align: center;\">OpenAI o3, o4, codex 공개 영상</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">코덱스 코드 및 도구는 Github에 공개되었다.</div><div style=\"text-align: left;\"><ul style=\"text-align: left;\"><li><a href=\"https://github.com/openai/codex\">codex: Lightweight coding agent that runs in your terminal</a></li></ul></div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>코덱스 설치 및 환경설정</b></div><div style=\"text-align: left;\">터미널에서 다음을 실행해 설치 및 환경 설정을 한다.</div><div style=\"text-align: left;\">git clone https://github.com/openai/codex.git</div><div style=\"text-align: left;\">cd codex</div><div style=\"text-align: left;\">npm install -g @openai/codex</div><div style=\"text-align: center;\"><div style=\"text-align: left;\"><img alt=\"\" data-original-height=\"270\" data-original-width=\"1084\" height=\"133\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhe8O2QU6nkqpzFKwOzt8VyJTszssUlQuN1aRNvqgbzGy9iQF1T7Y19JLCbvvElUuSO2FbHRqF-2-GZ3-VuK0rymBhXul_7K51RcYsZHhubP6DbOyDemUgQeb_VKPZff3cYWL1TYtjjxsNlAqRi-SNPT8EVi5Wzut4jLvPYEYYIANR3LIgvDym8aVvwn608=w533-h133\" style=\"color: #0000ee; text-align: center;\" width=\"533\" /></div></div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">설치 시 npm error code SELF_SIGNED_CERT_IN_CHAIN 에러 발생하면 다음 명령 실행 후 패키지 재설치한다.</div><div style=\"text-align: left;\"><div>npm config set strict-ssl false -g</div><div><br /></div><div>오픈AI Key를 설정한다.</div></div><div style=\"text-align: left;\">export OPENAI_API_KEY=\"your-api-key-here\"</div><div style=\"text-align: left;\"><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div></div><div style=\"text-align: left;\"><b>실행</b></div><div style=\"text-align: left;\">터미널에서 코덱스를 실행한다.&nbsp;</div><div style=\"text-align: left;\">codex&nbsp;</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">프롬프트를 직접 입력해도 된다.&nbsp;&nbsp;</div><div style=\"text-align: left;\">codex \"explain this codebase to me\"</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">앱을 개발해보자.&nbsp;</div><div style=\"text-align: left;\">codex --approval-mode full-auto \"create the fanciest todo-list app\"</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>레퍼런스</b></div><div style=\"text-align: left;\"><ul style=\"text-align: left;\"><li><a href=\"https://github.com/openai/codex\">Lightweight coding agent that runs in your terminal</a></li></ul></div>",
        "contentSnippet": "이 글은 OpenAI가 개발한 코딩 멀티 에이전트 Codex 사용법을 간략히 소개한다. \n\n\n현재 시점에서 14시간 전에 OpenAI o3, o4, codex 가 공개되었다. 모두 멀티 AI 에이전트 기능을 충실히 구현한 영상을 데모가 업로드되었고, 특히, 자동화 코딩을 지원하는 codex(코덱스) 가 로컬 컴퓨터에서 실행 가능한 형태로 공개된 점이 인상적이었다. \n\nOpenAI o3, o4, codex 공개 영상\n\n\n코덱스 코드 및 도구는 Github에 공개되었다.\n\ncodex: Lightweight coding agent that runs in your terminal\n\n\n\n코덱스 설치 및 환경설정\n터미널에서 다음을 실행해 설치 및 환경 설정을 한다.\ngit clone https://github.com/openai/codex.git\ncd codex\nnpm install -g @openai/codex\n\n\n\n\n설치 시 npm error code SELF_SIGNED_CERT_IN_CHAIN 에러 발생하면 다음 명령 실행 후 패키지 재설치한다.\n\nnpm config set strict-ssl false -g\n\n\n오픈AI Key를 설정한다.\n\nexport OPENAI_API_KEY=\"your-api-key-here\"\n\n\n\n실행\n터미널에서 코덱스를 실행한다. \ncodex \n\n\n프롬프트를 직접 입력해도 된다.  \ncodex \"explain this codebase to me\"\n\n\n앱을 개발해보자. \ncodex --approval-mode full-auto \"create the fanciest todo-list app\"\n\n\n레퍼런스\n\nLightweight coding agent that runs in your terminal",
        "id": "tag:blogger.com,1999:blog-5201956450461596914.post-3813547155265462040",
        "isoDate": "2025-04-17T07:04:00.000Z"
      },
      {
        "title": "Gemini 기반 MCP 서버 및 클라이언트 개발해 보기 ",
        "link": "http://daddynkidsmakers.blogspot.com/2025/04/gemini-mcp.html",
        "pubDate": "2025-04-13T00:58:00.000Z",
        "author": "Daddy Maker",
        "content": "<div style=\"text-align: left;\">이 글은&nbsp;Gemini 기반 MCP 서버 및 클라이언트를 개발하는 방법을 간략히 보여준다.</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/a/AVvXsEhm2o0xjgQULzjL4FnWbvTN0EZq5ejD3hsoffi1vYZcG1jzqXODlvmDVnpfybgf8a0TuJ0nqpuE46IfQgsX-dOFjTOSkx6lZTdUoEyz-F5lFJFfgQN-WqLbsldwwot3pxyBrJ2-ugwWwvzWGHM8erMtYTNwQheMSZi83krw0VkSqE80hrbTgbVWUX4YMxce\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"\" data-original-height=\"600\" data-original-width=\"1200\" height=\"200\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhm2o0xjgQULzjL4FnWbvTN0EZq5ejD3hsoffi1vYZcG1jzqXODlvmDVnpfybgf8a0TuJ0nqpuE46IfQgsX-dOFjTOSkx6lZTdUoEyz-F5lFJFfgQN-WqLbsldwwot3pxyBrJ2-ugwWwvzWGHM8erMtYTNwQheMSZi83krw0VkSqE80hrbTgbVWUX4YMxce=w400-h200\" width=\"400\" /></a></div><div class=\"separator\" style=\"clear: both; text-align: center;\">MCP 기반 멀티 AI 에이전트 아키텍처 개념도</div><br /></div><div style=\"text-align: left;\">MCP의 개념과 상세한 동작 방식은 다음 글을 참고한다.</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>개요</b></div><div style=\"text-align: left;\">MCP는 클라이언트-서버 구조를 따른다. 클라이언트는 서버의 MCP 도구를 사용하는 AI 앱이나 LLM을 의미한다. 서버는 MCP 도구를 공급하고, API, 데이터소스 인터페이스를 제공한다.&nbsp;</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">MCP를 통해 LLM이 해결하지 못하는 작업은 외부 시스템과 연결해 서비스 받을 수 있다.</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">MCP서버는 파일 시스템 조작, 웹 검색, 데이터베이스 조작, 버전 관리 등 다양한 도구를 제공할 수 있다.&nbsp;</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>제미니 LLM 기반 MCP 구조</b></div><div style=\"text-align: left;\">다음은 제미니 LLM 기반 MCP 구조 예시를 보여준다. 이 예는 비행기 예약 유스케이스를 구현한다.</div><div style=\"text-align: left;\"><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/a/AVvXsEjJi0KvcBwMZamL_qYjpkJ9L5wCc-L1FNm1XiMpxofuR_BheadHYrmEwVlCidd_Z0u5T01UFwpfrWr-xF23ENbqmEviz_Wqs3rc8VIbUxuHgCoAYP3kP8HU1HIpukYPk9sDOagmKn3vt_bqXFLXA1VDFEalzd9ySjbsxJMgvH9jCDLW6ktNyM917NZ_LnEg\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"\" data-original-height=\"755\" data-original-width=\"1067\" height=\"357\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEjJi0KvcBwMZamL_qYjpkJ9L5wCc-L1FNm1XiMpxofuR_BheadHYrmEwVlCidd_Z0u5T01UFwpfrWr-xF23ENbqmEviz_Wqs3rc8VIbUxuHgCoAYP3kP8HU1HIpukYPk9sDOagmKn3vt_bqXFLXA1VDFEalzd9ySjbsxJMgvH9jCDLW6ktNyM917NZ_LnEg=w505-h357\" width=\"505\" /></a></div>구조의 각 번호는 시퀀스 시나리오를 보여준다. 이 내용은 다음과 같다.</div><div style=\"text-align: left;\"><ol style=\"text-align: left;\"><li>MCP 호스트가 사용자 명령 입력. 예) 내일 인천에서 애틀란타 가는 비행편 찾기</li><ol><li>클라이언트 스크립트가 입력을 처리(CLIENT.PY)</li></ol><li>클라이언트가 MCP 서버 프로세스 시작(MCP-FLIGHT-SEARCH). STDIO 통신 채널 연결 및 관련 도구 검색</li><li>클라이언트가 사용자 명령에 대한 함수 호출 방법을 수신함</li><li>클라리언트가 함수 호출 방법에 대한 정확한 함수 호출 형식을 GEMINI에서 획득. 함수 호출 형식에 부합하는 적절한 MCP 도구를 서버에 호출. 서버의 도구 함수 호출 결과를 리턴</li><li>MCP 서버가 구글 항공편 검색을 위한 SerpAPI를 호출. 구글 항공편 데이터 질의.</li><li>구글 항공편 정보 리턴</li><li>서버에서 클라이언트로 해당 정보 리턴</li><li>클라이언트가 호스로 해당 정보 전달</li></ol><div><b>개발 환경</b></div>개발을 위한 최소한의 환경은 파이썬 3.8+이다. 이외 다음을 준비한다.</div><div style=\"text-align: left;\"><ul style=\"text-align: left;\"><li><a href=\"https://console.cloud.google.com/\">Google Cloud</a> 에서 Project 생성</li></ul><div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/a/AVvXsEhfTBQEXNM-unXJdkC_ZpFiH8j6l1wDRupyOGynBHVdb0mfX81QoZKJ86O-9jZa3wX-1I5MQqT8J96KGVFXZvVTrAIzinVnJHEfkaGQzSiAv4GyfwycWhkgCgZHIkYL7UdX_lad4hVrJXan6rasu-xOmyARkM9yJk2xSD7sy63ua7TmbRvSgJdqne4P1vMm\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"\" data-original-height=\"806\" data-original-width=\"1747\" height=\"185\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhfTBQEXNM-unXJdkC_ZpFiH8j6l1wDRupyOGynBHVdb0mfX81QoZKJ86O-9jZa3wX-1I5MQqT8J96KGVFXZvVTrAIzinVnJHEfkaGQzSiAv4GyfwycWhkgCgZHIkYL7UdX_lad4hVrJXan6rasu-xOmyARkM9yJk2xSD7sy63ua7TmbRvSgJdqne4P1vMm=w400-h185\" width=\"400\" /></a></div></div><ul style=\"text-align: left;\"><li>Google <a href=\"https://aistudio.google.com/apikey\">Gemini API</a>&nbsp;키 획득</li></ul><div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/a/AVvXsEjJk7hEyenBNWdRjlm114O1G5wlRXCEirzbE7wdn6agF01g36Ufj0KNq7XfOqNlLZ63WayLKcqZk8kXh4kYDqAhV4Zmx0rPdXu1re_vXdWxuAEAdlJ4fHRyLQZqeNnq6qTXUPyBHqoymW54Xj_ORkmaiK-wROnczvyrYjm8naTAFRmIV4F3-OKYYdLm-UK9\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"\" data-original-height=\"911\" data-original-width=\"1946\" height=\"150\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEjJk7hEyenBNWdRjlm114O1G5wlRXCEirzbE7wdn6agF01g36Ufj0KNq7XfOqNlLZ63WayLKcqZk8kXh4kYDqAhV4Zmx0rPdXu1re_vXdWxuAEAdlJ4fHRyLQZqeNnq6qTXUPyBHqoymW54Xj_ORkmaiK-wROnczvyrYjm8naTAFRmIV4F3-OKYYdLm-UK9\" width=\"320\" /></a></div></div><ul style=\"text-align: left;\"><li><a href=\"https://serpapi.com/\">SerpAPI</a> 키 획득</li></ul><div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/a/AVvXsEjXELm_6bCIugZHmhrYyUzDynDZzL5Nb2e3QCQsP6aLcCbvf6nDVNsZmV5KL1tQdl94hzOE9noB2d07QKfNorNqHKdy_KgOGjWMp-EqDxe7AZqrWEyWmZVKF2i_pvkd4lor23dOOgpzhbA8v67icVqUHmQ6yeJ_kuU2pW9gA7eI9sdFdXzSKMTYh8HJ9Xrm\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"\" data-original-height=\"903\" data-original-width=\"1989\" height=\"145\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEjXELm_6bCIugZHmhrYyUzDynDZzL5Nb2e3QCQsP6aLcCbvf6nDVNsZmV5KL1tQdl94hzOE9noB2d07QKfNorNqHKdy_KgOGjWMp-EqDxe7AZqrWEyWmZVKF2i_pvkd4lor23dOOgpzhbA8v67icVqUHmQ6yeJ_kuU2pW9gA7eI9sdFdXzSKMTYh8HJ9Xrm\" width=\"320\" /></a></div><br /></div><div>다음 종속성을 터미널에서 설치한다. google-genai는 google 생성AI 라이브러리이며, mcp는 MCP 서버 통신을 위한 파이썬 SDK이다.&nbsp;</div><div>pip install google-genai mcp</div></div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">환경변수를 설정한다.&nbsp;</div><div style=\"text-align: left;\"><div>export GEMINI_API_KEY=\"your-google-api-key\"</div><div>export SERP_API_KEY=\"your-serpapi-key\"</div></div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>항공편 검색 MCP 서버 설치</b></div><div style=\"text-align: left;\">MCP 프로토콜 공개 이후로 많은 MCP 서버가 개발되었다. 우리는 항공편 검색 MCP 서버 오픈소스인 <a href=\"https://pypi.org/project/mcp-flight-search/\">mcp-flgiht-search</a> 를 사용한다. 다음을 설치한다.</div><div style=\"text-align: left;\"><div>pip install mcp-flight-search</div><div><br /></div></div><div style=\"text-align: left;\"><b>코딩해보기</b></div><div style=\"text-align: left;\">다음과 같이 client.py를 코딩한다.&nbsp;</div><div style=\"text-align: left;\"><div style=\"background-color: #1f1f1f; color: #cccccc; font-family: Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; line-height: 16px; white-space: pre;\"><div><span style=\"color: #c586c0;\">import</span> os, sys, time, asyncio</div><div><span style=\"color: #c586c0;\">from</span> google <span style=\"color: #c586c0;\">import</span> genai</div><div><span style=\"color: #c586c0;\">from</span> google.genai <span style=\"color: #c586c0;\">import</span> types</div><div><span style=\"color: #c586c0;\">from</span> mcp <span style=\"color: #c586c0;\">import</span> ClientSession, StdioServerParameters</div><div><span style=\"color: #c586c0;\">from</span> mcp.client.stdio <span style=\"color: #c586c0;\">import</span> stdio_client</div><div><span style=\"color: #c586c0;\">from</span> dotenv <span style=\"color: #c586c0;\">import</span> load_dotenv</div><br /><div>load_dotenv()</div><br /><div>gemini_api_key <span style=\"color: #d4d4d4;\">=</span> os.getenv(<span style=\"color: #ce9178;\">\"GEMINI_API_KEY\"</span>)</div><div>serp_api_key <span style=\"color: #d4d4d4;\">=</span> os.getenv(<span style=\"color: #ce9178;\">\"SERP_API_KEY\"</span>)</div><br /><div>client <span style=\"color: #d4d4d4;\">=</span> genai.Client(<span style=\"color: #9cdcfe;\">api_key</span><span style=\"color: #d4d4d4;\">=</span>gemini_api_key)</div><br /><div>server_params <span style=\"color: #d4d4d4;\">=</span> StdioServerParameters(</div><div>&nbsp; &nbsp; <span style=\"color: #9cdcfe;\">command</span><span style=\"color: #d4d4d4;\">=</span><span style=\"color: #ce9178;\">\"mcp-flight-search\"</span>,</div><div>&nbsp; &nbsp; <span style=\"color: #9cdcfe;\">args</span><span style=\"color: #d4d4d4;\">=</span>[<span style=\"color: #ce9178;\">\"--connection_type\"</span>, <span style=\"color: #ce9178;\">\"stdio\"</span>],</div><div>&nbsp; &nbsp; <span style=\"color: #9cdcfe;\">env</span><span style=\"color: #d4d4d4;\">=</span>{<span style=\"color: #ce9178;\">\"SERP_API_KEY\"</span>: serp_api_key},</div><div>)</div><br /><div><span style=\"color: #569cd6;\">async</span> <span style=\"color: #569cd6;\">def</span> <span style=\"color: #dcdcaa;\">run</span>():</div><div>&nbsp; &nbsp; <span style=\"color: #c586c0;\">async</span> <span style=\"color: #c586c0;\">with</span> stdio_client(server_params) <span style=\"color: #c586c0;\">as</span> (read, write):  # 항공 예약 검색 도구 등록</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">async</span> <span style=\"color: #c586c0;\">with</span> ClientSession(read, write) <span style=\"color: #c586c0;\">as</span> session:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prompt <span style=\"color: #d4d4d4;\">=</span> <span style=\"color: #569cd6;\">f</span><span style=\"color: #ce9178;\">\"Find Flights from Atlanta to Las Vegas 2025-08-15\"  # 사용자 질의 명령</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">await</span> session.initialize()</div><br /><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcp_tools <span style=\"color: #d4d4d4;\">=</span> <span style=\"color: #c586c0;\">await</span> session.list_tools()  # 도구 리스트 획득</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tools <span style=\"color: #d4d4d4;\">=</span> [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; types.Tool(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #9cdcfe;\">function_declarations</span><span style=\"color: #d4d4d4;\">=</span>[</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #ce9178;\">\"name\"</span>: tool.name,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #ce9178;\">\"description\"</span>: tool.description,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #ce9178;\">\"parameters\"</span>: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k: v</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">for</span> k, v <span style=\"color: #c586c0;\">in</span> tool.inputSchema.items()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">if</span> k <span style=\"color: #569cd6;\">not</span> <span style=\"color: #569cd6;\">in</span> [<span style=\"color: #ce9178;\">\"additionalProperties\"</span>, <span style=\"color: #ce9178;\">\"$schema\"</span>]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]  # 해당 도구 함수 선언 생성</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">for</span> tool <span style=\"color: #c586c0;\">in</span> mcp_tools.tools</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]</div><br /><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response <span style=\"color: #d4d4d4;\">=</span> client.models.generate_content(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #9cdcfe;\">model</span><span style=\"color: #d4d4d4;\">=</span><span style=\"color: #ce9178;\">\"gemini-2.5-pro-exp-03-25\"</span>,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #9cdcfe;\">contents</span><span style=\"color: #d4d4d4;\">=</span>prompt,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #9cdcfe;\">config</span><span style=\"color: #d4d4d4;\">=</span>types.GenerateContentConfig(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #9cdcfe;\">temperature</span><span style=\"color: #d4d4d4;\">=</span><span style=\"color: #b5cea8;\">0</span>,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #9cdcfe;\">tools</span><span style=\"color: #d4d4d4;\">=</span>tools,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ),  # LLM 모델에 프롬프트 전달.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )</div><br /><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">if</span> response.candidates[<span style=\"color: #b5cea8;\">0</span>].content.parts[<span style=\"color: #b5cea8;\">0</span>].function_call:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function_call <span style=\"color: #d4d4d4;\">=</span> response.candidates[<span style=\"color: #b5cea8;\">0</span>].content.parts[<span style=\"color: #b5cea8;\">0</span>].function_call # 함수호출정보</div><br /><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result <span style=\"color: #d4d4d4;\">=</span> <span style=\"color: #c586c0;\">await</span> session.call_tool(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function_call.name, <span style=\"color: #9cdcfe;\">arguments</span><span style=\"color: #d4d4d4;\">=</span><span style=\"color: #4ec9b0;\">dict</span>(function_call.args)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )  # 도구 함수 호출</div><br /><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #dcdcaa;\">print</span>(<span style=\"color: #ce9178;\">\"--- Formatted Result ---\"</span>) <span style=\"color: #6a9955;\"># Add header for clarity</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">try</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flight_data <span style=\"color: #d4d4d4;\">=</span> json.loads(result.content[<span style=\"color: #b5cea8;\">0</span>].text)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #dcdcaa;\">print</span>(json.dumps(flight_data, <span style=\"color: #9cdcfe;\">indent</span><span style=\"color: #d4d4d4;\">=</span><span style=\"color: #b5cea8;\">2</span>))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">except</span> json.JSONDecodeError:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #dcdcaa;\">print</span>(<span style=\"color: #ce9178;\">\"MCP server returned non-JSON response:\"</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #dcdcaa;\">print</span>(result.content[<span style=\"color: #b5cea8;\">0</span>].text)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">except</span> (<span style=\"color: #4ec9b0;\">IndexError</span>, <span style=\"color: #4ec9b0;\">AttributeError</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color: #dcdcaa;\">print</span>(<span style=\"color: #ce9178;\">\"Unexpected result structure from MCP server:\"</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color: #dcdcaa;\">print</span>(result)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">else</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #dcdcaa;\">print</span>(<span style=\"color: #ce9178;\">\"No function call was generated by the model.\"</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: #c586c0;\">if</span> response.text:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color: #dcdcaa;\">print</span>(<span style=\"color: #ce9178;\">\"Model response:\"</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color: #dcdcaa;\">print</span>(response.text)</div><br /><div>asyncio.run(run()) # 클라이언트 실행</div></div></div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\">실행한다. 그럼 프롬프트에 대해 LLM이 적절한 도구와 파라메터를 확인해 함수 호출 정보를 생성한다. 이를 call_tool로 호출한 결과가 표시된다&nbsp;</div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><b>레퍼런스</b></div><div style=\"text-align: left;\"><ul style=\"text-align: left;\"><li><a href=\"https://medium.com/binome/introduction-to-graphite-an-event-driven-ai-agent-framework-540478130cd2\">Introducing Graphite — An Event Driven AI Agent Framework | by Craig Li, Ph.D | Binome | Apr, 2025 | Medium</a></li><li><a href=\"https://medium.com/google-cloud/model-context-protocol-mcp-with-google-gemini-llm-a-deep-dive-full-code-ea16e3fac9a3\">Model Context Protocol(MCP) with Google Gemini 2.5 Pro - Deep Dive , Google Cloud Gen AI | Google Cloud - Community</a></li><li><a href=\"https://github.com/arjunprabhulal/mcp-gemini-search?source=post_page-----ea16e3fac9a3---------------------------------------\">Model Context Protocol (MCP) with Gemini 2.5 Pro. Convert conversational queries into flight searches using Gemini's function calling capabilities and MCP's flight search tools</a></li></ul></div><div style=\"text-align: left;\"><br /></div><div style=\"text-align: left;\"><br /></div>",
        "contentSnippet": "이 글은 Gemini 기반 MCP 서버 및 클라이언트를 개발하는 방법을 간략히 보여준다.\n\n\n\nMCP 기반 멀티 AI 에이전트 아키텍처 개념도\n\nMCP의 개념과 상세한 동작 방식은 다음 글을 참고한다.\n\n\n개요\nMCP는 클라이언트-서버 구조를 따른다. 클라이언트는 서버의 MCP 도구를 사용하는 AI 앱이나 LLM을 의미한다. 서버는 MCP 도구를 공급하고, API, 데이터소스 인터페이스를 제공한다. \n\n\nMCP를 통해 LLM이 해결하지 못하는 작업은 외부 시스템과 연결해 서비스 받을 수 있다.\n\n\nMCP서버는 파일 시스템 조작, 웹 검색, 데이터베이스 조작, 버전 관리 등 다양한 도구를 제공할 수 있다. \n\n\n제미니 LLM 기반 MCP 구조\n다음은 제미니 LLM 기반 MCP 구조 예시를 보여준다. 이 예는 비행기 예약 유스케이스를 구현한다.\n\n\n구조의 각 번호는 시퀀스 시나리오를 보여준다. 이 내용은 다음과 같다.\n\nMCP 호스트가 사용자 명령 입력. 예) 내일 인천에서 애틀란타 가는 비행편 찾기\n\n클라이언트 스크립트가 입력을 처리(CLIENT.PY)\n\n클라이언트가 MCP 서버 프로세스 시작(MCP-FLIGHT-SEARCH). STDIO 통신 채널 연결 및 관련 도구 검색\n클라이언트가 사용자 명령에 대한 함수 호출 방법을 수신함\n클라리언트가 함수 호출 방법에 대한 정확한 함수 호출 형식을 GEMINI에서 획득. 함수 호출 형식에 부합하는 적절한 MCP 도구를 서버에 호출. 서버의 도구 함수 호출 결과를 리턴\nMCP 서버가 구글 항공편 검색을 위한 SerpAPI를 호출. 구글 항공편 데이터 질의.\n구글 항공편 정보 리턴\n서버에서 클라이언트로 해당 정보 리턴\n클라이언트가 호스로 해당 정보 전달\n\n개발 환경\n개발을 위한 최소한의 환경은 파이썬 3.8+이다. 이외 다음을 준비한다.\n\nGoogle Cloud 에서 Project 생성\n\n\n\nGoogle Gemini API 키 획득\n\n\n\nSerpAPI 키 획득\n\n\n\n다음 종속성을 터미널에서 설치한다. google-genai는 google 생성AI 라이브러리이며, mcp는 MCP 서버 통신을 위한 파이썬 SDK이다. \npip install google-genai mcp\n\n\n환경변수를 설정한다. \n\nexport GEMINI_API_KEY=\"your-google-api-key\"\nexport SERP_API_KEY=\"your-serpapi-key\"\n\n\n항공편 검색 MCP 서버 설치\nMCP 프로토콜 공개 이후로 많은 MCP 서버가 개발되었다. 우리는 항공편 검색 MCP 서버 오픈소스인 mcp-flgiht-search 를 사용한다. 다음을 설치한다.\n\npip install mcp-flight-search\n\n\n코딩해보기\n다음과 같이 client.py를 코딩한다. \n\nimport os, sys, time, asyncio\nfrom google import genai\nfrom google.genai import types\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\ngemini_api_key = os.getenv(\"GEMINI_API_KEY\")\nserp_api_key = os.getenv(\"SERP_API_KEY\")\n\nclient = genai.Client(api_key=gemini_api_key)\n\nserver_params = StdioServerParameters(\n    command=\"mcp-flight-search\",\n    args=[\"--connection_type\", \"stdio\"],\n    env={\"SERP_API_KEY\": serp_api_key},\n)\n\nasync def run():\n    async with stdio_client(server_params) as (read, write):  # 항공 예약 검색 도구 등록\n        async with ClientSession(read, write) as session:\n            prompt = f\"Find Flights from Atlanta to Las Vegas 2025-08-15\"  # 사용자 질의 명령\n            await session.initialize()\n\n            mcp_tools = await session.list_tools()  # 도구 리스트 획득\n            tools = [\n                types.Tool(\n                    function_declarations=[\n                        {\n                            \"name\": tool.name,\n                            \"description\": tool.description,\n                            \"parameters\": {\n                                k: v\n                                for k, v in tool.inputSchema.items()\n                                if k not in [\"additionalProperties\", \"$schema\"]\n                            },\n                        }\n                    ]  # 해당 도구 함수 선언 생성\n                )\n                for tool in mcp_tools.tools\n            ]\n\n            response = client.models.generate_content(\n                model=\"gemini-2.5-pro-exp-03-25\",\n                contents=prompt,\n                config=types.GenerateContentConfig(\n                    temperature=0,\n                    tools=tools,\n                ),  # LLM 모델에 프롬프트 전달.\n            )\n\n            if response.candidates[0].content.parts[0].function_call:\n                function_call = response.candidates[0].content.parts[0].function_call # 함수호출정보\n\n                result = await session.call_tool(\n                    function_call.name, arguments=dict(function_call.args)\n                )  # 도구 함수 호출\n\n                print(\"--- Formatted Result ---\") # Add header for clarity\n                try:\n                    flight_data = json.loads(result.content[0].text)\n                    print(json.dumps(flight_data, indent=2))\n                except json.JSONDecodeError:\n                    print(\"MCP server returned non-JSON response:\")\n                    print(result.content[0].text)\n                except (IndexError, AttributeError):\n                     print(\"Unexpected result structure from MCP server:\")\n                     print(result)\n            else:\n                print(\"No function call was generated by the model.\")\n                if response.text:\n                     print(\"Model response:\")\n                     print(response.text)\n\nasyncio.run(run()) # 클라이언트 실행\n\n\n\n실행한다. 그럼 프롬프트에 대해 LLM이 적절한 도구와 파라메터를 확인해 함수 호출 정보를 생성한다. 이를 call_tool로 호출한 결과가 표시된다 \n\n\n레퍼런스\n\nIntroducing Graphite — An Event Driven AI Agent Framework | by Craig Li, Ph.D | Binome | Apr, 2025 | Medium\nModel Context Protocol(MCP) with Google Gemini 2.5 Pro - Deep Dive , Google Cloud Gen AI | Google Cloud - Community\nModel Context Protocol (MCP) with Gemini 2.5 Pro. Convert conversational queries into flight searches using Gemini's function calling capabilities and MCP's flight search tools",
        "id": "tag:blogger.com,1999:blog-5201956450461596914.post-90111100907465866",
        "isoDate": "2025-04-13T00:58:00.000Z"
      }
    ]
  },
  {
    "name": "권용진",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김민수",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김승호",
    "category": "개인",
    "posts": []
  },
  {
    "name": "RSS feed for boyism Blog",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김성준의 린스타트업과 디자인씽킹",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강동혁",
    "category": "개인",
    "posts": []
  },
  {
    "name": "고종범",
    "category": "개인",
    "posts": []
  },
  {
    "name": "cheese10yun",
    "category": "개인",
    "posts": []
  },
  {
    "name": "구자철",
    "category": "개인",
    "posts": []
  },
  {
    "name": "FSS",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권동준",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김용일",
    "category": "개인",
    "posts": [
      {
        "creator": "흰끼끼",
        "title": "블루베리 효능 총정리: 노화 방지에 탁월한 이유 5가지",
        "link": "http://app-developer.tistory.com/entry/%EB%B8%94%EB%A3%A8%EB%B2%A0%EB%A6%AC-%ED%9A%A8%EB%8A%A5-%EC%B4%9D%EC%A0%95%EB%A6%AC-%EB%85%B8%ED%99%94-%EB%B0%A9%EC%A7%80%EC%97%90-%ED%83%81%EC%9B%94%ED%95%9C-%EC%9D%B4%EC%9C%A0-5%EA%B0%80%EC%A7%80",
        "pubDate": "Sun, 13 Apr 2025 20:44:48 +0900",
        "author": "흰끼끼",
        "comments": "http://app-developer.tistory.com/entry/%EB%B8%94%EB%A3%A8%EB%B2%A0%EB%A6%AC-%ED%9A%A8%EB%8A%A5-%EC%B4%9D%EC%A0%95%EB%A6%AC-%EB%85%B8%ED%99%94-%EB%B0%A9%EC%A7%80%EC%97%90-%ED%83%81%EC%9B%94%ED%95%9C-%EC%9D%B4%EC%9C%A0-5%EA%B0%80%EC%A7%80#entry207comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"ChatGPT Image 2025년 4월 13일 오후 08_43_47.png\" data-origin-width=\"1536\" data-origin-height=\"1024\"><span data-url=\"https://blog.kakaocdn.net/dn/c18gA9/btsNjFgQZIm/4YdksfRmkM58ehiPktlCl1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/c18gA9/btsNjFgQZIm/4YdksfRmkM58ehiPktlCl1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/c18gA9/btsNjFgQZIm/4YdksfRmkM58ehiPktlCl1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc18gA9%2FbtsNjFgQZIm%2F4YdksfRmkM58ehiPktlCl1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"1536\" height=\"1024\" data-filename=\"ChatGPT Image 2025년 4월 13일 오후 08_43_47.png\" data-origin-width=\"1536\" data-origin-height=\"1024\"/></span></figure>\n</p>\n<p>현대인의 건강식으로 각광받고 있는 <strong>블루베리</strong>, 그냥 맛있는 과일일 뿐이라고 생각하셨다면 오산입니다. 특히 <strong>노화를 늦추는 항산화 식품</strong>으로 블루베리는 수많은 연구에서 그 효과가 입증되고 있는데요. 이번 글에서는 블루베리가 <strong>왜 노화 방지에 탁월한지</strong>, 그 이유 5가지를 집중적으로 알아보겠습니다.</p>\n<h2>1. 강력한 항산화 성분, 안토시아닌의 힘</h2>\n<p>블루베리는 <strong>안토시아닌(Anthocyanin)</strong>이라는 강력한 항산화 성분이 풍부하게 들어 있습니다.<br>이 성분은 활성산소로부터 세포를 보호하여 <strong>세포 노화를 늦추는 효과</strong>를 합니다.<br>피부 탄력, 주름 개선, 면역력 강화에도 큰 도움을 줍니다.</p>\n<h2>2. 뇌 기능 보호 및 인지 능력 향상</h2>\n<p>노화의 대표적인 증상 중 하나는 <strong>기억력 저하</strong>와 같은 뇌 기능 감소입니다.<br>블루베리 섭취는 <strong>신경세포 손상을 줄이고, 뇌 신호 전달을 촉진</strong>하여<br>인지 능력 향상 및 <strong>치매 예방 효과</strong>까지 기대할 수 있습니다.</p>\n<h2>3. 심혈관 건강 개선으로 노화 예방</h2>\n<p>나이가 들수록 혈관 건강은 더 중요해지죠.<br>블루베리는 <strong>혈관을 깨끗하게 유지하고, 혈압과 콜레스테롤 수치를 낮추는 데</strong> 도움을 줍니다.<br>이로 인해 <strong>심혈관 질환 예방</strong>은 물론, 신체 전체의 노화 속도도 늦출 수 있습니다.</p>\n<h2>4. 면역력 강화로 각종 질병 예방</h2>\n<p>노화가 진행되면 <strong>면역 시스템이 약화</strong>되기 쉽습니다.<br>블루베리 속 <strong>비타민 C, K, 망간 등의 영양소</strong>는 면역 기능을 강화해<br>감기나 바이러스, 염증성 질환 등 각종 <strong>질병으로부터 몸을 보호</strong>해 줍니다.</p>\n<h2>5. 피부 건강 개선과 안티에이징 효과</h2>\n<p>블루베리는 <strong>피부 트러블 개선과 피부 톤 개선</strong>에도 효과적입니다.<br>항산화 작용으로 인해 피부의 노화 원인인 <strong>산화 스트레스와 자외선 손상</strong>을 줄여주며,<br>피부에 <strong>생기와 탄력</strong>을 더해주는 데 도움을 줍니다.</p>\n<h2>✅ 결론</h2>\n<p>블루베리는 단순한 과일이 아니라, <strong>노화 방지를 위한 자연의 선물</strong>입니다.<br>매일 소량이라도 꾸준히 섭취한다면, 건강은 물론 <strong>젊음까지 지킬 수 있는 최고의 슈퍼푸드</strong>죠.<br>오늘부터 식단에 블루베리를 더해보는 건 어떠세요?</p>\n<blockquote data-ke-style=\"style1\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>  <strong>팁</strong>: 신선한 블루베리뿐만 아니라, 냉동 블루베리나 블루베리 파우더도 동일한 효능을 기대할 수 있어요!</p>\n</span></p></blockquote>",
        "contentSnippet": "현대인의 건강식으로 각광받고 있는 블루베리, 그냥 맛있는 과일일 뿐이라고 생각하셨다면 오산입니다. 특히 노화를 늦추는 항산화 식품으로 블루베리는 수많은 연구에서 그 효과가 입증되고 있는데요. 이번 글에서는 블루베리가 왜 노화 방지에 탁월한지, 그 이유 5가지를 집중적으로 알아보겠습니다.\n1. 강력한 항산화 성분, 안토시아닌의 힘\n블루베리는 안토시아닌(Anthocyanin)이라는 강력한 항산화 성분이 풍부하게 들어 있습니다.\n이 성분은 활성산소로부터 세포를 보호하여 세포 노화를 늦추는 효과를 합니다.\n피부 탄력, 주름 개선, 면역력 강화에도 큰 도움을 줍니다.\n2. 뇌 기능 보호 및 인지 능력 향상\n노화의 대표적인 증상 중 하나는 기억력 저하와 같은 뇌 기능 감소입니다.\n블루베리 섭취는 신경세포 손상을 줄이고, 뇌 신호 전달을 촉진하여\n인지 능력 향상 및 치매 예방 효과까지 기대할 수 있습니다.\n3. 심혈관 건강 개선으로 노화 예방\n나이가 들수록 혈관 건강은 더 중요해지죠.\n블루베리는 혈관을 깨끗하게 유지하고, 혈압과 콜레스테롤 수치를 낮추는 데 도움을 줍니다.\n이로 인해 심혈관 질환 예방은 물론, 신체 전체의 노화 속도도 늦출 수 있습니다.\n4. 면역력 강화로 각종 질병 예방\n노화가 진행되면 면역 시스템이 약화되기 쉽습니다.\n블루베리 속 비타민 C, K, 망간 등의 영양소는 면역 기능을 강화해\n감기나 바이러스, 염증성 질환 등 각종 질병으로부터 몸을 보호해 줍니다.\n5. 피부 건강 개선과 안티에이징 효과\n블루베리는 피부 트러블 개선과 피부 톤 개선에도 효과적입니다.\n항산화 작용으로 인해 피부의 노화 원인인 산화 스트레스와 자외선 손상을 줄여주며,\n피부에 생기와 탄력을 더해주는 데 도움을 줍니다.\n✅ 결론\n블루베리는 단순한 과일이 아니라, 노화 방지를 위한 자연의 선물입니다.\n매일 소량이라도 꾸준히 섭취한다면, 건강은 물론 젊음까지 지킬 수 있는 최고의 슈퍼푸드죠.\n오늘부터 식단에 블루베리를 더해보는 건 어떠세요?\n\n  팁: 신선한 블루베리뿐만 아니라, 냉동 블루베리나 블루베리 파우더도 동일한 효능을 기대할 수 있어요!",
        "guid": "http://app-developer.tistory.com/207",
        "categories": [
          "건강/노화 및 웰에이징"
        ],
        "isoDate": "2025-04-13T11:44:48.000Z"
      },
      {
        "creator": "흰끼끼",
        "title": "배우 김수현, 故 김새론과의 의혹 해명에도&hellip;&ldquo;밤 11시에 닭볶음탕?&rdquo; 여론은 여전히 싸늘",
        "link": "http://app-developer.tistory.com/entry/%EB%B0%B0%EC%9A%B0-%EA%B9%80%EC%88%98%ED%98%84-%E6%95%85-%EA%B9%80%EC%83%88%EB%A1%A0%EA%B3%BC%EC%9D%98-%EC%9D%98%ED%98%B9-%ED%95%B4%EB%AA%85%EC%97%90%EB%8F%84%E2%80%A6%E2%80%9C%EB%B0%A4-11%EC%8B%9C%EC%97%90-%EB%8B%AD%EB%B3%B6%EC%9D%8C%ED%83%95%E2%80%9D-%EC%97%AC%EB%A1%A0%EC%9D%80-%EC%97%AC%EC%A0%84%ED%9E%88-%EC%8B%B8%EB%8A%98",
        "pubDate": "Fri, 11 Apr 2025 23:18:10 +0900",
        "author": "흰끼끼",
        "comments": "http://app-developer.tistory.com/entry/%EB%B0%B0%EC%9A%B0-%EA%B9%80%EC%88%98%ED%98%84-%E6%95%85-%EA%B9%80%EC%83%88%EB%A1%A0%EA%B3%BC%EC%9D%98-%EC%9D%98%ED%98%B9-%ED%95%B4%EB%AA%85%EC%97%90%EB%8F%84%E2%80%A6%E2%80%9C%EB%B0%A4-11%EC%8B%9C%EC%97%90-%EB%8B%AD%EB%B3%B6%EC%9D%8C%ED%83%95%E2%80%9D-%EC%97%AC%EB%A1%A0%EC%9D%80-%EC%97%AC%EC%A0%84%ED%9E%88-%EC%8B%B8%EB%8A%98#entry206comment",
        "content": "<p><figure class=\"imageblock widthContent\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"696\" data-origin-height=\"681\"><span data-url=\"https://blog.kakaocdn.net/dn/b3U4cn/btsNiwX3ewn/EmA9ff23k5aM7oyFfeVjh1/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/b3U4cn/btsNiwX3ewn/EmA9ff23k5aM7oyFfeVjh1/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/b3U4cn/btsNiwX3ewn/EmA9ff23k5aM7oyFfeVjh1/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb3U4cn%2FbtsNiwX3ewn%2FEmA9ff23k5aM7oyFfeVjh1%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"696\" height=\"681\" data-origin-width=\"696\" data-origin-height=\"681\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">2025년 3월 31일, 배우 <b>김수현</b>이 긴급 기자회견을 열고 <b>故 김새론과의 관계</b>에 대한 입장을 밝혔습니다. 하지만 이 해명 이후에도 <b>대중의 의문은 가라앉지 않고</b> 있습니다. 그 중심에는 &ldquo;고등학교 2학년, 17세였던 김새론이 <b>밤 11시에 김수현 가족이 있는 집에서 닭볶음탕을 만들었다는 정황</b>&rdquo;이 있습니다.</p>\n<hr data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\">▶ &ldquo;연인이 아니었다&rdquo;는 주장&hellip;하지만 그 밤의 정황은?</h2>\n<p data-ke-size=\"size16\">김수현 측은 공식 입장에서 <b>&ldquo;당시 연인 관계가 아니었고, 가족들도 함께 있었다&rdquo;고 해명</b>했습니다. 논란이 된 영상은 2018년 6월 촬영된 것으로, 당시 김새론은 고등학교 2학년, <b>만 17세의 미성년자</b>였습니다.</p>\n<p data-ke-size=\"size16\">해당 영상은 <b>밤 11시 20분경</b> 촬영되었으며, <b>식탁 위에는 소주병과 소주잔이 놓여 있었다는 점</b>이 확인되며 더욱 논란이 커지고 있습니다. 소속사는 단순한 가족 식사 자리였다고 주장하지만, 많은 이들은 이 상황 자체를 납득하기 어렵다는 반응입니다.</p>\n<hr data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\">▶ &ldquo;사귀지도 않았는데, 밤 11시에 가족 집에서 요리?&rdquo;</h2>\n<p data-ke-size=\"size16\">온라인 커뮤니티와 SNS에서는 다양한 반응이 이어지고 있습니다:</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li>&ldquo;사귀지 않았다면 오히려 더 이상한 상황&rdquo;</li>\n<li>&ldquo;그 시간에 미성년자가 남자 집에 있었다는 것 자체가 부적절하다&rdquo;</li>\n<li>&ldquo;친구 사이여도 집에 돌려보낼 시간 아닌가?&rdquo;</li>\n</ul>\n<p data-ke-size=\"size16\">또한, 김새론이 김수현에게 보냈다는 <b>카카오톡 메시지</b> 내용도 공개되었습니다. 메시지에는 &ldquo;보고 싶어&rdquo;, &ldquo;언제 안고 잘 수 있어?&rdquo; 등 <b>연인 사이로 보일 수 있는 문구</b>가 담겨 있었지만, 김수현 측은 <b>&ldquo;전면 조작된 메시지&rdquo;라며 원본 데이터 제출을 요구</b>한 상태입니다.</p>\n<hr data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\">▶ 해명에도 남은 의문&hellip;김수현 이미지 타격 불가피</h2>\n<p data-ke-size=\"size16\">김수현 소속사는 <b>&ldquo;미성년자와의 교제는 결단코 없었다&rdquo;</b>며 법적 대응을 시사하고 있지만, 유튜브 채널 <b>&lsquo;가세연&rsquo; 측의 공세는 계속</b>되고 있습니다. 특히 &ldquo;사귄 적 없다&rdquo;는 해명은 <b>&lsquo;그루밍&rsquo; 논란</b>으로 이어지며, 연예계 전반에 큰 파장을 주고 있습니다.</p>\n<p data-ke-size=\"size16\">한 프로파일러는 해당 상황에 대해 <b>&ldquo;상대를 잘못 골랐다&rdquo;</b>며 사안의 심각성을 지적했습니다. 이번 논란은 단순한 해명이 아닌, <b>도덕성과 윤리적 판단에 대한 대중의 평가</b>로 이어지고 있으며, 김수현의 이미지 회복은 <b>당분간 쉽지 않을 것</b>으로 보입니다.</p>\n<hr data-ke-style=\"style1\" />\n<blockquote data-ke-style=\"style1\">\n<p data-ke-size=\"size16\">⚠️ 본 포스팅은 대중에 공개된 기사 및 자료에 기반해 작성된 콘텐츠로, 사실 여부에 대한 판단은 독자에게 맡깁니다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "2025년 3월 31일, 배우 김수현이 긴급 기자회견을 열고 故 김새론과의 관계에 대한 입장을 밝혔습니다. 하지만 이 해명 이후에도 대중의 의문은 가라앉지 않고 있습니다. 그 중심에는 “고등학교 2학년, 17세였던 김새론이 밤 11시에 김수현 가족이 있는 집에서 닭볶음탕을 만들었다는 정황”이 있습니다.\n▶ “연인이 아니었다”는 주장…하지만 그 밤의 정황은?\n김수현 측은 공식 입장에서 “당시 연인 관계가 아니었고, 가족들도 함께 있었다”고 해명했습니다. 논란이 된 영상은 2018년 6월 촬영된 것으로, 당시 김새론은 고등학교 2학년, 만 17세의 미성년자였습니다.\n해당 영상은 밤 11시 20분경 촬영되었으며, 식탁 위에는 소주병과 소주잔이 놓여 있었다는 점이 확인되며 더욱 논란이 커지고 있습니다. 소속사는 단순한 가족 식사 자리였다고 주장하지만, 많은 이들은 이 상황 자체를 납득하기 어렵다는 반응입니다.\n▶ “사귀지도 않았는데, 밤 11시에 가족 집에서 요리?”\n온라인 커뮤니티와 SNS에서는 다양한 반응이 이어지고 있습니다:\n“사귀지 않았다면 오히려 더 이상한 상황”\n“그 시간에 미성년자가 남자 집에 있었다는 것 자체가 부적절하다”\n“친구 사이여도 집에 돌려보낼 시간 아닌가?”\n또한, 김새론이 김수현에게 보냈다는 카카오톡 메시지 내용도 공개되었습니다. 메시지에는 “보고 싶어”, “언제 안고 잘 수 있어?” 등 연인 사이로 보일 수 있는 문구가 담겨 있었지만, 김수현 측은 “전면 조작된 메시지”라며 원본 데이터 제출을 요구한 상태입니다.\n▶ 해명에도 남은 의문…김수현 이미지 타격 불가피\n김수현 소속사는 “미성년자와의 교제는 결단코 없었다”며 법적 대응을 시사하고 있지만, 유튜브 채널 ‘가세연’ 측의 공세는 계속되고 있습니다. 특히 “사귄 적 없다”는 해명은 ‘그루밍’ 논란으로 이어지며, 연예계 전반에 큰 파장을 주고 있습니다.\n한 프로파일러는 해당 상황에 대해 “상대를 잘못 골랐다”며 사안의 심각성을 지적했습니다. 이번 논란은 단순한 해명이 아닌, 도덕성과 윤리적 판단에 대한 대중의 평가로 이어지고 있으며, 김수현의 이미지 회복은 당분간 쉽지 않을 것으로 보입니다.\n⚠️ 본 포스팅은 대중에 공개된 기사 및 자료에 기반해 작성된 콘텐츠로, 사실 여부에 대한 판단은 독자에게 맡깁니다.",
        "guid": "http://app-developer.tistory.com/206",
        "isoDate": "2025-04-11T14:18:10.000Z"
      }
    ]
  },
  {
    "name": "김도균",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김민석",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김동우",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권윤학",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김민준",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김만수",
    "category": "개인",
    "posts": []
  },
  {
    "name": "엘키",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권태환",
    "category": "개인",
    "posts": [
      {
        "title": "Composable Architecture는 만들었는데 문제가 있었네? 개선해보자.",
        "link": "https://thdev.tech/architecture/2025/04/15/Android-Architecture-02/",
        "pubDate": "Tue, 15 Apr 2025 00:00:00 +0000",
        "content": "<p>이전 글에서 Composable Architecutre를 소개하는 내용을 담아보았는데, 몇 가지 문제점을 발견하여 이를 개선한 내용을 다시 정리하는 글이다.</p>\n\n<p>크게 2가지 문제점을 확인하였다.</p>\n\n<ul>\n  <li>ViewModel 내 Reducer 처리 후 자동 next</li>\n  <li>Action 스트림 처리를 위한 싱글턴 활용 시 Lifecycle 문제</li>\n</ul>\n\n<p>이 2가지 문제점을 해결하기 위해 코드를 어떻게 수정했는지, 그리고 더 나은 방법은 없을지 고민한 과정을 정리해본다.</p>\n\n<h3>이 글에서는</h3>\n<ul>\n  <li>기존 아키텍처의 구조적 문제점을 파악한다.</li>\n  <li>문제 해결 과정과 더 나은 구조에 대한 고민을 공유한다.</li>\n  <li>기본적인 내용을 담지 않고있어 앞선 글을 참고하면 좋다.</li>\n</ul>\n\n<!--more-->\n\n<h2>Action이란?</h2>\n\n<p>View와 ViewModel 사이의 통신을 어떻게 더 간결하게 할 수 있을까? Jetpack Compose 환경에서는 <a href=\"https://developer.android.com/develop/ui/compose/compositionlocal\">CompositionLocal - link</a>을 활용하는 방법이 있다. 저는 이 방식을 응용하여 Composable 함수 어디서든 이벤트 처리를 쉽게 호출할 수 있도록 Action이라는 개념을 만들었다.</p>\n\n<p>Flow를 기반으로 한 Action을 사용한 이유를 설명하기 위해, 먼저 일반적인 View-ViewModel 간 통신 방식의 예시 코드를 살펴보자.</p>\n\n<p>Composable 함수에서 ViewModel 인스턴스를 파라미터로 직접 전달받아 사용하는 것이 일반적이다. 하지만 이 방식은 Composable 함수의 깊이가 깊어지거나 개수가 많아질수록 ViewModel을 어디까지 전달해야 할지 고민이 필요하며, 구조가 복잡해지면 자연스럽게 보일러플레이트 코드가 늘어나는 단점이 있다.</p>\n\n<h4>ViewModel을 직접 사용한 함수 호출</h4>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">someViewModel</span><span class=\"p\">:</span> <span class=\"nc\">SomeViewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">})</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">doSomethingTwo</span><span class=\"p\">()</span> <span class=\"p\">})</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">doSomethingThree</span><span class=\"p\">()</span> <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">SomeViewModel</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">fun</span> <span class=\"nf\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n  <span class=\"k\">fun</span> <span class=\"nf\">doSomethingTwo</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n  <span class=\"k\">fun</span> <span class=\"nf\">doSomethingThree</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h4>ViewModel 함수를 sealed interface로 통합하여 호출하는 경우</h4>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">sealed</span> <span class=\"kd\">interface</span> <span class=\"nc\">SomeAction</span> <span class=\"p\">{</span>\n    <span class=\"n\">data</span> <span class=\"kd\">object</span> <span class=\"nc\">ActionOne</span> <span class=\"p\">:</span> <span class=\"nc\">SomeAction</span>\n    <span class=\"n\">data</span> <span class=\"kd\">object</span> <span class=\"nc\">ActionTwo</span> <span class=\"p\">:</span> <span class=\"nc\">SomeAction</span>\n    <span class=\"kd\">data class</span> <span class=\"nc\">ActionThree</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">item</span><span class=\"p\">:</span> <span class=\"nc\">Any</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">SomeAction</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">someViewModel</span><span class=\"p\">:</span> <span class=\"nc\">SomeViewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">val</span> <span class=\"py\">item</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span> <span class=\"c1\">// 예시 데이터</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionOne</span><span class=\"p\">)</span> <span class=\"p\">})</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionTwo</span><span class=\"p\">)</span> <span class=\"p\">})</span>\n  <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">someViewModel</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionThree</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">))</span> <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">SomeViewModel</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">fun</span> <span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">SomeAction</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">when</span> <span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">is</span> <span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionOne</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n      <span class=\"k\">is</span> <span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionTwo</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n      <span class=\"k\">is</span> <span class=\"nc\">SomeAction</span><span class=\"p\">.</span><span class=\"nc\">ActionThree</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h4>제가 활용하는 방식 (CompositionLocal 활용)</h4>\n\n<p>위 방식들은 ViewModel을 계속 전달하거나, <code class=\"language-plaintext highlighter-rouge\">onClick: () -&gt; Unit</code> 같은 콜백을 계속 만들어 전달해야 하는 번거로움이 있다. 특히 콜백 방식은 이벤트 통합 과정에서 N개의 고차 함수(Higher-Order function)가 만들어질 수 있다.</p>\n\n<p>그래서 Compose에서 제공하는 <a href=\"https://developer.android.com/develop/ui/compose/compositionlocal\">Locally scoped - link</a>을 활용하여 Action 객체에 쉽게 접근하는 방법을 사용하고 있습니다. (자세한 활용법은 이전 글 <a href=\"https://thdev.tech/architecture/2025/02/02/Android-Architecture-01/\">컴포즈에 사용할 Composable Architecture 설명</a>을 참고해주세요.)</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Action 정의 (예시)</span>\n<span class=\"k\">sealed</span> <span class=\"kd\">interface</span> <span class=\"nc\">MyScreenAction</span> <span class=\"p\">:</span> <span class=\"nc\">CaAction</span> <span class=\"p\">{</span> <span class=\"c1\">// CaAction은 마커 인터페이스 역할</span>\n    <span class=\"n\">data</span> <span class=\"kd\">object</span> <span class=\"nc\">ButtonClick</span> <span class=\"p\">:</span> <span class=\"nc\">MyScreenAction</span>\n    <span class=\"kd\">data class</span> <span class=\"nc\">TextTyped</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">text</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">MyScreenAction</span>\n    <span class=\"kd\">data class</span> <span class=\"nc\">SwitchChanged</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">isOn</span><span class=\"p\">:</span> <span class=\"nc\">Boolean</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">MyScreenAction</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Composable View</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// CompositionLocal을 통해 ActionDispatcher 획득</span>\n  <span class=\"kd\">val</span> <span class=\"py\">actionDispatcher</span> <span class=\"p\">=</span> <span class=\"nc\">LocalActionDispatcher</span><span class=\"p\">.</span><span class=\"n\">current</span>\n  <span class=\"kd\">var</span> <span class=\"py\">textState</span> <span class=\"k\">by</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nf\">mutableStateOf</span><span class=\"p\">(</span><span class=\"s\">\"\"</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n  <span class=\"kd\">var</span> <span class=\"py\">switchState</span> <span class=\"k\">by</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nf\">mutableStateOf</span><span class=\"p\">(</span><span class=\"k\">false</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n\n  <span class=\"nc\">Column</span> <span class=\"p\">{</span>\n      <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">actionDispatcher</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">ButtonClick</span><span class=\"p\">)</span> <span class=\"p\">})</span> <span class=\"p\">{</span>\n          <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Click Me\"</span><span class=\"p\">)</span>\n      <span class=\"p\">}</span>\n      <span class=\"nc\">TextField</span><span class=\"p\">(</span>\n          <span class=\"n\">value</span> <span class=\"p\">=</span> <span class=\"n\">textState</span><span class=\"p\">,</span>\n          <span class=\"n\">onValueChange</span> <span class=\"p\">=</span> <span class=\"p\">{</span>\n              <span class=\"n\">textState</span> <span class=\"p\">=</span> <span class=\"n\">it</span>\n              <span class=\"n\">actionDispatcher</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">TextTyped</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">))</span>\n          <span class=\"p\">}</span>\n      <span class=\"p\">)</span>\n      <span class=\"nc\">Switch</span><span class=\"p\">(</span>\n          <span class=\"n\">checked</span> <span class=\"p\">=</span> <span class=\"n\">switchState</span><span class=\"p\">,</span>\n          <span class=\"n\">onCheckedChange</span> <span class=\"p\">=</span> <span class=\"p\">{</span>\n              <span class=\"n\">switchState</span> <span class=\"p\">=</span> <span class=\"n\">it</span>\n              <span class=\"n\">actionDispatcher</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">SwitchChanged</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">))</span>\n          <span class=\"p\">}</span>\n      <span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// ViewModel</span>\n<span class=\"kd\">class</span> <span class=\"nc\">SomeViewModel</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">flowCaActionStream</span><span class=\"p\">:</span> <span class=\"nc\">FlowCaActionStream</span> <span class=\"c1\">// Action 스트림 주입</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"nc\">MyScreenAction</span><span class=\"p\">&gt;(</span><span class=\"n\">flowCaActionStream</span><span class=\"p\">,</span> <span class=\"nc\">MyScreenAction</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 수신할 Action 타입 지정</span>\n\n    <span class=\"c1\">// CaViewModel 내부에서 flowAction을 통해 MyScreenAction 타입의 이벤트만 필터링하여 수신</span>\n    <span class=\"c1\">// reducer 메소드에서 각 Action 처리 로직 구현</span>\n    <span class=\"k\">override</span> <span class=\"k\">suspend</span> <span class=\"k\">fun</span> <span class=\"nf\">reducer</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">MyScreenAction</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">when</span> <span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">is</span> <span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">ButtonClick</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 버튼 클릭 처리 로직</span>\n                <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">d</span><span class=\"p\">(</span><span class=\"s\">\"SomeViewModel\"</span><span class=\"p\">,</span> <span class=\"s\">\"Button Clicked\"</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">is</span> <span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">TextTyped</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 텍스트 입력 처리 로직</span>\n                <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">d</span><span class=\"p\">(</span><span class=\"s\">\"SomeViewModel\"</span><span class=\"p\">,</span> <span class=\"s\">\"Text Typed: ${action.text}\"</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">is</span> <span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">SwitchChanged</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 스위치 변경 처리 로직</span>\n                <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">d</span><span class=\"p\">(</span><span class=\"s\">\"SomeViewModel\"</span><span class=\"p\">,</span> <span class=\"s\">\"Switch Changed: ${action.isOn}\"</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<h2>사용성 측면에서의 개선</h2>\n\n<p>필요한 Action을 <code class=\"language-plaintext highlighter-rouge\">LocalAction.current</code>를 통해 어디서든 호출할 수 있으므로, ViewModel 인스턴스를 계속해서 하위 Composable로 전달할 필요가 없어 개발 편의성이 향상될 수 있다.</p>\n\n<p>CompositionLocal에 적절한 기본값이나 테스트용 구현체를 제공하면 Preview 동작에도 문제가 없다. 다만, Preview에서 특정 UI 요소의 상태 변화나 인터랙션을 테스트하려면, 선언형 UI의 원칙에 따라 <a href=\"https://developer.android.com/develop/ui/compose/state\">Stateless - link</a>한 Composable을 만들고 상태와 이벤트를 외부에서 주입하는 것이 좋다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Stateless Composable 예시</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeContent</span><span class=\"p\">(</span>\n    <span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span>\n    <span class=\"n\">isSwitchOn</span><span class=\"p\">:</span> <span class=\"nc\">Boolean</span><span class=\"p\">,</span>\n    <span class=\"n\">onButtonClick</span><span class=\"p\">:</span> <span class=\"p\">()</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">,</span>\n    <span class=\"n\">onTextTyped</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"nc\">String</span><span class=\"p\">)</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">,</span>\n    <span class=\"n\">onSwitchChange</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"nc\">Boolean</span><span class=\"p\">)</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">,</span>\n    <span class=\"n\">modifier</span><span class=\"p\">:</span> <span class=\"nc\">Modifier</span> <span class=\"p\">=</span> <span class=\"nc\">Modifier</span> <span class=\"c1\">// Modifier 추가 권장</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nc\">Column</span><span class=\"p\">(</span><span class=\"n\">modifier</span> <span class=\"p\">=</span> <span class=\"n\">modifier</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"n\">onButtonClick</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"cm\">/* ... */</span> <span class=\"p\">}</span>\n        <span class=\"nc\">TextField</span><span class=\"p\">(</span><span class=\"n\">value</span> <span class=\"p\">=</span> <span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">onValueChange</span> <span class=\"p\">=</span> <span class=\"n\">onTextTyped</span><span class=\"p\">)</span>\n        <span class=\"nc\">Switch</span><span class=\"p\">(</span><span class=\"n\">checked</span> <span class=\"p\">=</span> <span class=\"n\">isSwitchOn</span><span class=\"p\">,</span> <span class=\"n\">onCheckedChange</span> <span class=\"p\">=</span> <span class=\"n\">onSwitchChange</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Statefull Composable (ViewModel과 연결)</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">SomeViewModel</span> <span class=\"p\">=</span> <span class=\"nf\">hiltViewModel</span><span class=\"p\">())</span> <span class=\"p\">{</span> <span class=\"c1\">// Hilt 등 DI 활용 예시</span>\n    <span class=\"kd\">val</span> <span class=\"py\">actionDispatcher</span> <span class=\"p\">=</span> <span class=\"nc\">LocalActionDispatcher</span><span class=\"p\">.</span><span class=\"n\">current</span> <span class=\"c1\">// Action 발송기</span>\n    <span class=\"c1\">// ViewModel로부터 상태를 구독하거나, 필요한 상태를 여기서 관리</span>\n    <span class=\"kd\">val</span> <span class=\"py\">textState</span> <span class=\"k\">by</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"n\">textState</span><span class=\"p\">.</span><span class=\"nf\">collectAsState</span><span class=\"p\">()</span> <span class=\"c1\">// 예시 StateFlow</span>\n    <span class=\"kd\">val</span> <span class=\"py\">switchState</span> <span class=\"k\">by</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"n\">switchState</span><span class=\"p\">.</span><span class=\"nf\">collectAsState</span><span class=\"p\">()</span> <span class=\"c1\">// 예시 StateFlow</span>\n\n    <span class=\"nc\">SomeContent</span><span class=\"p\">(</span>\n        <span class=\"n\">text</span> <span class=\"p\">=</span> <span class=\"n\">textState</span><span class=\"p\">,</span>\n        <span class=\"n\">isSwitchOn</span> <span class=\"p\">=</span> <span class=\"n\">switchState</span><span class=\"p\">,</span>\n        <span class=\"n\">onButtonClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">actionDispatcher</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">ButtonClick</span><span class=\"p\">)</span> <span class=\"p\">},</span>\n        <span class=\"n\">onTextTyped</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">actionDispatcher</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">TextTyped</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">))</span> <span class=\"p\">},</span>\n        <span class=\"n\">onSwitchChange</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">actionDispatcher</span><span class=\"p\">.</span><span class=\"nf\">dispatch</span><span class=\"p\">(</span><span class=\"nc\">MyScreenAction</span><span class=\"p\">.</span><span class=\"nc\">SwitchChanged</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">))</span> <span class=\"p\">}</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이 방식(Stateless/Statefull 분리 및 CompositionLocal 활용)의 단점은 다음과 같다.</p>\n\n<ul>\n  <li>ViewModel에서 모든 UI 인터랙션을 하나의 reducer 함수로 통합 관리하기보다, 각 상태 업데이트 로직과 이벤트 발송 로직이 분리될 수 있다. (이는 관점에 따라 장점일 수도 있다)</li>\n  <li>새로운 Action 이벤트를 추가할 때, ViewModel의 reducer에서도 해당 이벤트를 처리하는 로직을 추가해야 한다. (이는 sealed interface 사용 시 컴파일 타임에 강제될 수 있어 오히려 장점이 될 수 있다.)</li>\n</ul>\n\n<p>하지만 장점은 다음과 같습니다.</p>\n<ul>\n  <li>각 UI 요소의 이벤트 발송 책임이 명확해진다.</li>\n  <li>Stateless Composable은 재사용 및 테스트가 용이하다.</li>\n  <li>CompositionLocal을 통해 이벤트 발송 인터페이스 접근이 간편하다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3>정리하면</h3>\n\n<h4>해결하고 싶었던 지점</h4>\n\n<ul>\n  <li>View와 ViewModel 간의 이벤트 전달을 왜 항상 ViewModel 인스턴스를 통해 viewModel.someFunction() 형태로 직접 호출해야 할까?</li>\n  <li>Composable 함수의 깊이가 깊어질 때 ViewModel 인스턴스나 콜백 함수를 계속 전달해야 하는 번거로움을 줄일 수 없을까?</li>\n</ul>\n\n<h4>그래서 도입한 Action(CompositionLocal)</h4>\n\n<p>이벤트 처리를 위한 Action 인터페이스와 이를 쉽게 발송(dispatch)할 수 있는 ActionDispatcher를 CompositionLocal로 제공하여, Composable 함수 내에서 발생하는 보일러플레이트를 줄이고자 했다.</p>\n\n<p>하지만 여전히 해결해야 할 문제가 있는데</p>\n\n<ul>\n  <li>이벤트를 보내는 쪽(View)과 받는 쪽(ViewModel)에서 정확히 어떤 Action 타입을 사용하고 처리할지 명확히 약속이 필요하다. 만약 서로 다른 타입을 사용하거나 누락하면 이벤트가 유실되어 동작하지 않는 치명적인 문제가 발생할 수 있다.</li>\n</ul>\n\n<p>이 문제를 해결하고 개발 과정에서 실수를 줄이기 위해 <code class=\"language-plaintext highlighter-rouge\">sealed interface</code>를 사용하여 <code class=\"language-plaintext highlighter-rouge\">Action</code>을 정의하는 방식을 채택했다. sealed interface를 사용하면 ViewModel의 reducer에서 when 식으로 처리할 때 모든 하위 타입을 강제로 구현해야 하므로, 이벤트 누락 가능성을 컴파일 시점에 방지할 수 있다. 이는 UI 동작 관련 테스트 케이스를 일부 줄여줄 수 있는 장점도 있다.</p>\n\n<p><br /></p>\n\n<h2>그래서 발견한 문제</h2>\n\n<p><a href=\"https://github.com/pointfreeco/swift-composable-architecture\">Swift-composable architecture - 링크</a>를 참고하여 아키텍처를 구상하다 보니, Reducer가 특정 액션을 처리한 후 다음 액션을 연쇄적으로 발생시키는 구조를 발견했다.</p>\n\n<p>Swift Composable Architecture의 코드 예시를 보면, Reduce 클로저 내에서 <code class=\"language-plaintext highlighter-rouge\">.send</code>나 다른 이펙트(Effect)를 반환하여 다음 동작을 유발할 수 있다. (아래 코드는 TCA의 이전 버전 구문일 수 있으며, 현재는 @Reducer 매크로 등을 사용한다.)</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// TCA 예시 (개념 설명용)</span>\n<span class=\"kt\">Reduce</span> <span class=\"p\">{</span> <span class=\"n\">state</span><span class=\"p\">,</span> <span class=\"n\">action</span> <span class=\"k\">in</span>\n  <span class=\"k\">switch</span> <span class=\"n\">action</span> <span class=\"p\">{</span>\n  <span class=\"k\">case</span> <span class=\"o\">.</span><span class=\"nv\">buttonTapped</span><span class=\"p\">:</span>\n    <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">isLoading</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n    <span class=\"c1\">// 이펙트를 반환하여 비동기 작업 후 다른 액션(.dataLoaded)을 발생시킴</span>\n    <span class=\"k\">return</span> <span class=\"o\">.</span><span class=\"n\">run</span> <span class=\"p\">{</span> <span class=\"n\">send</span> <span class=\"k\">in</span>\n      <span class=\"k\">let</span> <span class=\"nv\">data</span> <span class=\"o\">=</span> <span class=\"k\">try</span> <span class=\"k\">await</span> <span class=\"n\">apiClient</span><span class=\"o\">.</span><span class=\"nf\">fetchData</span><span class=\"p\">()</span>\n      <span class=\"k\">await</span> <span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">dataLoaded</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">))</span>\n    <span class=\"p\">}</span>\n  <span class=\"k\">case</span> <span class=\"kd\">let</span> <span class=\"o\">.</span><span class=\"nf\">dataLoaded</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">):</span>\n    <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">isLoading</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n    <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">data</span>\n    <span class=\"k\">return</span> <span class=\"o\">.</span><span class=\"k\">none</span> <span class=\"c1\">// 추가 액션 없음</span>\n  <span class=\"c1\">// ...</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이러한 ‘액션 후 연쇄 액션’ 개념을 안드로이드에서 Flow와 제가 만든 Action 시스템으로 구현해보고자 했다. 하지만 여기서 두 가지 주요 문제가 발생했다.</p>\n\n<ol>\n  <li>자동 nextAction 호출로 인한 문제:\n    <ul>\n      <li>ViewModel의 reducer 함수가 반환하는 값을 기반으로 시스템이 자동으로 다음 액션(nextAction)을 발생시키도록 설계했더니, 개발자가 이 동작 방식을 정확히 이해하고 사용해야 하는 부담이 늘었다. 알아야 할 규칙이 많아진 것.</li>\n      <li>결정적으로, nextAction을 잘못 지정하거나 reducer 로직에 실수가 있으면 무한 루프에 빠질 위험이 있었다. 디버깅이 불가능한 것은 아니지만, 코드 설계상 예측 가능한 문제가 쉽게 발생할 수 있는 구조였다.</li>\n    </ul>\n  </li>\n  <li>싱글턴 Action 스트림과 Lifecycle 동기화 문제:\n    <ul>\n      <li>앱 전체에서 단 하나의 Action 스트림(FlowCaActionStream)을 싱글턴으로 사용하다 보니, 새로운 Activity가 실행되거나 Composable Navigation 라이브러리(like Navigation-Compose)를 통해 화면이 전환될 때 문제가 발생했다.</li>\n      <li>예를 들어, Activity A와 Activity B가 있고 각각 여러 Composable 화면(Screen)을 가지고 있다고 가정해 보자. 사용자가 Activity B에 있더라도, 백그라운드의 Activity A에 속한 ViewModel들이 여전히 싱글턴 Action 스트림을 구독하고 있을 수 있다. 만약 특정 Action이 Activity B에서 발생했는데, Activity A의 ViewModel도 해당 Action 타입에 대해 필터링 로직(filterIsInstance)을 가지고 있다면, 의도치 않게 Activity A의 ViewModel에서도 해당 Action이 처리될 수 있다. (물론 reducer 로직 내에서 현재 화면 상태 등을 체크하여 방어할 수는 있겠지만, 근본적으로 불필요한 구독 및 처리 시도가 발생한다.)</li>\n      <li>이는 특히 Alert, Toast, Router(화면 전환)와 같이 앱 전역적으로 영향을 줄 수 있는 Side Effect 처리 시 동기화 문제를 일으킬 수 있다. ViewModel의 생명주기(viewModelScope)는 일반적으로 Composable의 생명주기보다 길기 때문에 이 문제가 더 두드러진다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>이 두 가지 문제를 어떻게 해결했는지 구체적으로 설명하겠다.</p>\n\n<p><br /></p>\n\n<h2>문제점 1 - 무한 루프 가능성 해결하기</h2>\n\n<p>무한 루프 발생 가능성을 제거하기 위해 기존 CaViewModel의 flowAction 처리 방식에서 문제의 소지가 있는 부분을 수정했다.</p>\n\n<p>기존 코드 (문제 발생 가능성 있음):</p>\n\n<pre><code class=\"language-kotiln\">abstract class CaViewModel&lt;ACTION : CaAction, SIDE_EFFECT : CaSideEffect&gt;(\n    private val flowCaActionStream: FlowCaActionStream, // 'private' 추가 (캡슐화)\n    actionClass: KClass&lt;ACTION&gt;,\n) : ViewModel() {\n\n    @VisibleForTesting\n    val flowAction by lazy(LazyThreadSafetyMode.NONE) {\n        flowCaActionStream.flowAction()\n            .filterIsInstance(actionClass) // 1. 해당 ViewModel이 처리할 Action만 필터링\n            .map { action -&gt; // 2. reducer를 호출하고, 그 결과를 반환 (문제의 소지)\n                reducer(action = action) // reducer가 다음 Action을 반환한다고 가정\n            }\n            .onEach { nextActionToDispatch -&gt; // 3. map에서 반환된 다음 Action을 자동으로 전파 (문제!)\n                flowCaActionStream.nextAction(nextActionToDispatch) // 무한 루프 가능 지점\n            }\n            // .launchIn(viewModelScope) // 실제로는 여기서 launch 되어야 함\n    }\n\n    // reducer 함수가 다음 Action을 반환하는 형태였다고 가정\n    abstract suspend fun reducer(action: ACTION): CaAction? // 예시: 반환 타입이 다음 Action\n}\n</code></pre>\n\n<p>수정된 코드:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"nc\">CA_ACTION</span> <span class=\"p\">:</span> <span class=\"nc\">CaAction</span><span class=\"p\">&gt;(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">flowCaActionStream</span><span class=\"p\">:</span> <span class=\"nc\">FlowCaActionStream</span><span class=\"p\">,</span>\n    <span class=\"n\">actionClass</span><span class=\"p\">:</span> <span class=\"nc\">KClass</span><span class=\"p\">&lt;</span><span class=\"nc\">CA_ACTION</span><span class=\"p\">&gt;,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\n    <span class=\"c1\">// Action 처리를 위한 Flow (자동 nextAction 로직 제거)</span>\n    <span class=\"nd\">@VisibleForTesting</span>\n    <span class=\"k\">internal</span> <span class=\"kd\">val</span> <span class=\"py\">actionProcessingFlow</span> <span class=\"k\">by</span> <span class=\"nf\">lazy</span><span class=\"p\">(</span><span class=\"nc\">LazyThreadSafetyMode</span><span class=\"p\">.</span><span class=\"nc\">NONE</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 'internal'로 변경하고 이름 명확화</span>\n        <span class=\"n\">flowCaActionStream</span><span class=\"p\">.</span><span class=\"nf\">flowAction</span><span class=\"p\">()</span>\n            <span class=\"p\">.</span><span class=\"nf\">filterIsInstance</span><span class=\"p\">(</span><span class=\"n\">actionClass</span><span class=\"p\">)</span> <span class=\"c1\">// 1. 처리할 Action 필터링</span>\n            <span class=\"p\">.</span><span class=\"nf\">onEach</span> <span class=\"p\">{</span> <span class=\"n\">action</span> <span class=\"p\">-&gt;</span> <span class=\"c1\">// 2. map 대신 onEach 사용. 각 Action에 대해 reducer만 실행 (반환값 사용 안 함)</span>\n                <span class=\"nf\">reducer</span><span class=\"p\">(</span><span class=\"n\">action</span> <span class=\"p\">=</span> <span class=\"n\">action</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n            <span class=\"c1\">// 3. 자동 nextAction 전파 로직 제거됨</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// reducer 함수는 이제 Side Effect 처리나 상태 변경에만 집중 (반환값 없음)</span>\n    <span class=\"k\">abstract</span> <span class=\"k\">suspend</span> <span class=\"k\">fun</span> <span class=\"nf\">reducer</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">CA_ACTION</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">// 다음 Action을 명시적으로 전파하고 싶을 때 호출하는 함수 추가</span>\n    <span class=\"k\">protected</span> <span class=\"k\">fun</span> <span class=\"nf\">nextAction</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nc\">CaAction</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 'protected'로 변경하여 자식 클래스에서만 사용하도록 제한</span>\n        <span class=\"n\">flowCaActionStream</span><span class=\"p\">.</span><span class=\"nf\">nextAction</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 실제 Flow 구독 시작/취소는 별도 관리 (아래 Lifecycle 해결 부분 참조)</span>\n    <span class=\"nd\">@VisibleForTesting</span>\n    <span class=\"kd\">var</span> <span class=\"py\">actionProcessingJob</span><span class=\"p\">:</span> <span class=\"nc\">Job</span><span class=\"p\">?</span> <span class=\"p\">=</span> <span class=\"k\">null</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>수정 내용 요약:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">map</code> -&gt; <code class=\"language-plaintext highlighter-rouge\">onEach</code> 변경: <code class=\"language-plaintext highlighter-rouge\">reducer</code> 함수가 다음 Action을 반환하고 이를 <code class=\"language-plaintext highlighter-rouge\">map</code> 연산자가 받아 downstream로 흘려보내는 구조를 제거했다. 대신 onEach를 사용하여 각 Action에 대해 reducer 함수를 실행만 하도록 변경다. 이로써 reducer의 반환값과 관계없이 자동 nextAction 호출 가능성이 사라졌다.</li>\n  <li>명시적 <code class=\"language-plaintext highlighter-rouge\">nextAction</code> 함수 추가: 연쇄적인 Action 전파가 필요한 경우, 개발자가 <code class=\"language-plaintext highlighter-rouge\">reducer</code> 함수 내에서 직접 <code class=\"language-plaintext highlighter-rouge\">nextAction(action)</code> 함수를 호출하도록 변경했다. 이는 시스템에 의한 암묵적인 동작 대신, 개발자의 명확한 의도에 따라 다음 Action이 발생하도록 하여 코드의 예측 가능성을 높인다.</li>\n</ul>\n\n<p>이제 reducer 내에서 다음과 같이 명시적으로 다음 Action을 지정해야 한다.</p>\n\n<pre><code class=\"language-koltin\">override suspend fun reducer(action: MyScreenAction) {\n    when (action) {\n        is MyScreenAction.ButtonClick -&gt; {\n            // 예시: 버튼 클릭 후 특정 조건 만족 시 Alert 표시 Action 전파\n            if (shouldShowAlert()) {\n                nextAction(CommonUiAction.ShowAlert(\"버튼 클릭됨!\")) // 명시적으로 nextAction 호출\n            }\n        }\n        // ... 다른 Action 처리\n    }\n}\n</code></pre>\n\n<p>이 변경으로 시스템적인 무한 루프 발생 가능성은 제거되었고, 코드의 흐름이 더 명확해졌다.</p>\n\n<p><br /></p>\n\n<h2>문제점 2 - Lifecycle 문제 해결하기</h2>\n\n<p>싱글턴 Action 스트림(FlowCaActionStream) 사용 시 발생하는 Lifecycle 동기화 문제를 해결하기 위해, Composable의 Lifecycle에 맞춰 ViewModel의 Action 스트림 구독을 시작하고 중지하는 방식을 도입했다.</p>\n\n<p>문제 상황: Activity A와 B가 있을 때, Activity B가 화면에 보이는 동안에도 백그라운드의 Activity A에 있는 ViewModel이 Action 스트림을 계속 구독하고 있으면, Activity B에서 발생한 Action이 Activity A의 ViewModel에게도 전달될 수 있다. (물론 filterIsInstance로 타입 필터링은 되지만, 같은 타입의 Action을 여러 화면에서 사용한다면 문제가 된다.)</p>\n\n<p><img src=\"/images/posts/2025/Android-Architecture-02/sample_01.jpg\" alt=\"sample_01\" /></p>\n\n<p><br /></p>\n\n<h3>해결 방안: Lifecycle에 따른 구독 제어</h3>\n\n<p>Composable의 Lifecycle 상태(특히 <code class=\"language-plaintext highlighter-rouge\">ON_RESUME</code>, <code class=\"language-plaintext highlighter-rouge\">ON_PAUSE</code>)에 맞춰 ViewModel 내 Action 스트림(<code class=\"language-plaintext highlighter-rouge\">actionProcessingFlow</code>)의 구독(Job)을 시작하고 취소하는 방법을 사용합니다. 이를 위해 <code class=\"language-plaintext highlighter-rouge\">DisposableEffect</code>와 <code class=\"language-plaintext highlighter-rouge\">LocalLifecycleOwner</code>를 활용하는 Helper Composable 함수를 만들었습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">LaunchedLifecycleViewModel</span><span class=\"p\">(</span>\n    <span class=\"n\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;</span> <span class=\"c1\">// 라이프사이클 관리가 필요한 ViewModel</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">lifecycleOwner</span> <span class=\"p\">=</span> <span class=\"nc\">LocalLifecycleOwner</span><span class=\"p\">.</span><span class=\"n\">current</span>\n    <span class=\"nc\">DisposableEffect</span><span class=\"p\">(</span><span class=\"n\">lifecycleOwner</span><span class=\"p\">,</span> <span class=\"n\">viewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// lifecycleOwner와 viewModel이 키</span>\n        <span class=\"kd\">val</span> <span class=\"py\">observer</span> <span class=\"p\">=</span> <span class=\"nc\">LifecycleEventObserver</span> <span class=\"p\">{</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">event</span> <span class=\"p\">-&gt;</span>\n            <span class=\"k\">when</span> <span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"nc\">Lifecycle</span><span class=\"p\">.</span><span class=\"nc\">Event</span><span class=\"p\">.</span><span class=\"nc\">ON_RESUME</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                    <span class=\"c1\">// 화면이 활성화되면 Action 스트림 구독 시작</span>\n                    <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">startActionProcessing</span><span class=\"p\">()</span>\n                <span class=\"p\">}</span>\n                <span class=\"nc\">Lifecycle</span><span class=\"p\">.</span><span class=\"nc\">Event</span><span class=\"p\">.</span><span class=\"nc\">ON_PAUSE</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span>\n                    <span class=\"c1\">// 화면이 비활성화되면 Action 스트림 구독 취소</span>\n                    <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">cancelActionProcessing</span><span class=\"p\">()</span>\n                <span class=\"p\">}</span>\n                <span class=\"c1\">// ON_DESTROY는 DisposableEffect의 onDispose에서 처리되거나</span>\n                <span class=\"c1\">// ViewModel의 onCleared에서 처리될 수 있음</span>\n                <span class=\"k\">else</span> <span class=\"p\">-&gt;</span> <span class=\"p\">{</span> <span class=\"cm\">/* Do nothing for other events */</span> <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">lifecycleOwner</span><span class=\"p\">.</span><span class=\"n\">lifecycle</span><span class=\"p\">.</span><span class=\"nf\">addObserver</span><span class=\"p\">(</span><span class=\"n\">observer</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// Composable이 Composition에서 제거될 때(onDispose) Observer 제거</span>\n        <span class=\"nf\">onDispose</span> <span class=\"p\">{</span>\n            <span class=\"n\">lifecycleOwner</span><span class=\"p\">.</span><span class=\"n\">lifecycle</span><span class=\"p\">.</span><span class=\"nf\">removeObserver</span><span class=\"p\">(</span><span class=\"n\">observer</span><span class=\"p\">)</span>\n            <span class=\"c1\">// 필요하다면 여기서도 cancelActionProcessing() 호출 고려</span>\n            <span class=\"c1\">// viewModel.cancelActionProcessing()</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>그리고 <code class=\"language-plaintext highlighter-rouge\">CaViewModel</code>에 <code class=\"language-plaintext highlighter-rouge\">Action</code> 스트림 구독을 시작하고 취소하는 함수를 추가한다. (<code class=\"language-plaintext highlighter-rouge\">internal</code> 접근 제한자를 사용하여 모듈 외부에서의 직접 호출을 방지한다.)</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"nc\">CA_ACTION</span> <span class=\"p\">:</span> <span class=\"nc\">CaAction</span><span class=\"p\">&gt;(</span>\n    <span class=\"c1\">// ... (이전 코드와 동일)</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\n    <span class=\"c1\">// ... (actionProcessingFlow, reducer, nextAction 등) ...</span>\n\n    <span class=\"nd\">@VisibleForTesting</span>\n    <span class=\"kd\">var</span> <span class=\"py\">actionProcessingJob</span><span class=\"p\">:</span> <span class=\"nc\">Job</span><span class=\"p\">?</span> <span class=\"p\">=</span> <span class=\"k\">null</span> <span class=\"c1\">// 구독 상태를 관리하는 Job</span>\n\n    <span class=\"c1\">// Action 스트림 구독 시작 (ON_RESUME 시 호출됨)</span>\n    <span class=\"k\">internal</span> <span class=\"k\">fun</span> <span class=\"nf\">startActionProcessing</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 이미 실행 중이라면 중복 실행 방지</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">actionProcessingJob</span><span class=\"o\">?.</span><span class=\"n\">isActive</span> <span class=\"p\">==</span> <span class=\"k\">true</span><span class=\"p\">)</span> <span class=\"k\">return</span>\n\n        <span class=\"c1\">// 기존 Job이 있다면 취소 (혹시 모를 상황 대비)</span>\n        <span class=\"nf\">cancelActionProcessing</span><span class=\"p\">()</span>\n\n        <span class=\"c1\">// actionProcessingFlow를 viewModelScope에서 구독 시작</span>\n        <span class=\"n\">actionProcessingJob</span> <span class=\"p\">=</span> <span class=\"n\">actionProcessingFlow</span>\n            <span class=\"p\">.</span><span class=\"nf\">launchIn</span><span class=\"p\">(</span><span class=\"n\">viewModelScope</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// Action 스트림 구독 취소 (ON_PAUSE 시 호출됨)</span>\n    <span class=\"k\">internal</span> <span class=\"k\">fun</span> <span class=\"nf\">cancelActionProcessing</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">actionProcessingJob</span><span class=\"o\">?.</span><span class=\"nf\">cancel</span><span class=\"p\">()</span>\n        <span class=\"n\">actionProcessingJob</span> <span class=\"p\">=</span> <span class=\"k\">null</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// ViewModel이 파괴될 때(onCleared) 확실하게 Job 취소</span>\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">onCleared</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">super</span><span class=\"p\">.</span><span class=\"nf\">onCleared</span><span class=\"p\">()</span>\n        <span class=\"nf\">cancelActionProcessing</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3>위 코드를 활용하는 방법은?</h3>\n\n<p>각 화면의 최상위 Composable에서 ObserveLifecycle 함수를 호출해주어야 한다.</p>\n\n<pre><code class=\"language-koltin\">@Composable\nfun SomeScreen(viewModel: SomeViewModel = hiltViewModel()) {\n    // ViewModel의 Action 구독 라이프사이클 관리\n    LaunchedLifecycleViewModel(viewModel = viewModel)\n\n    // --- 실제 UI ---\n    // val state by viewModel.uiState.collectAsState()\n    // SomeContent(...)\n    // ---\n}\n</code></pre>\n\n<p>개선 아이디어: 매번 ObserveLifecycle(viewModel)를 호출하는 것이 번거롭다면, ViewModel 인스턴스를 얻을 때 자동으로 이 로직을 포함시키는 확장 함수나 위임(delegate)을 고려해볼 수 있다. 예를 들어:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">Some</span><span class=\"p\">(</span><span class=\"n\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">ViewModel</span> <span class=\"p\">=</span> <span class=\"nf\">hiltViewModel</span><span class=\"p\">().</span><span class=\"nc\">Activate</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// Your view</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>또는 hilt를 직접 확장한다면 아래와 같다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 개념적인 아이디어 (구현 필요)</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">inline</span> <span class=\"k\">fun</span> <span class=\"p\">&lt;</span><span class=\"k\">reified</span> <span class=\"nc\">VM</span> <span class=\"p\">:</span> <span class=\"nc\">CaViewModel</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;&gt;</span> <span class=\"nf\">hiltViewModelWithLifecycle</span><span class=\"p\">():</span> <span class=\"nc\">VM</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">VM</span> <span class=\"p\">=</span> <span class=\"nf\">hiltViewModel</span><span class=\"p\">()</span>\n    <span class=\"nc\">LaunchedLifecycleViewModel</span><span class=\"p\">(</span><span class=\"n\">viewModel</span> <span class=\"p\">=</span> <span class=\"n\">viewModel</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">viewModel</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 사용 예시</span>\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">SomeScreen</span><span class=\"p\">(</span><span class=\"n\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">SomeViewModel</span> <span class=\"p\">=</span> <span class=\"nf\">hiltViewModelWithLifecycle</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 이제 LaunchedLifecycleViewModel() 호출 불필요</span>\n    <span class=\"c1\">// ... UI ...</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>(Gemini 주의: <code class=\"language-plaintext highlighter-rouge\">hiltViewModelWithLifecycle</code> 같은 함수는 Composable 함수 내에서 다른 Composable 함수(LaunchedLifecycleViewModel)를 호출하는 방식이므로, ViewModel 생성 로직과 Lifecycle 관찰 로직을 분리하는 것이 더 좋을 수 있다. 또는 별도의 진입점 Composable에서 처리하는 방식도 고려할 수 있다.)</p>\n\n<p>고려사항:</p>\n<ul>\n  <li>이 방식은 ViewModel이 간접적으로 UI Lifecycle을 인지하게 되는 것 아니냐는 비판이 있을 수 있다. 하지만 start/cancelActionProcessing 함수 호출 시점은 ViewModel 외부(LaunchedLifecycleViewModel)에서 결정되므로, ViewModel 자체는 Lifecycle 객체를 직접 참조하지 않는다.</li>\n  <li>ON_RESUME / ON_PAUSE 이벤트마다 Job을 취소하고 다시 시작하는 오버헤드가 발생할 수 있다. 하지만 이는 화면이 실제로 보이지 않을 때 불필요한 Action 처리를 방지하는 효과적인 방법 중 하나이다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2>해결했을까?</h2>\n\n<p>위 변경 사항들을 통해 초기 설계에서 발견된 두 가지 주요 문제점을 해결할 수 있었다.</p>\n\n<ul>\n  <li>무한 루프 발생 가능성: <code class=\"language-plaintext highlighter-rouge\">reducer</code> 처리 후 자동 <code class=\"language-plaintext highlighter-rouge\">nextAction</code> 전파 로직을 제거하고, 명시적인 <code class=\"language-plaintext highlighter-rouge\">nextAction</code> 함수 호출 방식으로 변경하여 해결했다.</li>\n  <li>싱글턴 <code class=\"language-plaintext highlighter-rouge\">Action</code> 스트림의 Lifecycle 문제: Composable의 Lifecycle에 맞춰 ViewModel의 Action 스트림 구독을 제어하는 <code class=\"language-plaintext highlighter-rouge\">LaunchedLifecycleViewModel</code> Helper Composable을 도입하여, 비활성 화면에서의 불필요한 Action 처리 가능성을 해결했다.</li>\n</ul>\n\n<p>하지만 항상 더 나은 방법이 있을 수 있다.</p>\n\n<p><br /></p>\n\n<h2>구독하는 더 좋은 방법은 없을까?</h2>\n\n<p><code class=\"language-plaintext highlighter-rouge\">ON_RESUME</code>/<code class=\"language-plaintext highlighter-rouge\">ON_PAUSE</code> 마다 <code class=\"language-plaintext highlighter-rouge\">launchIn</code>으로 <code class=\"language-plaintext highlighter-rouge\">Job</code>을 생성하고 취소하는 방식 대신, Flow의 <code class=\"language-plaintext highlighter-rouge\">stateIn</code> 연산자를 활용하는 방법을 고려해볼 수 있다.</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">stateIn</code> 연산자는 <code class=\"language-plaintext highlighter-rouge\">Flow</code>를 <code class=\"language-plaintext highlighter-rouge\">StateFlow</code>로 변환하며, 구독자(collector)의 유무에 따라 업스트림 Flow의 실행을 제어할 수 있는 SharingStarted 정책을 제공한다. 예를 들어 <code class=\"language-plaintext highlighter-rouge\">SharingStarted.WhileSubscribed()</code> 정책을 사용하면, StateFlow를 구독하는 Composable이 화면에 보이는 동안(<code class=\"language-plaintext highlighter-rouge\">collectAsState</code> 등으로 구독 중)에만 업스트림 Flow(actionProcessingFlow)가 활성화되고, 화면에서 사라지면 자동으로 구독이 중단(cancel)될 수 있다.</p>\n\n<p>이러한 접근 방식은 Slack에서 만든 <a href=\"https://slackhq.github.io/circuit/\">Circuit - link</a> 아키텍처와 유사한 방향으로 흘러갈 수 있다. Circuit에서는 Presenter가 UI State를 Flow로 노출하고, UI 이벤트는 Sink를 통해 Presenter로 전달됩니다. Presenter 내부 로직의 실행 여부는 최종적으로 UI State Flow의 구독 여부에 따라 결정될 수 있다.</p>\n\n<p>skydoves(재웅 님)가 작성한 <a href=\"https://proandroiddev.com/loading-initial-data-in-launchedeffect-vs-viewmodel-f1747c20ce62\">Loading Initial Data in LaunchedEffect vs. ViewModel - link</a> 글에서도 LaunchedEffect 내에서의 데이터 로딩과 ViewModel의 stateIn을 활용한 데이터 로딩 방식을 비교하며 유사한 아이디어를 엿볼 수 있다.</p>\n\n<p>결국 상태(State)를 중심으로 데이터 흐름을 관리하고, 그 상태의 구독 생명주기에 맞춰 연관된 로직(Action 처리 등)의 실행 여부를 제어하는 방식이 더 Compose 친화적이고 효율적일 수 있다.</p>\n\n<p>저는 현재 설계에서 상태 관리와 이벤트 처리를 분리하고 싶어 이 방식(Circuit이나 stateIn을 전면적으로 활용하는 방식)까지 적용하지는 않았지만, 궁극적으로는 이와 유사한 형태로 발전할 수 있지 않을까 생각하고 있다.</p>\n\n<p><br /></p>\n\n<h2>Next</h2>\n\n<p>이번 글에서는 기존 Composable Architecture 설계에서 발견된 2가지 문제점을 파악하고 이를 해결하기 위해 어떤 고민과 선택을 했는지 정리해보았다.</p>\n\n<p>다음 글에서는 이 아키텍처를 활용하여 구현한 구체적인 기능들을 다룰 예정이다.</p>\n\n<ul>\n  <li>코드에는 이미 있지만 Alert/Toast를 포함하고있다.</li>\n  <li>Router(액티비티, 네비게이션)를 처리하기 위한 부분도 포함하고있다.</li>\n</ul>\n\n<p>이제 다음 글에서 이 두개를 정리할 계획이다.</p>\n\n<p><br /></p>\n\n<h2>작성 글 이어보기</h2>\n\n<ul>\n  <li><a href=\"https://thdev.tech/architecture/2025/02/02/Android-Architecture-01/\">컴포즈에 사용할 Composable Architecutre 설명(리엑트?)</a></li>\n  <li>Composable Architecutre는 만들었는데 문제가 있었네? 개선해보자.</li>\n  <li>예고 - Composable Architecutre를 활용한 Alert/Toast?</li>\n  <li>예고 - Composable Architecutre를 활용한 Router?</li>\n</ul>\n\n",
        "contentSnippet": "이전 글에서 Composable Architecutre를 소개하는 내용을 담아보았는데, 몇 가지 문제점을 발견하여 이를 개선한 내용을 다시 정리하는 글이다.\n크게 2가지 문제점을 확인하였다.\nViewModel 내 Reducer 처리 후 자동 next\nAction 스트림 처리를 위한 싱글턴 활용 시 Lifecycle 문제\n이 2가지 문제점을 해결하기 위해 코드를 어떻게 수정했는지, 그리고 더 나은 방법은 없을지 고민한 과정을 정리해본다.\n이 글에서는\n기존 아키텍처의 구조적 문제점을 파악한다.\n문제 해결 과정과 더 나은 구조에 대한 고민을 공유한다.\n기본적인 내용을 담지 않고있어 앞선 글을 참고하면 좋다.\nAction이란?\nView와 ViewModel 사이의 통신을 어떻게 더 간결하게 할 수 있을까? Jetpack Compose 환경에서는 CompositionLocal - link을 활용하는 방법이 있다. 저는 이 방식을 응용하여 Composable 함수 어디서든 이벤트 처리를 쉽게 호출할 수 있도록 Action이라는 개념을 만들었다.\nFlow를 기반으로 한 Action을 사용한 이유를 설명하기 위해, 먼저 일반적인 View-ViewModel 간 통신 방식의 예시 코드를 살펴보자.\nComposable 함수에서 ViewModel 인스턴스를 파라미터로 직접 전달받아 사용하는 것이 일반적이다. 하지만 이 방식은 Composable 함수의 깊이가 깊어지거나 개수가 많아질수록 ViewModel을 어디까지 전달해야 할지 고민이 필요하며, 구조가 복잡해지면 자연스럽게 보일러플레이트 코드가 늘어나는 단점이 있다.\nViewModel을 직접 사용한 함수 호출\n\n@Composable\nfun SomeScreen(someViewModel: SomeViewModel) {\n  Button(onClick = { someViewModel.doSomething() })\n  Button(onClick = { someViewModel.doSomethingTwo() })\n  Button(onClick = { someViewModel.doSomethingThree() })\n}\n\nclass SomeViewModel : ViewModel() {\n  fun doSomething() { /* ... */ }\n  fun doSomethingTwo() { /* ... */ }\n  fun doSomethingThree() { /* ... */ }\n}\n\n\nViewModel 함수를 sealed interface로 통합하여 호출하는 경우\n\nsealed interface SomeAction {\n    data object ActionOne : SomeAction\n    data object ActionTwo : SomeAction\n    data class ActionThree(val item: Any) : SomeAction\n}\n\n@Composable\nfun SomeScreen(someViewModel: SomeViewModel) {\n  val item = remember { /* ... */ } // 예시 데이터\n  Button(onClick = { someViewModel.dispatch(SomeAction.ActionOne) })\n  Button(onClick = { someViewModel.dispatch(SomeAction.ActionTwo) })\n  Button(onClick = { someViewModel.dispatch(SomeAction.ActionThree(item)) })\n}\n\nclass SomeViewModel : ViewModel() {\n  fun dispatch(action: SomeAction) {\n    when (action) {\n      is SomeAction.ActionOne -> { /* ... */ }\n      is SomeAction.ActionTwo -> { /* ... */ }\n      is SomeAction.ActionThree -> { /* ... */ }\n    }\n  }\n}\n\n\n제가 활용하는 방식 (CompositionLocal 활용)\n위 방식들은 ViewModel을 계속 전달하거나, onClick: () -> Unit 같은 콜백을 계속 만들어 전달해야 하는 번거로움이 있다. 특히 콜백 방식은 이벤트 통합 과정에서 N개의 고차 함수(Higher-Order function)가 만들어질 수 있다.\n그래서 Compose에서 제공하는 Locally scoped - link을 활용하여 Action 객체에 쉽게 접근하는 방법을 사용하고 있습니다. (자세한 활용법은 이전 글 컴포즈에 사용할 Composable Architecture 설명을 참고해주세요.)\n\n// Action 정의 (예시)\nsealed interface MyScreenAction : CaAction { // CaAction은 마커 인터페이스 역할\n    data object ButtonClick : MyScreenAction\n    data class TextTyped(val text: String) : MyScreenAction\n    data class SwitchChanged(val isOn: Boolean) : MyScreenAction\n}\n\n// Composable View\n@Composable\nfun SomeScreen() {\n  // CompositionLocal을 통해 ActionDispatcher 획득\n  val actionDispatcher = LocalActionDispatcher.current\n  var textState by remember { mutableStateOf(\"\") }\n  var switchState by remember { mutableStateOf(false) }\n\n  Column {\n      Button(onClick = { actionDispatcher.dispatch(MyScreenAction.ButtonClick) }) {\n          Text(\"Click Me\")\n      }\n      TextField(\n          value = textState,\n          onValueChange = {\n              textState = it\n              actionDispatcher.dispatch(MyScreenAction.TextTyped(it))\n          }\n      )\n      Switch(\n          checked = switchState,\n          onCheckedChange = {\n              switchState = it\n              actionDispatcher.dispatch(MyScreenAction.SwitchChanged(it))\n          }\n      )\n  }\n}\n\n// ViewModel\nclass SomeViewModel(\n    private val flowCaActionStream: FlowCaActionStream // Action 스트림 주입\n) : CaViewModel<MyScreenAction>(flowCaActionStream, MyScreenAction::class) { // 수신할 Action 타입 지정\n\n    // CaViewModel 내부에서 flowAction을 통해 MyScreenAction 타입의 이벤트만 필터링하여 수신\n    // reducer 메소드에서 각 Action 처리 로직 구현\n    override suspend fun reducer(action: MyScreenAction) {\n        when (action) {\n            is MyScreenAction.ButtonClick -> {\n                // 버튼 클릭 처리 로직\n                Log.d(\"SomeViewModel\", \"Button Clicked\")\n            }\n            is MyScreenAction.TextTyped -> {\n                // 텍스트 입력 처리 로직\n                Log.d(\"SomeViewModel\", \"Text Typed: ${action.text}\")\n            }\n            is MyScreenAction.SwitchChanged -> {\n                // 스위치 변경 처리 로직\n                Log.d(\"SomeViewModel\", \"Switch Changed: ${action.isOn}\")\n            }\n        }\n    }\n}\n\n\n\n사용성 측면에서의 개선\n필요한 Action을 LocalAction.current를 통해 어디서든 호출할 수 있으므로, ViewModel 인스턴스를 계속해서 하위 Composable로 전달할 필요가 없어 개발 편의성이 향상될 수 있다.\nCompositionLocal에 적절한 기본값이나 테스트용 구현체를 제공하면 Preview 동작에도 문제가 없다. 다만, Preview에서 특정 UI 요소의 상태 변화나 인터랙션을 테스트하려면, 선언형 UI의 원칙에 따라 Stateless - link한 Composable을 만들고 상태와 이벤트를 외부에서 주입하는 것이 좋다.\n\n// Stateless Composable 예시\n@Composable\nfun SomeContent(\n    text: String,\n    isSwitchOn: Boolean,\n    onButtonClick: () -> Unit,\n    onTextTyped: (String) -> Unit,\n    onSwitchChange: (Boolean) -> Unit,\n    modifier: Modifier = Modifier // Modifier 추가 권장\n) {\n    Column(modifier = modifier) {\n        Button(onClick = onButtonClick) { /* ... */ }\n        TextField(value = text, onValueChange = onTextTyped)\n        Switch(checked = isSwitchOn, onCheckedChange = onSwitchChange)\n    }\n}\n\n// Statefull Composable (ViewModel과 연결)\n@Composable\nfun SomeScreen(viewModel: SomeViewModel = hiltViewModel()) { // Hilt 등 DI 활용 예시\n    val actionDispatcher = LocalActionDispatcher.current // Action 발송기\n    // ViewModel로부터 상태를 구독하거나, 필요한 상태를 여기서 관리\n    val textState by viewModel.textState.collectAsState() // 예시 StateFlow\n    val switchState by viewModel.switchState.collectAsState() // 예시 StateFlow\n\n    SomeContent(\n        text = textState,\n        isSwitchOn = switchState,\n        onButtonClick = { actionDispatcher.dispatch(MyScreenAction.ButtonClick) },\n        onTextTyped = { actionDispatcher.dispatch(MyScreenAction.TextTyped(it)) },\n        onSwitchChange = { actionDispatcher.dispatch(MyScreenAction.SwitchChanged(it)) }\n    )\n}\n\n\n이 방식(Stateless/Statefull 분리 및 CompositionLocal 활용)의 단점은 다음과 같다.\nViewModel에서 모든 UI 인터랙션을 하나의 reducer 함수로 통합 관리하기보다, 각 상태 업데이트 로직과 이벤트 발송 로직이 분리될 수 있다. (이는 관점에 따라 장점일 수도 있다)\n새로운 Action 이벤트를 추가할 때, ViewModel의 reducer에서도 해당 이벤트를 처리하는 로직을 추가해야 한다. (이는 sealed interface 사용 시 컴파일 타임에 강제될 수 있어 오히려 장점이 될 수 있다.)\n하지만 장점은 다음과 같습니다.\n각 UI 요소의 이벤트 발송 책임이 명확해진다.\nStateless Composable은 재사용 및 테스트가 용이하다.\nCompositionLocal을 통해 이벤트 발송 인터페이스 접근이 간편하다.\n\n정리하면\n해결하고 싶었던 지점\nView와 ViewModel 간의 이벤트 전달을 왜 항상 ViewModel 인스턴스를 통해 viewModel.someFunction() 형태로 직접 호출해야 할까?\nComposable 함수의 깊이가 깊어질 때 ViewModel 인스턴스나 콜백 함수를 계속 전달해야 하는 번거로움을 줄일 수 없을까?\n그래서 도입한 Action(CompositionLocal)\n이벤트 처리를 위한 Action 인터페이스와 이를 쉽게 발송(dispatch)할 수 있는 ActionDispatcher를 CompositionLocal로 제공하여, Composable 함수 내에서 발생하는 보일러플레이트를 줄이고자 했다.\n하지만 여전히 해결해야 할 문제가 있는데\n이벤트를 보내는 쪽(View)과 받는 쪽(ViewModel)에서 정확히 어떤 Action 타입을 사용하고 처리할지 명확히 약속이 필요하다. 만약 서로 다른 타입을 사용하거나 누락하면 이벤트가 유실되어 동작하지 않는 치명적인 문제가 발생할 수 있다.\n이 문제를 해결하고 개발 과정에서 실수를 줄이기 위해 sealed interface를 사용하여 Action을 정의하는 방식을 채택했다. sealed interface를 사용하면 ViewModel의 reducer에서 when 식으로 처리할 때 모든 하위 타입을 강제로 구현해야 하므로, 이벤트 누락 가능성을 컴파일 시점에 방지할 수 있다. 이는 UI 동작 관련 테스트 케이스를 일부 줄여줄 수 있는 장점도 있다.\n\n그래서 발견한 문제\nSwift-composable architecture - 링크를 참고하여 아키텍처를 구상하다 보니, Reducer가 특정 액션을 처리한 후 다음 액션을 연쇄적으로 발생시키는 구조를 발견했다.\nSwift Composable Architecture의 코드 예시를 보면, Reduce 클로저 내에서 .send나 다른 이펙트(Effect)를 반환하여 다음 동작을 유발할 수 있다. (아래 코드는 TCA의 이전 버전 구문일 수 있으며, 현재는 @Reducer 매크로 등을 사용한다.)\n\n// TCA 예시 (개념 설명용)\nReduce { state, action in\n  switch action {\n  case .buttonTapped:\n    state.isLoading = true\n    // 이펙트를 반환하여 비동기 작업 후 다른 액션(.dataLoaded)을 발생시킴\n    return .run { send in\n      let data = try await apiClient.fetchData()\n      await send(.dataLoaded(data))\n    }\n  case let .dataLoaded(data):\n    state.isLoading = false\n    state.data = data\n    return .none // 추가 액션 없음\n  // ...\n  }\n}\n\n\n이러한 ‘액션 후 연쇄 액션’ 개념을 안드로이드에서 Flow와 제가 만든 Action 시스템으로 구현해보고자 했다. 하지만 여기서 두 가지 주요 문제가 발생했다.\n자동 nextAction 호출로 인한 문제:\n    \nViewModel의 reducer 함수가 반환하는 값을 기반으로 시스템이 자동으로 다음 액션(nextAction)을 발생시키도록 설계했더니, 개발자가 이 동작 방식을 정확히 이해하고 사용해야 하는 부담이 늘었다. 알아야 할 규칙이 많아진 것.\n결정적으로, nextAction을 잘못 지정하거나 reducer 로직에 실수가 있으면 무한 루프에 빠질 위험이 있었다. 디버깅이 불가능한 것은 아니지만, 코드 설계상 예측 가능한 문제가 쉽게 발생할 수 있는 구조였다.\n싱글턴 Action 스트림과 Lifecycle 동기화 문제:\n    \n앱 전체에서 단 하나의 Action 스트림(FlowCaActionStream)을 싱글턴으로 사용하다 보니, 새로운 Activity가 실행되거나 Composable Navigation 라이브러리(like Navigation-Compose)를 통해 화면이 전환될 때 문제가 발생했다.\n예를 들어, Activity A와 Activity B가 있고 각각 여러 Composable 화면(Screen)을 가지고 있다고 가정해 보자. 사용자가 Activity B에 있더라도, 백그라운드의 Activity A에 속한 ViewModel들이 여전히 싱글턴 Action 스트림을 구독하고 있을 수 있다. 만약 특정 Action이 Activity B에서 발생했는데, Activity A의 ViewModel도 해당 Action 타입에 대해 필터링 로직(filterIsInstance)을 가지고 있다면, 의도치 않게 Activity A의 ViewModel에서도 해당 Action이 처리될 수 있다. (물론 reducer 로직 내에서 현재 화면 상태 등을 체크하여 방어할 수는 있겠지만, 근본적으로 불필요한 구독 및 처리 시도가 발생한다.)\n이는 특히 Alert, Toast, Router(화면 전환)와 같이 앱 전역적으로 영향을 줄 수 있는 Side Effect 처리 시 동기화 문제를 일으킬 수 있다. ViewModel의 생명주기(viewModelScope)는 일반적으로 Composable의 생명주기보다 길기 때문에 이 문제가 더 두드러진다.\n이 두 가지 문제를 어떻게 해결했는지 구체적으로 설명하겠다.\n\n문제점 1 - 무한 루프 가능성 해결하기\n무한 루프 발생 가능성을 제거하기 위해 기존 CaViewModel의 flowAction 처리 방식에서 문제의 소지가 있는 부분을 수정했다.\n기존 코드 (문제 발생 가능성 있음):\nabstract class CaViewModel<ACTION : CaAction, SIDE_EFFECT : CaSideEffect>(\n    private val flowCaActionStream: FlowCaActionStream, // 'private' 추가 (캡슐화)\n    actionClass: KClass<ACTION>,\n) : ViewModel() {\n\n    @VisibleForTesting\n    val flowAction by lazy(LazyThreadSafetyMode.NONE) {\n        flowCaActionStream.flowAction()\n            .filterIsInstance(actionClass) // 1. 해당 ViewModel이 처리할 Action만 필터링\n            .map { action -> // 2. reducer를 호출하고, 그 결과를 반환 (문제의 소지)\n                reducer(action = action) // reducer가 다음 Action을 반환한다고 가정\n            }\n            .onEach { nextActionToDispatch -> // 3. map에서 반환된 다음 Action을 자동으로 전파 (문제!)\n                flowCaActionStream.nextAction(nextActionToDispatch) // 무한 루프 가능 지점\n            }\n            // .launchIn(viewModelScope) // 실제로는 여기서 launch 되어야 함\n    }\n\n    // reducer 함수가 다음 Action을 반환하는 형태였다고 가정\n    abstract suspend fun reducer(action: ACTION): CaAction? // 예시: 반환 타입이 다음 Action\n}\n\n수정된 코드:\n\nabstract class CaViewModel<CA_ACTION : CaAction>(\n    private val flowCaActionStream: FlowCaActionStream,\n    actionClass: KClass<CA_ACTION>,\n) : ViewModel() {\n\n    // Action 처리를 위한 Flow (자동 nextAction 로직 제거)\n    @VisibleForTesting\n    internal val actionProcessingFlow by lazy(LazyThreadSafetyMode.NONE) { // 'internal'로 변경하고 이름 명확화\n        flowCaActionStream.flowAction()\n            .filterIsInstance(actionClass) // 1. 처리할 Action 필터링\n            .onEach { action -> // 2. map 대신 onEach 사용. 각 Action에 대해 reducer만 실행 (반환값 사용 안 함)\n                reducer(action = action)\n            }\n            // 3. 자동 nextAction 전파 로직 제거됨\n    }\n\n    // reducer 함수는 이제 Side Effect 처리나 상태 변경에만 집중 (반환값 없음)\n    abstract suspend fun reducer(action: CA_ACTION)\n\n    // 다음 Action을 명시적으로 전파하고 싶을 때 호출하는 함수 추가\n    protected fun nextAction(action: CaAction) { // 'protected'로 변경하여 자식 클래스에서만 사용하도록 제한\n        flowCaActionStream.nextAction(action)\n    }\n\n    // 실제 Flow 구독 시작/취소는 별도 관리 (아래 Lifecycle 해결 부분 참조)\n    @VisibleForTesting\n    var actionProcessingJob: Job? = null\n}\n\n\n수정 내용 요약:\nmap -> onEach 변경: reducer 함수가 다음 Action을 반환하고 이를 map 연산자가 받아 downstream로 흘려보내는 구조를 제거했다. 대신 onEach를 사용하여 각 Action에 대해 reducer 함수를 실행만 하도록 변경다. 이로써 reducer의 반환값과 관계없이 자동 nextAction 호출 가능성이 사라졌다.\n명시적 nextAction 함수 추가: 연쇄적인 Action 전파가 필요한 경우, 개발자가 reducer 함수 내에서 직접 nextAction(action) 함수를 호출하도록 변경했다. 이는 시스템에 의한 암묵적인 동작 대신, 개발자의 명확한 의도에 따라 다음 Action이 발생하도록 하여 코드의 예측 가능성을 높인다.\n이제 reducer 내에서 다음과 같이 명시적으로 다음 Action을 지정해야 한다.\noverride suspend fun reducer(action: MyScreenAction) {\n    when (action) {\n        is MyScreenAction.ButtonClick -> {\n            // 예시: 버튼 클릭 후 특정 조건 만족 시 Alert 표시 Action 전파\n            if (shouldShowAlert()) {\n                nextAction(CommonUiAction.ShowAlert(\"버튼 클릭됨!\")) // 명시적으로 nextAction 호출\n            }\n        }\n        // ... 다른 Action 처리\n    }\n}\n\n이 변경으로 시스템적인 무한 루프 발생 가능성은 제거되었고, 코드의 흐름이 더 명확해졌다.\n\n문제점 2 - Lifecycle 문제 해결하기\n싱글턴 Action 스트림(FlowCaActionStream) 사용 시 발생하는 Lifecycle 동기화 문제를 해결하기 위해, Composable의 Lifecycle에 맞춰 ViewModel의 Action 스트림 구독을 시작하고 중지하는 방식을 도입했다.\n문제 상황: Activity A와 B가 있을 때, Activity B가 화면에 보이는 동안에도 백그라운드의 Activity A에 있는 ViewModel이 Action 스트림을 계속 구독하고 있으면, Activity B에서 발생한 Action이 Activity A의 ViewModel에게도 전달될 수 있다. (물론 filterIsInstance로 타입 필터링은 되지만, 같은 타입의 Action을 여러 화면에서 사용한다면 문제가 된다.)\n\n\n해결 방안: Lifecycle에 따른 구독 제어\nComposable의 Lifecycle 상태(특히 ON_RESUME, ON_PAUSE)에 맞춰 ViewModel 내 Action 스트림(actionProcessingFlow)의 구독(Job)을 시작하고 취소하는 방법을 사용합니다. 이를 위해 DisposableEffect와 LocalLifecycleOwner를 활용하는 Helper Composable 함수를 만들었습니다.\n\n@Composable\nfun LaunchedLifecycleViewModel(\n    viewModel: CaViewModel<*> // 라이프사이클 관리가 필요한 ViewModel\n) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    DisposableEffect(lifecycleOwner, viewModel) { // lifecycleOwner와 viewModel이 키\n        val observer = LifecycleEventObserver { _, event ->\n            when (event) {\n                Lifecycle.Event.ON_RESUME -> {\n                    // 화면이 활성화되면 Action 스트림 구독 시작\n                    viewModel.startActionProcessing()\n                }\n                Lifecycle.Event.ON_PAUSE -> {\n                    // 화면이 비활성화되면 Action 스트림 구독 취소\n                    viewModel.cancelActionProcessing()\n                }\n                // ON_DESTROY는 DisposableEffect의 onDispose에서 처리되거나\n                // ViewModel의 onCleared에서 처리될 수 있음\n                else -> { /* Do nothing for other events */ }\n            }\n        }\n        lifecycleOwner.lifecycle.addObserver(observer)\n\n        // Composable이 Composition에서 제거될 때(onDispose) Observer 제거\n        onDispose {\n            lifecycleOwner.lifecycle.removeObserver(observer)\n            // 필요하다면 여기서도 cancelActionProcessing() 호출 고려\n            // viewModel.cancelActionProcessing()\n        }\n    }\n}\n\n\n그리고 CaViewModel에 Action 스트림 구독을 시작하고 취소하는 함수를 추가한다. (internal 접근 제한자를 사용하여 모듈 외부에서의 직접 호출을 방지한다.)\n\nabstract class CaViewModel<CA_ACTION : CaAction>(\n    // ... (이전 코드와 동일)\n) : ViewModel() {\n\n    // ... (actionProcessingFlow, reducer, nextAction 등) ...\n\n    @VisibleForTesting\n    var actionProcessingJob: Job? = null // 구독 상태를 관리하는 Job\n\n    // Action 스트림 구독 시작 (ON_RESUME 시 호출됨)\n    internal fun startActionProcessing() {\n        // 이미 실행 중이라면 중복 실행 방지\n        if (actionProcessingJob?.isActive == true) return\n\n        // 기존 Job이 있다면 취소 (혹시 모를 상황 대비)\n        cancelActionProcessing()\n\n        // actionProcessingFlow를 viewModelScope에서 구독 시작\n        actionProcessingJob = actionProcessingFlow\n            .launchIn(viewModelScope)\n    }\n\n    // Action 스트림 구독 취소 (ON_PAUSE 시 호출됨)\n    internal fun cancelActionProcessing() {\n        actionProcessingJob?.cancel()\n        actionProcessingJob = null\n    }\n\n    // ViewModel이 파괴될 때(onCleared) 확실하게 Job 취소\n    override fun onCleared() {\n        super.onCleared()\n        cancelActionProcessing()\n    }\n}\n\n\n위 코드를 활용하는 방법은?\n각 화면의 최상위 Composable에서 ObserveLifecycle 함수를 호출해주어야 한다.\n@Composable\nfun SomeScreen(viewModel: SomeViewModel = hiltViewModel()) {\n    // ViewModel의 Action 구독 라이프사이클 관리\n    LaunchedLifecycleViewModel(viewModel = viewModel)\n\n    // --- 실제 UI ---\n    // val state by viewModel.uiState.collectAsState()\n    // SomeContent(...)\n    // ---\n}\n\n개선 아이디어: 매번 ObserveLifecycle(viewModel)를 호출하는 것이 번거롭다면, ViewModel 인스턴스를 얻을 때 자동으로 이 로직을 포함시키는 확장 함수나 위임(delegate)을 고려해볼 수 있다. 예를 들어:\n\n@Composable\nfun Some(viewModel: ViewModel = hiltViewModel().Activate()) {\n  // Your view\n}\n\n\n또는 hilt를 직접 확장한다면 아래와 같다.\n\n// 개념적인 아이디어 (구현 필요)\n@Composable\ninline fun <reified VM : CaViewModel<*>> hiltViewModelWithLifecycle(): VM {\n    val viewModel: VM = hiltViewModel()\n    LaunchedLifecycleViewModel(viewModel = viewModel)\n    return viewModel\n}\n\n// 사용 예시\n@Composable\nfun SomeScreen(viewModel: SomeViewModel = hiltViewModelWithLifecycle()) {\n    // 이제 LaunchedLifecycleViewModel() 호출 불필요\n    // ... UI ...\n}\n\n\n(Gemini 주의: hiltViewModelWithLifecycle 같은 함수는 Composable 함수 내에서 다른 Composable 함수(LaunchedLifecycleViewModel)를 호출하는 방식이므로, ViewModel 생성 로직과 Lifecycle 관찰 로직을 분리하는 것이 더 좋을 수 있다. 또는 별도의 진입점 Composable에서 처리하는 방식도 고려할 수 있다.)\n고려사항:\n이 방식은 ViewModel이 간접적으로 UI Lifecycle을 인지하게 되는 것 아니냐는 비판이 있을 수 있다. 하지만 start/cancelActionProcessing 함수 호출 시점은 ViewModel 외부(LaunchedLifecycleViewModel)에서 결정되므로, ViewModel 자체는 Lifecycle 객체를 직접 참조하지 않는다.\nON_RESUME / ON_PAUSE 이벤트마다 Job을 취소하고 다시 시작하는 오버헤드가 발생할 수 있다. 하지만 이는 화면이 실제로 보이지 않을 때 불필요한 Action 처리를 방지하는 효과적인 방법 중 하나이다.\n\n해결했을까?\n위 변경 사항들을 통해 초기 설계에서 발견된 두 가지 주요 문제점을 해결할 수 있었다.\n무한 루프 발생 가능성: reducer 처리 후 자동 nextAction 전파 로직을 제거하고, 명시적인 nextAction 함수 호출 방식으로 변경하여 해결했다.\n싱글턴 Action 스트림의 Lifecycle 문제: Composable의 Lifecycle에 맞춰 ViewModel의 Action 스트림 구독을 제어하는 LaunchedLifecycleViewModel Helper Composable을 도입하여, 비활성 화면에서의 불필요한 Action 처리 가능성을 해결했다.\n하지만 항상 더 나은 방법이 있을 수 있다.\n\n구독하는 더 좋은 방법은 없을까?\nON_RESUME/ON_PAUSE 마다 launchIn으로 Job을 생성하고 취소하는 방식 대신, Flow의 stateIn 연산자를 활용하는 방법을 고려해볼 수 있다.\nstateIn 연산자는 Flow를 StateFlow로 변환하며, 구독자(collector)의 유무에 따라 업스트림 Flow의 실행을 제어할 수 있는 SharingStarted 정책을 제공한다. 예를 들어 SharingStarted.WhileSubscribed() 정책을 사용하면, StateFlow를 구독하는 Composable이 화면에 보이는 동안(collectAsState 등으로 구독 중)에만 업스트림 Flow(actionProcessingFlow)가 활성화되고, 화면에서 사라지면 자동으로 구독이 중단(cancel)될 수 있다.\n이러한 접근 방식은 Slack에서 만든 Circuit - link 아키텍처와 유사한 방향으로 흘러갈 수 있다. Circuit에서는 Presenter가 UI State를 Flow로 노출하고, UI 이벤트는 Sink를 통해 Presenter로 전달됩니다. Presenter 내부 로직의 실행 여부는 최종적으로 UI State Flow의 구독 여부에 따라 결정될 수 있다.\nskydoves(재웅 님)가 작성한 Loading Initial Data in LaunchedEffect vs. ViewModel - link 글에서도 LaunchedEffect 내에서의 데이터 로딩과 ViewModel의 stateIn을 활용한 데이터 로딩 방식을 비교하며 유사한 아이디어를 엿볼 수 있다.\n결국 상태(State)를 중심으로 데이터 흐름을 관리하고, 그 상태의 구독 생명주기에 맞춰 연관된 로직(Action 처리 등)의 실행 여부를 제어하는 방식이 더 Compose 친화적이고 효율적일 수 있다.\n저는 현재 설계에서 상태 관리와 이벤트 처리를 분리하고 싶어 이 방식(Circuit이나 stateIn을 전면적으로 활용하는 방식)까지 적용하지는 않았지만, 궁극적으로는 이와 유사한 형태로 발전할 수 있지 않을까 생각하고 있다.\n\nNext\n이번 글에서는 기존 Composable Architecture 설계에서 발견된 2가지 문제점을 파악하고 이를 해결하기 위해 어떤 고민과 선택을 했는지 정리해보았다.\n다음 글에서는 이 아키텍처를 활용하여 구현한 구체적인 기능들을 다룰 예정이다.\n코드에는 이미 있지만 Alert/Toast를 포함하고있다.\nRouter(액티비티, 네비게이션)를 처리하기 위한 부분도 포함하고있다.\n이제 다음 글에서 이 두개를 정리할 계획이다.\n\n작성 글 이어보기\n컴포즈에 사용할 Composable Architecutre 설명(리엑트?)\nComposable Architecutre는 만들었는데 문제가 있었네? 개선해보자.\n예고 - Composable Architecutre를 활용한 Alert/Toast?\n예고 - Composable Architecutre를 활용한 Router?",
        "guid": "https://thdev.tech/architecture/2025/04/15/Android-Architecture-02/",
        "isoDate": "2025-04-15T00:00:00.000Z"
      }
    ]
  },
  {
    "name": "김슬기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김광현",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김성빈",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김영우",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강명훈",
    "category": "개인",
    "posts": [
      {
        "title": "Splunk의 Join - 5th",
        "link": "https://kangmyounghun.blogspot.com/2025/04/splunk-join-5th.html",
        "pubDate": "2025-04-13T02:57:00.000Z",
        "author": "강명훈",
        "content": "<div>inner join.</div><div><br /></div>\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixDdh6sq0h7NiY7ekFt67l7iM1xq8xuzAs98M-YfZLGi-RF5u0jJuPt7ZKDvnI2QLHtL8ApWNdZG9BKztDHCP_Icc0AkSCy9D5VDDXr2ByO-OSVFgsjxK5KGhrL2_Whi2fNJmoWUjdSedGCFF60NFAPwO1M8dCuslqlKFPuauk9_V-Y8fEbFnaDDEj7dTQ/s1470/inner_join.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"1470\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixDdh6sq0h7NiY7ekFt67l7iM1xq8xuzAs98M-YfZLGi-RF5u0jJuPt7ZKDvnI2QLHtL8ApWNdZG9BKztDHCP_Icc0AkSCy9D5VDDXr2ByO-OSVFgsjxK5KGhrL2_Whi2fNJmoWUjdSedGCFF60NFAPwO1M8dCuslqlKFPuauk9_V-Y8fEbFnaDDEj7dTQ/s16000/inner_join.png\" /></a></div>\n<div><br /></div><div><span><a name='more'></a></span>left join.</div><br />\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhBMe03aUKkg4gKcHkNA0_SYmAO9Qc_hcPLnmMg31hmS2tsgmWAbPfHsV0ap9GvpdrL1tDkxln4vpLrebn7ON935oJPZJT3G9TDJkFxFUkBKH92N_qoj9KFolOzXj6AQF8j0sc7maki5Fof20iL1eq2tXHp-dIZqI2SZu6DxS08Q1S5iR6Z66si6mVRbROb/s1394/left_join.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"1394\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhBMe03aUKkg4gKcHkNA0_SYmAO9Qc_hcPLnmMg31hmS2tsgmWAbPfHsV0ap9GvpdrL1tDkxln4vpLrebn7ON935oJPZJT3G9TDJkFxFUkBKH92N_qoj9KFolOzXj6AQF8j0sc7maki5Fof20iL1eq2tXHp-dIZqI2SZu6DxS08Q1S5iR6Z66si6mVRbROb/s16000/left_join.png\" /></a></div>\n<div><br /></div><div>교집합 제외한 left join.</div><br />\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiz1UdN6mn1NqtKodNpELfR6Jn4F9aLLlveptkzxioo2L_r8ISYu7ww6XSn2rbYbYtBQoq_SJtoKlAXzjtSWbV80ALWuAMX7gcTdceAJY5dRSv0qEpr_2TGk7cXyURnN0Xzg6Is88PDX0EcZopXJVY3lMjf5RJoZnogWaCMx1MsPSXEYI7Ts_oX-4d_4yEJ/s1502/left_join2.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"1502\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiz1UdN6mn1NqtKodNpELfR6Jn4F9aLLlveptkzxioo2L_r8ISYu7ww6XSn2rbYbYtBQoq_SJtoKlAXzjtSWbV80ALWuAMX7gcTdceAJY5dRSv0qEpr_2TGk7cXyURnN0Xzg6Is88PDX0EcZopXJVY3lMjf5RJoZnogWaCMx1MsPSXEYI7Ts_oX-4d_4yEJ/s16000/left_join2.png\" /></a></div>\n<br /><div>full join.</div><div><br /></div>\n<div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiyoVvxzr8IoshQYh36Igmd1CshyphenhyphencRy2qO_13b-CepCvOKannzB5NLUTkMD_gbjAqVhKjR8vIZ0D2sBI9r9NebVtKHXSe4kKO0-T5n_zzvzh7H3cA159pQv9ekt_qWKvK_OnHQjy9mMw2BXBhTc3XRvz-gbaRl3M5XnfptbxtO74GJK6HIUhO5QJ7ZXLU_0/s1125/full_join.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"944\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiyoVvxzr8IoshQYh36Igmd1CshyphenhyphencRy2qO_13b-CepCvOKannzB5NLUTkMD_gbjAqVhKjR8vIZ0D2sBI9r9NebVtKHXSe4kKO0-T5n_zzvzh7H3cA159pQv9ekt_qWKvK_OnHQjy9mMw2BXBhTc3XRvz-gbaRl3M5XnfptbxtO74GJK6HIUhO5QJ7ZXLU_0/s16000/full_join.png\" /></a></div><br /></div><div>교집합 제외한 full join.</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgPSJ6DgrvnRYmhT5qwkLjXTFV8ig78PCr9gPHmpDfYxcycB4sM6Hcu6A4cuuTd3a6F3HDwU9kNgjiqBJlQs1UggleUsH2gWer86fn7sjY_N6CxQofWcubDBLlWHvZ2jMalTLIEFMJ1PWoJ59lrG9BYGrn75eOQqhyWkzaOsdyIQD6dcJkQu4_v4suR-kfC/s1125/full_join2.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1125\" data-original-width=\"990\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgPSJ6DgrvnRYmhT5qwkLjXTFV8ig78PCr9gPHmpDfYxcycB4sM6Hcu6A4cuuTd3a6F3HDwU9kNgjiqBJlQs1UggleUsH2gWer86fn7sjY_N6CxQofWcubDBLlWHvZ2jMalTLIEFMJ1PWoJ59lrG9BYGrn75eOQqhyWkzaOsdyIQD6dcJkQu4_v4suR-kfC/s16000/full_join2.png\" /></a></div><br /><div><b>관련 글</b></div><div><div><ul><li><a href=\"https://kangmyounghun.blogspot.com/2024/10/splunk-join-4th.html\">Splunk의 Join - 4th</a></li><li><a href=\"https://kangmyounghun.blogspot.com/2021/03/splunk-join.html\" target=\"\">Splunk의 Join</a></li><li><a href=\"https://kangmyounghun.blogspot.com/2021/07/splunk-lookup.html\" target=\"\">Splunk의 lookup</a></li><li><a href=\"https://kangmyounghun.blogspot.com/2022/10/join.html\" target=\"\">엘라스틱의 Join</a></li></ul></div></div>",
        "contentSnippet": "inner join.\n\n\n\n\nleft join.\n\n\n\n교집합 제외한 left join.\n\n\nfull join.\n\n\n\n\n\n교집합 제외한 full join.\n\n\n\n\n관련 글\n\n\nSplunk의 Join - 4th\nSplunk의 Join\nSplunk의 lookup\n엘라스틱의 Join",
        "id": "tag:blogger.com,1999:blog-2597780270996323853.post-9209557534125241532",
        "isoDate": "2025-04-13T02:57:00.000Z"
      }
    ]
  },
  {
    "name": "김민장",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김성중",
    "category": "개인",
    "posts": [
      {
        "title": "승려와 수수께끼 | 랜디 코미사",
        "link": "https://sungjk.github.io/2025/04/12/the-monk-and-the-riddle.html",
        "pubDate": "2025-04-12T00:00:00+00:00",
        "content": "\n            \n            &lt;p&gt;&lt;img src=&quot;/images/2025/04/12/the-monk-and-the-riddle.png&quot; alt=&quot;The Monk And The Riddle&quot; title=&quot;The Monk And The Riddle&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;“이 달걀을 1미터 정도 아래로 떨어뜨리되 깨뜨리면 안 됩니다. 어찌 해야 할까요?”&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;변호사이자 실리콘밸리 투자자인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Randy_Komisar&quot;&gt;랜디 코미사&lt;/a&gt;의 이야기를 다룬 책이다. 미얀마에서 만난 한 승려가 던지는 질문으로 책에서 하고자 하는 이야기가 시작된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이 달걀을 1미터 정도 아래로 떨어뜨리되 깨뜨리면 안 됩니다. 어찌 해야 할까요?&lt;/code&gt; 이 질문을 들으면 어떤 생각이 드는가? 단단한 돌 바닥 위에서 달걀을 들고 있는 모습이 상상된다. 그런데 이걸 떨어뜨리되 깨뜨리면 안된다..? 바닥에 쿠션을 놓으면 안될까? 아니면 혹시.. 물 위에서 떨어뜨리면 안되나?&lt;/p&gt;\n\n&lt;p&gt;우리는 자연스레 계란이 떨어지면 깨지는 것부터 상상한다. 그래서 깨지지 않게 하려면 바닥에 부드러운 무언가를 놓고 깨지지 않게끔 만드는게 중요하다고 생각이 든다. 승려는 어떤 메시지를 전달하고 싶어서 이런 질문을 했는지 궁금증을 가진채 계속 읽어 나갔다.&lt;/p&gt;\n\n&lt;p&gt;승려는 책의 도입부에 질문을 마지막으로 나오지 않고, 그 이후부터는 랜디와 레니라는 창업가의 이야기로만 구성되어 있다. 어느날 랜디에게 장례 용품을 온라인에서 사고 팔 수 있는 사업을 하겠다고 레니라는 사람이 투자와 자문을 구하기 위해 찾아왔다. 레니는 엄청난 열정과 굉장히 구체적인 사업 계획을 가지고 있었다. 하지만 지금 당장은 돈을 벌기 위한 수단으로 사업을 하고, 돈을 많이 벌고 난 이후에 본인이 진짜 하고 싶은 일을 하려고 계획중이었다. 이런 레니의 이야기를 듣고 랜디는 열정 가득하고 사업 계획 구체적이지만, 왜 장례 사업을 하려는건지 목적과 비전이 뚜렷하지 않아서 몇 가지 조언을 남긴 뒤 투자를 위한 마음은 접기로 했다.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;“내 경험상, 만약 돈 때문에 이 일을 시작한다면 닭 쫓던 개 신세를 면치 못할 겁니다. 돈은 결코 그렇게 따라오지 않아요. 뭔가 더 있어야 합니다. 상황이 최악으로 치달을 때 나를 지켜줄 만한 목적의식 같은 것 말이죠. 실패하더라도 이 일에 엄청난 시간과 노력을 쏟을 만한 가치가 있는, 그런 것이 있어야 한단 말입니다.”&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;그러나 레니는 포기하지 않고 랜디의 조언을 바탕으로 사업 계획서를 다시 다듬고 오랜 기간 랜디를 괴롭히다시피 한다. 결국 랜디는 굉장히 끈질긴 성격을 가진 레니에게 사업을 하려고 하는 진짜 목적에 대해 스스로 고민할 수 있도록 질문을 하기 시작한다. ‘미뤄 놓은 인생 설계’, ‘내가 가장 하고 싶은 것’. 중간중간 랜디의 변호사 시절과 실리콘밸리 회사에서의 다양한 경험 이야기도 나오는데, 사업을 함에 있어 가장 중요한건 동기라는 사실을 일깨워준다. 레니는 랜디와 동업자 앨리슨의 생각과 조언을 받아들여 본인이 정말로 하고 싶었던 것과 장례 사업을 접목시켜 가슴뛰는 사업의 목적을 찾게 된다.&lt;/p&gt;\n\n&lt;p&gt;살면서 혹은 일을 하면서 여러가지 문제를 마주하는데 그 때마다 &lt;strong&gt;지금 있는 현상에만 집중하다가 본질(핵심)이 무엇인지 잊게 된다.&lt;/strong&gt; 현상에만 집중하다보면 본질과 다른 방향으로 답을 찾게 된다. 책의 맨 마지막에 승려가 낸 질문에 대한 해답이 나온다. 그런데 그 답이 중요한게 아니라, 승려가 왜 이 수수께끼를 냈는지가 중요하다. 책을 읽다보면 승려가 내놓은 수수께끼의 본질을 알게 되는데, &lt;strong&gt;‘계란이 깨지지 않게 만드는게 아니라, 1미터 높이에서 깨지지 않는 상태로 존재하게 할 수 있는 방법’&lt;/strong&gt; 이다.&lt;/p&gt;\n\n&lt;p&gt;이 책의 주된 이야기인 사업 뿐만 아니라, 우리가 하고 있는 무언가에 대한 질문이기도 하다. 지금 원하는 일을 하고 있는가? 이 일을 왜 하는가? 열심히 일해서, 돈 많이 벌어서, 나중에 하고 싶은거 하면서 편하게 즐겁게 살아야지. 인생은 출애굽기도, 영웅전도 아니다. 현재의 고통을 전제로 미래의 행복을 바꾸거나 하고 싶지도 않은 일에 인생을 낭비하기엔 너무 아깝고, 당장 하고 싶은 일을 해야 한다는 당연하면서도 어려운 교훈을 주는 책이다.&lt;/p&gt;\n\n&lt;h3 id=&quot;인상-깊은-구절&quot;&gt;인상 깊은 구절&lt;/h3&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;열정이란, 저항할 수조차 없이 어떤 것으로 당신 자신을 끌어가는 것을 말한다. 반면 의지란, 책임감 또는 해야만 한다고 생각되는 일에 의해 떠밀려가는 것이다. 만약 자신에 대해 아무것도 모른다면 그 차이를 알 수 없다. 조금이나마 자기 인식을 하고 있는 사람은 내가 어떤 분야에 열정을 가지고 있는지 알 수가 있다. 어떤 목표를 달성하고 싶다는 욕망은 열정이 아니며, 일정 수준의 몫이나 보너스, 또는 회사를 매각하여 현금을 벌고 싶다는 욕심도 열정이 아니다. 다른 사람의 성취를 따라 하기 위해 노력하는 것도 열정이 아니다. 그것은 의지에 가깝다.&lt;/li&gt;\n  &lt;li&gt;비즈니스 환경은 늘 변한다. 사람들은 전략과 수익모델을 변화하는 환경에 맞게 지속적으로 재검토하고 필요에 따라 수정해야 한다. 하지만 수정할 때마다 기준으로 삼아야 하는 것은 기업의 큰 비전이다. 긴급한 상황을 모면하기 위해 구성원의 감동을 이끌어 내는 비전을 포기하면, 나침반 없이 남겨지는 것과 다를 바 없다. 나는 기업의 위치를 돌아볼 때 현재 상황만 따지는 것이 아니라 목표와 방향 점검도 병행돼야 한다는 충고를 늘 하고 있다. 나침반을 맞추고 길을 따라 나아가라. 그래야 장애물에 걸려 넘어지더라도 방향 감각을 유지할 수 있을 것이다.&lt;/li&gt;\n  &lt;li&gt;관리와 리더십은 서로 공통점이 있기는 하지만 같은 건 아니다. 레니처럼 편협한 사고방식을 가지고 있는 사람은 그 차이를 알 수 없다. 관리는 체계적인 과정을 말하는데 그 목적은 정해진 시간과 예산 내에서 원하는 결과를 낳는 것이다. 리더십은 인격과 비전으로 다른 사람을 불가능한 일에 도전하도록 만든다. 관리는 리더십을 보완하고 지원하지만, 리더십을 내포하지 않은 관리는 아무것도 할 수 없다. 리더는 아랫사람들의 의혹을 해소시키고 불완전한 정보를 가지고도 나아갈 수 있도록 만들어야 한다.&lt;/li&gt;\n  &lt;li&gt;기차를 제시간에 맞게 도착시키는 관리자의 역할보다 리더로서의 업무가 나는 더 마음에 들었다. 리더의 묘미는 계산기를 두드리고 생산라인을 개선하는 방법을 찾는 것에 있지 않았다. 사람들이 한계를 넘어설 수 있도록 용기를 북돋고, 사람들이 위대해질 수 있도록 자극을 주며 나보다 더 잘 할 수 있는 사람에게 그 일을 맡기며, 또한 사람들이 조화롭게 업무를 수행할 수 있도록 돕는 데 있었다. 그게 수준 높다할 수 있는 기술이었다.&lt;/li&gt;\n  &lt;li&gt;위험부담에 너무 신경 쓴 나머지 아무런 결정도 내리지 못하는 사람들도 있다. 이들은 모든 사항을 열심히 검토하지만, 어느 순간부터는 추가 정보나 확증이 있어도 사업의 궁극적인 성공이나 실패에 대한 갈피를 잡지 못하게 된다. 이렇게 되면 이들은 불확실에 휩싸인 나머지 그 자리에 얼어붙은 채 현상만을 유지한다. 결국 그들이 아는 것은 그게 전부가 된다.&lt;/li&gt;\n  &lt;li&gt;하지만 좀 더 파고들어 가면, 사업의 위험부담과 함께 결부되는 개인의 위험부담도 고려하게 된다. 개인의 위험부담은 존경하지 않는 사람과 함께 일하는 것, 나와 다른 사업관을 가진 회사에서 일하는 것, 그리고 중요하다고 생각하는 것을 타협해야 하는 것, 본모습을 제대로 발휘할 수 없는, 혹은 완전히 모순되는 일을 하는 것들을 의미한다. 하지만 그 중 가장 큰 위험 부단은 미래의 행복을 위안으로 삼으면서 하고 싶지도 않은 일에 평생 인생을 낭비하게 되는 것이다.&lt;/li&gt;\n  &lt;li&gt;반면 개인적 위험은 계량화가 불가능하다. 그것은 가치와 우선순위, 자신이 누구인지를 표현하는 문제다. ‘안전 제일주의’ 라는 말은 현상에 만족하겠다는 것을 의미한다. 지금 당장 금전적 이익이 있으면 시간 낭비와 만족감의 부채 또한 감소할 수 있다는 뜻이다. 아니면 아무 생각조차 해보지 않겠다는 뜻이다. 반면, 시간과 만족이 값을 매길 수 없을만큼 소중한 것이라 여긴다면 자신과 가족의 행복을 위험에 빠뜨리지 않는 한도 내에서 실패에 따른 위험부담을 감수하게 된다. 원하는 삶을 살기 위한 위험부담은 아무것도 아니라는 것을 알기 때문이다.&lt;/li&gt;\n  &lt;li&gt;개인의 위험부담을 생각하다 보면 개인의 성공에 대한 정의도 내려진다. 사업적인 성공이 꼭 개인의 성공으로 연결된다고 할 수 없다. 우리는 대부분 초등학교에서부터 대학교를 거쳐 직장생활에 이르기까지, 끊임없는 방해요소에 부딪히면서 다른 사람들이 내린 ‘성공’ 의 정의를 그대로 인식하게 된다. 다른 사람들이 만든 기준으로 자신을 평가하고, 다른 사람과 나를 비교해 순위를 매기려 한다. 개인적인 목표는 오로지 우리 스스로에게 놓여 있을 뿐, 쓸데없는 평가와 비교로부터 자유로운 것이다.&lt;/li&gt;\n  &lt;li&gt;열정을 다해 열심히 일하라. 단, 가장 소중한 재산인 시간을 가장 의미 있는 일에 써라. 남은 인생 동안 무엇을 하고 싶은가? 이 말은 문자 그대로 앞으로 평생 무엇을 할 것인가 라는 뜻이 아니다. 예상치 않은 사회 속에서 앞으로 평생 동안 어떤 일을 하게 될지 알 수 있는 사람이 과연 누가 있을까? 내일 갑자기 생이 끝난다면 지금까지 정말로 하고 싶은 일을 하면서 살았다고 자신 있게 말할 수 있을까? 당신은 앞으로 평생 어떤 일을 하고 싶은가? 지금 당장 그 일을 시작하려면 어떻게 해야 할까?&lt;/li&gt;\n&lt;/ul&gt;\n\n            \n          ",
        "contentSnippet": "<p><img src=\"/images/2025/04/12/the-monk-and-the-riddle.png\" alt=\"The Monk And The Riddle\" title=\"The Monk And The Riddle\" class=\"center-image\" /></p>\n\n<blockquote>\n  <p><strong>“이 달걀을 1미터 정도 아래로 떨어뜨리되 깨뜨리면 안 됩니다. 어찌 해야 할까요?”</strong></p>\n</blockquote>\n\n<p>변호사이자 실리콘밸리 투자자인 <a href=\"https://en.wikipedia.org/wiki/Randy_Komisar\">랜디 코미사</a>의 이야기를 다룬 책이다. 미얀마에서 만난 한 승려가 던지는 질문으로 책에서 하고자 하는 이야기가 시작된다. <code class=\"language-plaintext highlighter-rouge\">이 달걀을 1미터 정도 아래로 떨어뜨리되 깨뜨리면 안 됩니다. 어찌 해야 할까요?</code> 이 질문을 들으면 어떤 생각이 드는가? 단단한 돌 바닥 위에서 달걀을 들고 있는 모습이 상상된다. 그런데 이걸 떨어뜨리되 깨뜨리면 안된다..? 바닥에 쿠션을 놓으면 안될까? 아니면 혹시.. 물 위에서 떨어뜨리면 안되나?</p>\n\n<p>우리는 자연스레 계란이 떨어지면 깨지는 것부터 상상한다. 그래서 깨지지 않게 하려면 바닥에 부드러운 무언가를 놓고 깨지지 않게끔 만드는게 중요하다고 생각이 든다. 승려는 어떤 메시지를 전달하고 싶어서 이런 질문을 했는지 궁금증을 가진채 계속 읽어 나갔다.</p>\n\n<p>승려는 책의 도입부에 질문을 마지막으로 나오지 않고, 그 이후부터는 랜디와 레니라는 창업가의 이야기로만 구성되어 있다. 어느날 랜디에게 장례 용품을 온라인에서 사고 팔 수 있는 사업을 하겠다고 레니라는 사람이 투자와 자문을 구하기 위해 찾아왔다. 레니는 엄청난 열정과 굉장히 구체적인 사업 계획을 가지고 있었다. 하지만 지금 당장은 돈을 벌기 위한 수단으로 사업을 하고, 돈을 많이 벌고 난 이후에 본인이 진짜 하고 싶은 일을 하려고 계획중이었다. 이런 레니의 이야기를 듣고 랜디는 열정 가득하고 사업 계획 구체적이지만, 왜 장례 사업을 하려는건지 목적과 비전이 뚜렷하지 않아서 몇 가지 조언을 남긴 뒤 투자를 위한 마음은 접기로 했다.</p>\n\n<blockquote>\n  <p>“내 경험상, 만약 돈 때문에 이 일을 시작한다면 닭 쫓던 개 신세를 면치 못할 겁니다. 돈은 결코 그렇게 따라오지 않아요. 뭔가 더 있어야 합니다. 상황이 최악으로 치달을 때 나를 지켜줄 만한 목적의식 같은 것 말이죠. 실패하더라도 이 일에 엄청난 시간과 노력을 쏟을 만한 가치가 있는, 그런 것이 있어야 한단 말입니다.”</p>\n</blockquote>\n\n<p>그러나 레니는 포기하지 않고 랜디의 조언을 바탕으로 사업 계획서를 다시 다듬고 오랜 기간 랜디를 괴롭히다시피 한다. 결국 랜디는 굉장히 끈질긴 성격을 가진 레니에게 사업을 하려고 하는 진짜 목적에 대해 스스로 고민할 수 있도록 질문을 하기 시작한다. ‘미뤄 놓은 인생 설계’, ‘내가 가장 하고 싶은 것’. 중간중간 랜디의 변호사 시절과 실리콘밸리 회사에서의 다양한 경험 이야기도 나오는데, 사업을 함에 있어 가장 중요한건 동기라는 사실을 일깨워준다. 레니는 랜디와 동업자 앨리슨의 생각과 조언을 받아들여 본인이 정말로 하고 싶었던 것과 장례 사업을 접목시켜 가슴뛰는 사업의 목적을 찾게 된다.</p>\n\n<p>살면서 혹은 일을 하면서 여러가지 문제를 마주하는데 그 때마다 <strong>지금 있는 현상에만 집중하다가 본질(핵심)이 무엇인지 잊게 된다.</strong> 현상에만 집중하다보면 본질과 다른 방향으로 답을 찾게 된다. 책의 맨 마지막에 승려가 낸 질문에 대한 해답이 나온다. 그런데 그 답이 중요한게 아니라, 승려가 왜 이 수수께끼를 냈는지가 중요하다. 책을 읽다보면 승려가 내놓은 수수께끼의 본질을 알게 되는데, <strong>‘계란이 깨지지 않게 만드는게 아니라, 1미터 높이에서 깨지지 않는 상태로 존재하게 할 수 있는 방법’</strong> 이다.</p>\n\n<p>이 책의 주된 이야기인 사업 뿐만 아니라, 우리가 하고 있는 무언가에 대한 질문이기도 하다. 지금 원하는 일을 하고 있는가? 이 일을 왜 하는가? 열심히 일해서, 돈 많이 벌어서, 나중에 하고 싶은거 하면서 편하게 즐겁게 살아야지. 인생은 출애굽기도, 영웅전도 아니다. 현재의 고통을 전제로 미래의 행복을 바꾸거나 하고 싶지도 않은 일에 인생을 낭비하기엔 너무 아깝고, 당장 하고 싶은 일을 해야 한다는 당연하면서도 어려운 교훈을 주는 책이다.</p>\n\n<h3 id=\"인상-깊은-구절\">인상 깊은 구절</h3>\n\n<ul>\n  <li>열정이란, 저항할 수조차 없이 어떤 것으로 당신 자신을 끌어가는 것을 말한다. 반면 의지란, 책임감 또는 해야만 한다고 생각되는 일에 의해 떠밀려가는 것이다. 만약 자신에 대해 아무것도 모른다면 그 차이를 알 수 없다. 조금이나마 자기 인식을 하고 있는 사람은 내가 어떤 분야에 열정을 가지고 있는지 알 수가 있다. 어떤 목표를 달성하고 싶다는 욕망은 열정이 아니며, 일정 수준의 몫이나 보너스, 또는 회사를 매각하여 현금을 벌고 싶다는 욕심도 열정이 아니다. 다른 사람의 성취를 따라 하기 위해 노력하는 것도 열정이 아니다. 그것은 의지에 가깝다.</li>\n  <li>비즈니스 환경은 늘 변한다. 사람들은 전략과 수익모델을 변화하는 환경에 맞게 지속적으로 재검토하고 필요에 따라 수정해야 한다. 하지만 수정할 때마다 기준으로 삼아야 하는 것은 기업의 큰 비전이다. 긴급한 상황을 모면하기 위해 구성원의 감동을 이끌어 내는 비전을 포기하면, 나침반 없이 남겨지는 것과 다를 바 없다. 나는 기업의 위치를 돌아볼 때 현재 상황만 따지는 것이 아니라 목표와 방향 점검도 병행돼야 한다는 충고를 늘 하고 있다. 나침반을 맞추고 길을 따라 나아가라. 그래야 장애물에 걸려 넘어지더라도 방향 감각을 유지할 수 있을 것이다.</li>\n  <li>관리와 리더십은 서로 공통점이 있기는 하지만 같은 건 아니다. 레니처럼 편협한 사고방식을 가지고 있는 사람은 그 차이를 알 수 없다. 관리는 체계적인 과정을 말하는데 그 목적은 정해진 시간과 예산 내에서 원하는 결과를 낳는 것이다. 리더십은 인격과 비전으로 다른 사람을 불가능한 일에 도전하도록 만든다. 관리는 리더십을 보완하고 지원하지만, 리더십을 내포하지 않은 관리는 아무것도 할 수 없다. 리더는 아랫사람들의 의혹을 해소시키고 불완전한 정보를 가지고도 나아갈 수 있도록 만들어야 한다.</li>\n  <li>기차를 제시간에 맞게 도착시키는 관리자의 역할보다 리더로서의 업무가 나는 더 마음에 들었다. 리더의 묘미는 계산기를 두드리고 생산라인을 개선하는 방법을 찾는 것에 있지 않았다. 사람들이 한계를 넘어설 수 있도록 용기를 북돋고, 사람들이 위대해질 수 있도록 자극을 주며 나보다 더 잘 할 수 있는 사람에게 그 일을 맡기며, 또한 사람들이 조화롭게 업무를 수행할 수 있도록 돕는 데 있었다. 그게 수준 높다할 수 있는 기술이었다.</li>\n  <li>위험부담에 너무 신경 쓴 나머지 아무런 결정도 내리지 못하는 사람들도 있다. 이들은 모든 사항을 열심히 검토하지만, 어느 순간부터는 추가 정보나 확증이 있어도 사업의 궁극적인 성공이나 실패에 대한 갈피를 잡지 못하게 된다. 이렇게 되면 이들은 불확실에 휩싸인 나머지 그 자리에 얼어붙은 채 현상만을 유지한다. 결국 그들이 아는 것은 그게 전부가 된다.</li>\n  <li>하지만 좀 더 파고들어 가면, 사업의 위험부담과 함께 결부되는 개인의 위험부담도 고려하게 된다. 개인의 위험부담은 존경하지 않는 사람과 함께 일하는 것, 나와 다른 사업관을 가진 회사에서 일하는 것, 그리고 중요하다고 생각하는 것을 타협해야 하는 것, 본모습을 제대로 발휘할 수 없는, 혹은 완전히 모순되는 일을 하는 것들을 의미한다. 하지만 그 중 가장 큰 위험 부단은 미래의 행복을 위안으로 삼으면서 하고 싶지도 않은 일에 평생 인생을 낭비하게 되는 것이다.</li>\n  <li>반면 개인적 위험은 계량화가 불가능하다. 그것은 가치와 우선순위, 자신이 누구인지를 표현하는 문제다. ‘안전 제일주의’ 라는 말은 현상에 만족하겠다는 것을 의미한다. 지금 당장 금전적 이익이 있으면 시간 낭비와 만족감의 부채 또한 감소할 수 있다는 뜻이다. 아니면 아무 생각조차 해보지 않겠다는 뜻이다. 반면, 시간과 만족이 값을 매길 수 없을만큼 소중한 것이라 여긴다면 자신과 가족의 행복을 위험에 빠뜨리지 않는 한도 내에서 실패에 따른 위험부담을 감수하게 된다. 원하는 삶을 살기 위한 위험부담은 아무것도 아니라는 것을 알기 때문이다.</li>\n  <li>개인의 위험부담을 생각하다 보면 개인의 성공에 대한 정의도 내려진다. 사업적인 성공이 꼭 개인의 성공으로 연결된다고 할 수 없다. 우리는 대부분 초등학교에서부터 대학교를 거쳐 직장생활에 이르기까지, 끊임없는 방해요소에 부딪히면서 다른 사람들이 내린 ‘성공’ 의 정의를 그대로 인식하게 된다. 다른 사람들이 만든 기준으로 자신을 평가하고, 다른 사람과 나를 비교해 순위를 매기려 한다. 개인적인 목표는 오로지 우리 스스로에게 놓여 있을 뿐, 쓸데없는 평가와 비교로부터 자유로운 것이다.</li>\n  <li>열정을 다해 열심히 일하라. 단, 가장 소중한 재산인 시간을 가장 의미 있는 일에 써라. 남은 인생 동안 무엇을 하고 싶은가? 이 말은 문자 그대로 앞으로 평생 무엇을 할 것인가 라는 뜻이 아니다. 예상치 않은 사회 속에서 앞으로 평생 동안 어떤 일을 하게 될지 알 수 있는 사람이 과연 누가 있을까? 내일 갑자기 생이 끝난다면 지금까지 정말로 하고 싶은 일을 하면서 살았다고 자신 있게 말할 수 있을까? 당신은 앞으로 평생 어떤 일을 하고 싶은가? 지금 당장 그 일을 시작하려면 어떻게 해야 할까?</li>\n</ul>",
        "guid": "https://sungjk.github.io/2025/04/12/the-monk-and-the-riddle.html",
        "isoDate": "2025-04-12T00:00:00.000Z"
      }
    ]
  },
  {
    "name": "구교준",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김덕기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "고명환",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강병수",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김봉현",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강형석",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김수로",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강미경",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김성현",
    "category": "개인",
    "posts": []
  },
  {
    "name": "강진우",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권민재",
    "category": "개인",
    "posts": []
  },
  {
    "name": "권태관",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김도곤",
    "category": "개인",
    "posts": []
  },
  {
    "name": "칡토스의 게임 개발",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김선철",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김놀부",
    "category": "개인",
    "posts": []
  },
  {
    "name": "Lael's World",
    "category": "개인",
    "posts": []
  },
  {
    "name": "프리웨어 이야기",
    "category": "개인",
    "posts": [
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "검색엔진 상위 노출을 위한 무료 프로그램, 키워드 파이터로 SEO 최적화하는 법",
        "link": "http://muzbox.tistory.com/483571",
        "pubDate": "Thu, 17 Apr 2025 19:33:06 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483571#entry483571comment",
        "content": "<p data-ke-size=\"size16\">블로그 방문자수 고민 끝! 키워드 파이터 V2로 SEO 최적화하고 상위노출 비결을 찾아보세요. 무료인데 실시간 트렌드부터 제목 생성까지 한번에! 클릭 한 번으로 블로그 트래픽이 두 배로 늘어날 수 있어요.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"><span data-url=\"https://blog.kakaocdn.net/dn/4tZKN/btsNo9W0MgL/4VRDExwXGs7p7CKu6dKjU1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/4tZKN/btsNo9W0MgL/4VRDExwXGs7p7CKu6dKjU1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/4tZKN/btsNo9W0MgL/4VRDExwXGs7p7CKu6dKjU1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4tZKN%2FbtsNo9W0MgL%2F4VRDExwXGs7p7CKu6dKjU1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"검색엔진 상위 노출을 위한 무료 프로그램, 키워드 파이터로 SEO 최적화하는 법\" loading=\"lazy\" width=\"1280\" height=\"853\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">요즘 블로그 운영하면서 방문자수 고민 안 해본 사람 있을까요? 솔직히 저도 블로그 시작하고 한동안은 그냥 '좋은 글 쓰면 사람들이 알아서 찾아오겠지' 하는 안일한 생각으로 운영했어요. 근데 현실은? 아무리 좋은 글 써도 구글이나 네이버가 내 글을 상위에 노출시켜주지 않으면 그냥 인터넷 바다에 던져진 돌맹이 신세더라고요.  </p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">그래서 요즘은 SEO(검색엔진 최적화)와 키워드 선정에 진심인데요. 오늘은 블로그 운영자, 콘텐츠 크리에이터분들에게 정말 유용한 무료 프로그램을 소개해드리려고 해요. 바로 '<span style=\"color: #ee2323;\"><b>키워드 파이터 V2</b></span>'인데, 이 프로그램 하나면 어떤 키워드로 글을 써야 할지, 어떻게 제목을 지어야 할지 고민이 싹 사라질 거예요!</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>  키워드 파이터 V2가 뭐길래?</b></span></h2>\n<p data-ke-size=\"size16\">키워드 파이터 V2는 블로그, 유튜브, 쇼핑몰 운영자들을 위한 올인원 키워드 발굴 &amp; 분석 툴이에요. 제가 일주일 전부터 써봤는데, 진짜 이런 프로그램이 무료라니...싶을 정도로 기능이 알차요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">가장 마음에 드는 점은 키워드 분석부터 블로그 제목 생성까지 원스톱으로 가능하다는 건데요. 특히 요즘처럼 경쟁이 치열한 상황에서 '어떤 키워드로 글을 써야 노출이 잘 될까?'라는 고민을 해결해주는 정말 고마운 프로그램이에요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>⚙️ 주요 기능과 사용법 살펴보기</b></span></h2>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"kakaotv\" data-video-url=\"https://tv.kakao.com/v/454478220\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/qS5Rf/hyYIkqMoa7/ivIxC54hoYKva66b76P350/img.jpg?width=1330&amp;height=1080&amp;face=0_0_1330_1080,https://scrap.kakaocdn.net/dn/kpVF8/hyYFBzWtd5/b0QKFZtmcQlj34ifOypjv0/img.jpg?width=1330&amp;height=1080&amp;face=0_0_1330_1080\" data-video-width=\"860\" data-video-height=\"698\" data-video-origin-width=\"860\" data-video-origin-height=\"698\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"'어떤오후의 프리웨어 이야기 (유용한 IT정보)'에서 업로드한 동영상\" data-video-play-service=\"daum_tistory\" data-original-url=\"\"><iframe src=\"https://play-tv.kakao.com/embed/player/cliplink/454478220?service=daum_tistory\" width=\"860\" height=\"698\" frameborder=\"0\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"color: #ee2323;\">1. 실시간 트렌드 키워드 분석</span></h3>\n<p data-ke-size=\"size16\">트렌드 탭에서는 구글 트렌드와 시그널(옛 네이버 실검과 비슷한) 실시간 인기 검색어를 한눈에 볼 수 있어요. '실시간 검색어 일괄 조회' 버튼만 누르면 현재 사람들이 많이 검색하는 키워드가 쫙 나오죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이렇게 뜨는 키워드 중에서 내 블로그 주제와 연관된 것이 있다면? 바로 그날의 트렌드에 맞는 글을 쓸 수 있는 절호의 기회예요! 제가 지난주 '메타버스'라는 키워드가 실시간 검색어에 올라왔을 때 바로 관련 글을 썼더니 평소보다 3배 이상 방문자가 늘었어요. 이게 바로 트렌드 파악의 힘이죠!</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">2. 자동완성 키워드 수집</span></h3>\n<p data-ke-size=\"size16\">그 다음으로 유용한 건 자동완성 키워드 기능이에요. 구글, 네이버, 빙의 자동완성 키워드를 한 번에 수집해주는데, 이게 왜 중요하냐면, 자동완성 키워드는 실제로 사람들이 많이 검색하는 키워드를 보여주기 때문이에요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어 '다이어트'를 검색하면 '다이어트 식단', '다이어트 운동', '다이어트 방법' 같은 자동완성 키워드가 뜨는데, 이런 키워드들은 실제 사용자들이 관심있어 하는 정보를 보여주는 거예요. 그래서 이걸 활용하면 독자들이 정말 알고 싶어하는 내용으로 글을 쓸 수 있죠.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">3. 키워드 분석 및 경쟁도 체크</span></h3>\n<p data-ke-size=\"size16\">이 기능이 진짜 핵심인데요, '키워드 분석' 탭에서는 검색한 키워드의 월간 검색량(PC/모바일), 총 조회수, 문서 수, 그리고 경쟁 비율까지 분석해줘요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어 '제주도 여행'이라는 키워드를 검색했다고 쳐볼게요. 그러면 PC 검색량 5만, 모바일 검색량 10만, 문서 수 50만 개 정도가 나올 수 있어요. 이 정보를 보고 '아, 이 키워드는 검색량은 많지만 이미 경쟁이 너무 심하구나'라고 판단할 수 있죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">근데 더 놀라운 건 '관련 키워드' 목록도 함께 보여준다는 거예요. '제주도 여행'에서 파생된 '제주도 여행 코스', '제주도 여행 맛집', '제주도 여행 렌트카' 같은 연관 키워드를 확인할 수 있어요. 이 중에서 검색량은 적당히 있는데 경쟁은 덜한 키워드를 찾아내는 게 SEO의 핵심 전략이죠!</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">4. SEO 최적화 블로그 제목 자동 생성</span></h3>\n<p data-ke-size=\"size16\">이 기능은 정말 신세계였어요. 키워드 분석 결과에서 '키워드 조합으로 SEO 최적화 블로그 제목 만들기' 버튼을 누르면 자동으로 GPTS 사이트로 연결되는데요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">거기서 분석한 키워드들을 붙여넣기만 하면 GPTS가 알아서 SEO에 최적화된 블로그 제목을 여러 개 제안해줘요. 제가 얼마 전에 '홈카페 원두추천'이라는 키워드로 해봤는데, '집에서 즐기는 프리미엄 커피, 바리스타도 인정한 원두 BEST 5', '홈카페 격이 다른 맛, 가성비 원두 추천 및 활용법 총정리' 같은 제목을 제안해줬어요. 이런 제목들은 단순히 키워드만 넣은 것보다 클릭율이 훨씬 높더라고요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>  실전에서 키워드 파이터 활용하기</b></span></h2>\n<p data-ke-size=\"size16\">제가 실제로 키워드 파이터를 활용해서 블로그 글을 작성한 방법을 공유할게요.</p>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>트렌드 키워드 발굴 &rarr; 관련성 확인</b> 저는 먼저 '실시간 트렌드' 탭에서 핫한 키워드를 확인해요. 얼마 전에 '미니멀라이프'가 트렌드에 올라왔을 때, 제 블로그가 라이프스타일 관련이다 보니 이걸 놓칠 수 없었죠.</li>\n<li><b>키워드 분석으로 경쟁도 체크</b> 그 다음 '미니멀라이프'를 검색창에 넣고 키워드 분석을 해봤어요. 검색량은 꽤 있는데 경쟁이 너무 심해서, 관련 키워드 중에서 '미니멀라이프 시작하기'라는 키워드를 선택했죠. 이건 검색량도 적당하고 경쟁도 상대적으로 적었거든요.</li>\n<li><b>자동완성 키워드로 독자 의도 파악</b> 자동완성 키워드를 보니 '미니멀라이프 시작하기 팁', '미니멀라이프 시작하기 옷정리' 같은 키워드가 있더라고요. 이걸 보고 '아, 사람들은 구체적인 실천 방법을 알고 싶어하는구나'라고 파악했어요.</li>\n<li><b>최적화 제목 생성 및 콘텐츠 작성</b> 마지막으로 GPTS 제목 생성 기능을 활용해 '버리기 전에 읽어보세요, 후회 없는 미니멀라이프 시작하기 8단계 가이드'라는 제목으로 글을 작성했어요.</li>\n</ol>\n<p data-ke-size=\"size16\">결과적으로 이 글은 구글에서 '미니멀라이프 시작하기' 키워드로 검색했을 때 2페이지에 노출되었고, 평소보다 2배 이상의 트래픽을 가져왔어요. 이게 다 키워드 파이터 덕분이죠!  </p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>  실전 활용을 위한 꿀팁</b></span><b></b></h2>\n<p data-ke-size=\"size16\">\"키워드 파이터 V2\"에는 위의 핵심기능 외에도 키워드와 블로그 주제선정에 유용한 무료 GPTS 를 함께 공개하니 참고하세요.</p>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>롱테일 키워드를 노려라</b> 메인 키워드보다는 '명사+명사+동사' 형태의 구체적인 롱테일 키워드가 경쟁이 적고 전환율이 높아요. 키워드 파이터의 관련 키워드와 자동완성 키워드에서 이런 롱테일을 찾아보세요.</li>\n<li><b>트렌드와 에버그린의 균형</b> 트렌드 키워드는 단기 트래픽에 좋지만, 에버그린 콘텐츠(시간이 지나도 가치가 있는)를 위한 키워드도 균형있게 공략하세요. 프로그램의 'GPTS 탭'에 있는 '에버그린 콘텐츠 GPT'가 이런 키워드 발굴에 도움이 돼요.</li>\n<li><b>제목에 감정을 자극하는 단어 추가</b> 키워드 파이터로 찾은 키워드에 '놀라운', '충격적인', '꼭 알아야 할' 같은 감정적 단어를 더하면 클릭율이 높아져요. 물론 너무 낚시성은 피해야겠죠!</li>\n<li><b>경쟁자 분석에 활용</b> 상위 노출된 경쟁자의 제목과 키워드를 분석해 역공략 전략을 세우는 데도 키워드 파이터가 유용해요. 그들이 놓친 틈새 키워드를 찾아내세요.</li>\n</ol>\n<p style=\"color: #333333; text-align: start;\" data-ke-size=\"size16\">요즘 블로그 운영이 점점 더 경쟁이 치열해지고 있어요. 그냥 좋은 글만 쓴다고 사람들이 찾아오는 시대는 지났죠. 하지만 이런 도구의 도움을 받으면 우리 같은 개인 블로거도 큰 포털 사이트나 기업 블로그와 경쟁할 수 있어요!</p>\n<p style=\"color: #333333; text-align: start;\" data-ke-size=\"size16\">키워드 파이터 V2는 제가 써본 무료 키워드 분석 도구 중에서 가장 실용적이고 직관적이었던 것 같아요. 특히 GPTS와의 연동 기능은 정말 혁신적이라고 생각해요. 이 글을 읽고 계신 블로거분들, 유튜버분들, 온라인 숍 운영자분들이라면 꼭 한번 사용해보시길 추천드려요!</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"1055\" data-origin-height=\"664\"><span data-url=\"https://blog.kakaocdn.net/dn/6yFnv/btsNo3JtAGz/zTJWS0l8KGwwYglKEJL3Wk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/6yFnv/btsNo3JtAGz/zTJWS0l8KGwwYglKEJL3Wk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/6yFnv/btsNo3JtAGz/zTJWS0l8KGwwYglKEJL3Wk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6yFnv%2FbtsNo3JtAGz%2FzTJWS0l8KGwwYglKEJL3Wk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"키워드 파이터 V2 활용팁\" loading=\"lazy\" width=\"1055\" height=\"664\" data-origin-width=\"1055\" data-origin-height=\"664\"/></span></figure>\n</p>\n<p style=\"color: #333333; text-align: start;\" data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\" data-ke-size=\"size16\">여러분의 블로그 운영 경험이나 키워드 파이터 사용 후기가 있다면 댓글로 남겨주세요. 서로의 경험을 나누다 보면 모두 함께 성장할 수 있을 거예요! 다음 포스팅에서는 제가 키워드 파이터로 발굴한 키워드로 실제 한 달간 블로그를 운영한 결과를 공유해드릴게요. 기대해주세요!  </p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style1\" />\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\">  자주 묻는 질문 (Q&amp;A)</span></h2>\n<p data-ke-size=\"size16\"><b>Q: 키워드 파이터 V2는 어디서 다운로드할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 본 기사 하단에 다운로드 링크가 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 다른 키워드 분석 도구와 비교했을 때 장점은 무엇인가요?</b></p>\n<p data-ke-size=\"size16\">A: 무료임에도 실시간 트렌드, 키워드 분석, 자동완성, 블로그 제목 생성까지 올인원으로 제공하는 점이 가장 큰 장점입니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 유튜브나 쇼핑몰에도 활용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 네, 키워드 분석 원리는 동일하게 적용됩니다. 특히 'GPTS 탭'의 다양한 도구를 활용하면 각 플랫폼에 맞는 키워드 전략을 수립할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 초보자도 쉽게 사용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 네, 직관적인 UI와 '사용법' 탭의 상세한 가이드 덕분에 SEO 초보자도 쉽게 활용할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 실제로 효과가 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 적절한 키워드 선정은 SEO의 기본이므로, 이 도구를 잘 활용하면 검색 노출과 트래픽 향상에 확실한 효과가 있습니다. 다만 양질의 콘텐츠가 뒷받침되어야 합니다.</p>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"키워드 파이터 V2는 어디서 다운로드할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 구글에서 '키워드 파이터 V2 다운로드'로 검색하면 공식 배포 페이지를 찾을 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"다른 키워드 분석 도구와 비교했을 때 장점은 무엇인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"무료임에도 실시간 트렌드, 키워드 분석, 자동완성, 블로그 제목 생성까지 올인원으로 제공하는 점이 가장 큰 장점입니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"유튜브나 쇼핑몰에도 활용할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 키워드 분석 원리는 동일하게 적용됩니다. 특히 'GPTS 탭'의 다양한 도구를 활용하면 각 플랫폼에 맞는 키워드 전략을 수립할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"초보자도 쉽게 사용할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 직관적인 UI와 '사용법' 탭의 상세한 가이드 덕분에 SEO 초보자도 쉽게 활용할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"실제로 효과가 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"적절한 키워드 선정은 SEO의 기본이므로, 이 도구를 잘 활용하면 검색 노출과 트래픽 향상에 확실한 효과가 있습니다. 다만 양질의 콘텐츠가 뒷받침되어야 합니다.\"\n      }\n    }\n  ]\n}\n</script>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"color: #006dd7;\">  프로그램 다운로드</span></h2>\n<div class=\"revenue_unit_wrap\">\n  <div class=\"revenue_unit_item adsense responsive\">\n    <div class=\"revenue_unit_info\">반응형</div>\n    <script src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\" async=\"async\"></script>\n    <ins class=\"adsbygoogle\" style=\"display: block;\" data-ad-host=\"ca-host-pub-9691043933427338\" data-ad-client=\"ca-pub-8195497734535830\" data-ad-format=\"auto\"></ins>\n    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>\n  </div>\n</div>\n<p><figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/dalHQo/btsNpTer4Q7/h8dkus65yixIAyTuM1HAEK/keyword_fighter_v2.z01?attach=1&amp;knm=tfile.z01\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.z01</span></div>\n<div class=\"size\">9.77MB</div>\n</div>\n  </a></figure>\n<figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/lpPu3/btsNpAsZQPh/tpNkkhOR0hyNFGL7uYeS4k/keyword_fighter_v2.z02?attach=1&amp;knm=tfile.z02\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.z02</span></div>\n<div class=\"size\">9.77MB</div>\n</div>\n  </a></figure>\n<figure class=\"fileblock\" data-ke-align=\"alignCenter\"><a href=\"https://blog.kakaocdn.net/dn/EY4oQ/btsNmH67t37/26S6tni4wmexcebJN1L8O1/keyword_fighter_v2.zip?attach=1&amp;knm=tfile.zip\" class=\"\">\n    <div class=\"image\"></div>\n    <div class=\"desc\"><div class=\"filename\"><span class=\"name\">keyword_fighter_v2.zip</span></div>\n<div class=\"size\">3.87MB</div>\n</div>\n  </a></figure>\n</p>",
        "contentSnippet": "블로그 방문자수 고민 끝! 키워드 파이터 V2로 SEO 최적화하고 상위노출 비결을 찾아보세요. 무료인데 실시간 트렌드부터 제목 생성까지 한번에! 클릭 한 번으로 블로그 트래픽이 두 배로 늘어날 수 있어요.\n\n\n \n요즘 블로그 운영하면서 방문자수 고민 안 해본 사람 있을까요? 솔직히 저도 블로그 시작하고 한동안은 그냥 '좋은 글 쓰면 사람들이 알아서 찾아오겠지' 하는 안일한 생각으로 운영했어요. 근데 현실은? 아무리 좋은 글 써도 구글이나 네이버가 내 글을 상위에 노출시켜주지 않으면 그냥 인터넷 바다에 던져진 돌맹이 신세더라고요.  \n \n그래서 요즘은 SEO(검색엔진 최적화)와 키워드 선정에 진심인데요. 오늘은 블로그 운영자, 콘텐츠 크리에이터분들에게 정말 유용한 무료 프로그램을 소개해드리려고 해요. 바로 '키워드 파이터 V2'인데, 이 프로그램 하나면 어떤 키워드로 글을 써야 할지, 어떻게 제목을 지어야 할지 고민이 싹 사라질 거예요!\n \n  키워드 파이터 V2가 뭐길래?\n키워드 파이터 V2는 블로그, 유튜브, 쇼핑몰 운영자들을 위한 올인원 키워드 발굴 & 분석 툴이에요. 제가 일주일 전부터 써봤는데, 진짜 이런 프로그램이 무료라니...싶을 정도로 기능이 알차요.\n \n가장 마음에 드는 점은 키워드 분석부터 블로그 제목 생성까지 원스톱으로 가능하다는 건데요. 특히 요즘처럼 경쟁이 치열한 상황에서 '어떤 키워드로 글을 써야 노출이 잘 될까?'라는 고민을 해결해주는 정말 고마운 프로그램이에요.\n \n⚙️ 주요 기능과 사용법 살펴보기\n\n\n\n \n1. 실시간 트렌드 키워드 분석\n트렌드 탭에서는 구글 트렌드와 시그널(옛 네이버 실검과 비슷한) 실시간 인기 검색어를 한눈에 볼 수 있어요. '실시간 검색어 일괄 조회' 버튼만 누르면 현재 사람들이 많이 검색하는 키워드가 쫙 나오죠.\n \n이렇게 뜨는 키워드 중에서 내 블로그 주제와 연관된 것이 있다면? 바로 그날의 트렌드에 맞는 글을 쓸 수 있는 절호의 기회예요! 제가 지난주 '메타버스'라는 키워드가 실시간 검색어에 올라왔을 때 바로 관련 글을 썼더니 평소보다 3배 이상 방문자가 늘었어요. 이게 바로 트렌드 파악의 힘이죠!\n \n2. 자동완성 키워드 수집\n그 다음으로 유용한 건 자동완성 키워드 기능이에요. 구글, 네이버, 빙의 자동완성 키워드를 한 번에 수집해주는데, 이게 왜 중요하냐면, 자동완성 키워드는 실제로 사람들이 많이 검색하는 키워드를 보여주기 때문이에요.\n \n예를 들어 '다이어트'를 검색하면 '다이어트 식단', '다이어트 운동', '다이어트 방법' 같은 자동완성 키워드가 뜨는데, 이런 키워드들은 실제 사용자들이 관심있어 하는 정보를 보여주는 거예요. 그래서 이걸 활용하면 독자들이 정말 알고 싶어하는 내용으로 글을 쓸 수 있죠.\n3. 키워드 분석 및 경쟁도 체크\n이 기능이 진짜 핵심인데요, '키워드 분석' 탭에서는 검색한 키워드의 월간 검색량(PC/모바일), 총 조회수, 문서 수, 그리고 경쟁 비율까지 분석해줘요.\n \n예를 들어 '제주도 여행'이라는 키워드를 검색했다고 쳐볼게요. 그러면 PC 검색량 5만, 모바일 검색량 10만, 문서 수 50만 개 정도가 나올 수 있어요. 이 정보를 보고 '아, 이 키워드는 검색량은 많지만 이미 경쟁이 너무 심하구나'라고 판단할 수 있죠.\n \n근데 더 놀라운 건 '관련 키워드' 목록도 함께 보여준다는 거예요. '제주도 여행'에서 파생된 '제주도 여행 코스', '제주도 여행 맛집', '제주도 여행 렌트카' 같은 연관 키워드를 확인할 수 있어요. 이 중에서 검색량은 적당히 있는데 경쟁은 덜한 키워드를 찾아내는 게 SEO의 핵심 전략이죠!\n4. SEO 최적화 블로그 제목 자동 생성\n이 기능은 정말 신세계였어요. 키워드 분석 결과에서 '키워드 조합으로 SEO 최적화 블로그 제목 만들기' 버튼을 누르면 자동으로 GPTS 사이트로 연결되는데요.\n \n거기서 분석한 키워드들을 붙여넣기만 하면 GPTS가 알아서 SEO에 최적화된 블로그 제목을 여러 개 제안해줘요. 제가 얼마 전에 '홈카페 원두추천'이라는 키워드로 해봤는데, '집에서 즐기는 프리미엄 커피, 바리스타도 인정한 원두 BEST 5', '홈카페 격이 다른 맛, 가성비 원두 추천 및 활용법 총정리' 같은 제목을 제안해줬어요. 이런 제목들은 단순히 키워드만 넣은 것보다 클릭율이 훨씬 높더라고요.\n \n  실전에서 키워드 파이터 활용하기\n제가 실제로 키워드 파이터를 활용해서 블로그 글을 작성한 방법을 공유할게요.\n트렌드 키워드 발굴 → 관련성 확인 저는 먼저 '실시간 트렌드' 탭에서 핫한 키워드를 확인해요. 얼마 전에 '미니멀라이프'가 트렌드에 올라왔을 때, 제 블로그가 라이프스타일 관련이다 보니 이걸 놓칠 수 없었죠.\n키워드 분석으로 경쟁도 체크 그 다음 '미니멀라이프'를 검색창에 넣고 키워드 분석을 해봤어요. 검색량은 꽤 있는데 경쟁이 너무 심해서, 관련 키워드 중에서 '미니멀라이프 시작하기'라는 키워드를 선택했죠. 이건 검색량도 적당하고 경쟁도 상대적으로 적었거든요.\n자동완성 키워드로 독자 의도 파악 자동완성 키워드를 보니 '미니멀라이프 시작하기 팁', '미니멀라이프 시작하기 옷정리' 같은 키워드가 있더라고요. 이걸 보고 '아, 사람들은 구체적인 실천 방법을 알고 싶어하는구나'라고 파악했어요.\n최적화 제목 생성 및 콘텐츠 작성 마지막으로 GPTS 제목 생성 기능을 활용해 '버리기 전에 읽어보세요, 후회 없는 미니멀라이프 시작하기 8단계 가이드'라는 제목으로 글을 작성했어요.\n결과적으로 이 글은 구글에서 '미니멀라이프 시작하기' 키워드로 검색했을 때 2페이지에 노출되었고, 평소보다 2배 이상의 트래픽을 가져왔어요. 이게 다 키워드 파이터 덕분이죠!  \n \n  실전 활용을 위한 꿀팁\n\"키워드 파이터 V2\"에는 위의 핵심기능 외에도 키워드와 블로그 주제선정에 유용한 무료 GPTS 를 함께 공개하니 참고하세요.\n롱테일 키워드를 노려라 메인 키워드보다는 '명사+명사+동사' 형태의 구체적인 롱테일 키워드가 경쟁이 적고 전환율이 높아요. 키워드 파이터의 관련 키워드와 자동완성 키워드에서 이런 롱테일을 찾아보세요.\n트렌드와 에버그린의 균형 트렌드 키워드는 단기 트래픽에 좋지만, 에버그린 콘텐츠(시간이 지나도 가치가 있는)를 위한 키워드도 균형있게 공략하세요. 프로그램의 'GPTS 탭'에 있는 '에버그린 콘텐츠 GPT'가 이런 키워드 발굴에 도움이 돼요.\n제목에 감정을 자극하는 단어 추가 키워드 파이터로 찾은 키워드에 '놀라운', '충격적인', '꼭 알아야 할' 같은 감정적 단어를 더하면 클릭율이 높아져요. 물론 너무 낚시성은 피해야겠죠!\n경쟁자 분석에 활용 상위 노출된 경쟁자의 제목과 키워드를 분석해 역공략 전략을 세우는 데도 키워드 파이터가 유용해요. 그들이 놓친 틈새 키워드를 찾아내세요.\n요즘 블로그 운영이 점점 더 경쟁이 치열해지고 있어요. 그냥 좋은 글만 쓴다고 사람들이 찾아오는 시대는 지났죠. 하지만 이런 도구의 도움을 받으면 우리 같은 개인 블로거도 큰 포털 사이트나 기업 블로그와 경쟁할 수 있어요!\n키워드 파이터 V2는 제가 써본 무료 키워드 분석 도구 중에서 가장 실용적이고 직관적이었던 것 같아요. 특히 GPTS와의 연동 기능은 정말 혁신적이라고 생각해요. 이 글을 읽고 계신 블로거분들, 유튜버분들, 온라인 숍 운영자분들이라면 꼭 한번 사용해보시길 추천드려요!\n\n\n \n여러분의 블로그 운영 경험이나 키워드 파이터 사용 후기가 있다면 댓글로 남겨주세요. 서로의 경험을 나누다 보면 모두 함께 성장할 수 있을 거예요! 다음 포스팅에서는 제가 키워드 파이터로 발굴한 키워드로 실제 한 달간 블로그를 운영한 결과를 공유해드릴게요. 기대해주세요!  \n \n  자주 묻는 질문 (Q&A)\nQ: 키워드 파이터 V2는 어디서 다운로드할 수 있나요?\nA: 본 기사 하단에 다운로드 링크가 있습니다.\nQ: 다른 키워드 분석 도구와 비교했을 때 장점은 무엇인가요?\nA: 무료임에도 실시간 트렌드, 키워드 분석, 자동완성, 블로그 제목 생성까지 올인원으로 제공하는 점이 가장 큰 장점입니다.\nQ: 유튜브나 쇼핑몰에도 활용할 수 있나요?\nA: 네, 키워드 분석 원리는 동일하게 적용됩니다. 특히 'GPTS 탭'의 다양한 도구를 활용하면 각 플랫폼에 맞는 키워드 전략을 수립할 수 있습니다.\nQ: 초보자도 쉽게 사용할 수 있나요?\nA: 네, 직관적인 UI와 '사용법' 탭의 상세한 가이드 덕분에 SEO 초보자도 쉽게 활용할 수 있습니다.\nQ: 실제로 효과가 있나요?\nA: 적절한 키워드 선정은 SEO의 기본이므로, 이 도구를 잘 활용하면 검색 노출과 트래픽 향상에 확실한 효과가 있습니다. 다만 양질의 콘텐츠가 뒷받침되어야 합니다.\n \n  프로그램 다운로드\n반응형\n\n    \n    (adsbygoogle = window.adsbygoogle || []).push({});\n  \n\n    \n\n    \nkeyword_fighter_v2.z01\n9.77MB\n\n\n    \n\n    \nkeyword_fighter_v2.z02\n9.77MB\n\n\n    \n\n    \nkeyword_fighter_v2.zip\n3.87MB",
        "guid": "http://muzbox.tistory.com/483571",
        "categories": [
          "NEWS/My Self",
          "gpts",
          "SEO 최적화",
          "검색엔진 최적화",
          "구글 트렌드",
          "롱테일 키워드",
          "무료 키워드 도구",
          "블로그 검색 노출",
          "블로그 제목 생성",
          "키워드 분석",
          "키워드 파이터"
        ],
        "isoDate": "2025-04-17T10:33:06.000Z"
      },
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "더 똑똑해진 챗GPT o3와 o4-mini 공개 , 기존 모델과 차이는?",
        "link": "http://muzbox.tistory.com/483570",
        "pubDate": "Thu, 17 Apr 2025 08:39:33 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483570#entry483570comment",
        "content": "<p data-ke-size=\"size16\">OpenAI의 새 모델 o3와 o4-mini가 뭐길래 이렇게 화제인걸까요? 더 오래 생각하고, 도구를 사용하며, 이미지까지 이해하는 이 모델들이 AI의 미래를 어떻게 바꿀지 함께 알아보세요!  </p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"><span data-url=\"https://blog.kakaocdn.net/dn/4B70K/btsNoPv2TY6/bQzUb4AxbrWIWdoJkwOrOk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/4B70K/btsNoPv2TY6/bQzUb4AxbrWIWdoJkwOrOk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/4B70K/btsNoPv2TY6/bQzUb4AxbrWIWdoJkwOrOk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4B70K%2FbtsNoPv2TY6%2FbQzUb4AxbrWIWdoJkwOrOk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"더 똑똑해진 챗GPT o3와 o4-mini 공개\" loading=\"lazy\" width=\"1280\" height=\"853\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">요즘 인공지능 업계는 진짜 숨 돌릴 틈이 없는 것 같아요. 오늘은 OpenAI가 또 새로운 모델을 내놨네요. 솔직히 따라가기 벅찬 느낌이랄까요? 특히 이번에 공개된 OpenAI의 o3와 o4-mini는 정말 많은 관심을 받고 있더라고요. 근데 이게 진짜 대단한 혁신인지, 아니면 그냥 마케팅 전략인지 궁금해서 한번 자세히 들여다봤어요. 여러분도 이런 고민 한번쯤 해보셨죠?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>o 시리즈가 뭘까? 그리고 이게 왜 중요할까?  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI의 새로운 o3와 o4-mini는 생각하는 시간을 더 길게 가지고 응답할 수 있도록 학습된 O 시리즈의 최신 모델입니다. 이 모델들은 지금까지 OpenAI가 출시한 모델 중 가장 똑똑한 모델로, ChatGPT의 기능에 큰 변화를 가져올 것으로 예상됩니다.</p>\n<p data-ke-size=\"size16\">특히 주목할 점은 이 모델들이 챗GPT 내의 모든 도구를 에이전트처럼 사용하고 결합할 수 있다는 것입니다. 여기에는 웹 검색, 업로드된 파일 및 기타 데이터를 Python으로 분석하는 기능, 시각적 입력에 대한 심층 추론, 심지어 이미지 생성까지 포함됩니다. 이건 진짜 획기적인 변화 아닐까요?  </p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이를 통해 다면적인 질문을 더 효과적으로 해결할 수 있게 되었고, 이는 사용자를 대신해 독립적으로 작업을 실행할 수 있는 더 에이전트형 ChatGPT를 향한 한 걸음이라고 볼 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>o3와 o4-mini의 차이점은 무엇일까?  </b></span></h2>\n<table style=\"border-collapse: collapse; width: 100%; margin: 15px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #4a86e8; color: white;\">\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px; width: 13.4884%;\">모델</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px; width: 42.3256%;\">주요 특징</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px; width: 44.0698%;\">최적 사용 케이스</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 13.4884%;\"><b>OpenAI o3</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 42.3256%;\">가장 강력한 추론 모델, 코딩/수학/과학/시각적 인식에서 최고 성능, o1보다 20% 더 적은 오류율</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 44.0698%;\">복잡한 다면적 분석, 이미지/차트/그래픽 분석, 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상</td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 13.4884%;\"><b>OpenAI o4-mini</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 42.3256%;\">빠르고 비용 효율적인 추론에 최적화, 크기와 비용 대비 뛰어난 성능, AIME 2024/2025 벤치마크 1위</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px; width: 44.0698%;\">수학, 코딩, 시각적 작업, 데이터 과학, 고용량/고처리량 필요 작업</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">OpenAI o3는 회사의 가장 강력한 추론 모델로, 코딩, 수학, 과학, 시각적 인식 등 여러 분야에서 최첨단 성능을 발휘합니다. Codeforces, SWE-bench (별도의 모델별 스캐폴드 없이), MMMU 등의 벤치마크에서 새로운 최고 성능을 기록했죠. 이 모델은 복잡한 다면적 분석이 필요하고 즉각적인 답이 명확하지 않은 복잡한 질의에 이상적입니다. 특히 이미지, 차트, 그래픽 분석과 같은 시각적 작업에서 강점을 보입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">외부 전문가들의 평가에 따르면, o3는 어려운 실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘합니다. 초기 테스터들은 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력을 강조했습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">반면에, OpenAI o4-mini는 빠르고 비용 효율적인 추론에 최적화된 더 작은 모델입니다. 크기와 비용 대비 놀라운 성능을 보이며, 특히 수학, 코딩, 시각적 작업에서 뛰어납니다. AIME 2024와 2025 벤치마크에서 가장 뛰어난 성능을 보이는 모델입니다. 전문가 평가에서도 데이터 과학과 같은 분야뿐만 아니라 비-STEM 작업에서도 이전 모델인 o3-mini보다 뛰어난 성능을 보였습니다.</p>\n<p data-ke-size=\"size16\">효율성 덕분에 o3보다 훨씬 더 높은 사용 제한을 지원하여, 추론이 필요한 질문에 대해 강력한 고용량, 고처리량 옵션이 됩니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>실제 성능은 어떨까?  </b></span></h2>\n<table style=\"border-collapse: collapse; width: 100%; margin: 15px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #4a86e8; color: white;\">\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">벤치마크/작업</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">o1</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">o3-mini</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">o3</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">o4-mini</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">AIME 2024 (경쟁 수학)</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">74.3%</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">87.3%</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">91.6%</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\"><b>93.4%</b></td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">Codeforces (경쟁 코딩)</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">1891</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">2073</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\"><b>2706</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">2719</td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">MMMU (대학 수준 시각적 문제 해결)</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">77.6%</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">-</td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\"><b>82.9%</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">81.6%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">벤치마크 성능을 보면 정말 놀랍습니다. 외부 전문가 평가자들은 두 모델 모두 향상된 명령 준수와 이전 모델보다 더 유용하고 검증 가능한 응답을 보여준다고 평가했습니다. 이는 향상된 지능과 웹 소스의 통합 덕분입니다. 이전 추론 모델 반복과 비교할 때, 이 두 모델은 특히 기억과 과거 대화를 참조하여 응답을 더 개인화하고 관련성을 높이는 데 있어 더 자연스럽고 대화적이라고 합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">OpenAI o3는 ChatGPT 내 전체 도구 접근권과 함께 API를 통한 사용자 지정 도구에도 접근할 수 있습니다. 이 모델들은 문제 해결 방법을 추론하고, 도구를 언제, 어떻게 사용할지 선택하여 일반적으로 1분 이내에 올바른 출력 형식으로 상세하고 사려 깊은 답변을 빠르게 생성하도록 학습되었습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어, 사용자가 \"캘리포니아의 여름 에너지 사용량이 작년과 비교하여 어떻게 될까요?\"라고 물을 수 있습니다. 이때 모델은 공공 유틸리티 데이터에 대한 웹 검색을 하고, 예측을 구축하기 위한 Python 코드를 작성하고, 그래프나 이미지를 생성한 다음, 예측 뒤에 있는 주요 요소를 설명할 수 있습니다. 이 과정에서 여러 도구 호출을 연결합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">추론을 통해 모델은 접하는 정보에 따라 필요에 따라 반응하고 방향을 전환할 수 있습니다. 예를 들어, 검색 제공업체의 도움을 받아 웹을 여러 번 검색하고, 결과를 살펴보고, 더 많은 정보가 필요한 경우 새로운 검색을 시도할 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>예를 통해 본 성능 차이  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI는 이 모델들의 뛰어난 성능을 보여주는 몇 가지 예시를 제공했습니다. o3와 o1의 성능을 비교하면 그 차이가 확연히 드러납니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어, 복잡한 수학 문제에서 o3는 디크슨 다항식(Dickson polynomial)을 사용해 문제를 정확히 풀어내는 반면, o1은 시간이 더 걸리고 부정확한 해결책을 제시합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">또한 호텔 체인 확장에 관한 질문에서도 o3는 실제 데이터를 활용한 철저한 분석을 통해 아테네와 오사카를 목표 도시로 추천했습니다. 각 도시의 점유율, RevPAR 성장률, 승객 증가율 등 구체적인 지표와 2024년 통계자료를 바탕으로 상세한 비교 테이블까지 제공했죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">배터리 기술 발전에 관한 질문에서도 o3는 리튬 이온 배터리, 솔리드 스테이트 배터리, 나트륨 이온 배터리 등 최신 기술의 영향을 상세히 분석하며, 2011년부터 2024년까지의 전기차 주행거리, 충전 속도, 보급률 등의 변화를 그래프로 시각화해 보여주었습니다.</p>\n<p data-ke-size=\"size16\">MLB 피치 클럭 규칙이 투수 성능과 게임 시간에 미친 영향에 관한 질문에서도 o3는 구체적인 통계 데이터를 활용해 2021년부터 2024년까지의 변화를 상세히 분석했습니다. 규칙 도입 이후 게임 시간이 24분 단축됐고, 초기에는 투수들의 ERA가 상승했지만 적응 기간을 거쳐 다시 안정되었다는 흥미로운 분석을 제공했죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이런 예시들을 보면 o3와 o4-mini의 성능이 정말 인상적이라는 걸 알 수 있어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>핵심 기술적 특징  </b></span></h2>\n<table style=\"border-collapse: collapse; width: 100%; margin: 15px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #4a86e8; color: white;\">\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">기술적 혁신</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">특징</th>\n<th style=\"border: 1px solid #dddddd; text-align: center; padding: 8px;\">영향</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\"><b>강화학습 확장</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">\"더 많은 컴퓨팅 = 더 나은 성능\" 트렌드 확인</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">더 오래 생각할수록 성능이 지속적으로 향상</td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\"><b>에이전트형 도구 사용</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">도구를 언제, 어떻게 사용할지 추론하는 능력</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">시각적 추론, 다단계 워크플로우 처리 능력 향상</td>\n</tr>\n<tr>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\"><b>이미지 통합 사고</b></td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">이미지를 사고 과정에 직접 통합</td>\n<td style=\"border: 1px solid #dddddd; text-align: left; padding: 8px;\">시각적, 텍스트 추론을 혼합한 새로운 문제 해결 가능</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">OpenAI의 o3 개발 과정에서, 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 GPT 시리즈 사전 학습에서 관찰된 것과 동일한 추세를 보여주는 것으로 확인됐습니다. OpenAI는 현재 강화학습에서 이 확장 경로를 다시 따라가며, 학습 컴퓨팅과 추론 시간을 추가로 10배 증가시켰음에도 여전히 성능 향상이 명확하게 보이는 것을 확인했습니다. 이는 모델이 더 오래 생각할수록 성능이 계속 향상된다는 것을 검증합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">o3와 o4-mini는 강화학습을 통해 도구를 사용하도록 학습되었습니다. 이는 단순히 도구 사용법을 학습하는 것이 아니라, 언제 도구를 사용할지에 대해 추론하는 능력을 키웠다는 의미입니다. 원하는 결과에 따라 도구를 배치하는 능력은 특히 시각적 추론과 다단계 워크플로우를 포함하는 개방형 상황에서 더 유능하게 만듭니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이러한 개선은 학술 벤치마크와 실제 작업 모두에서 반영되어, 초기 테스터들의 보고에서도 확인됩니다.</p>\n<p data-ke-size=\"size16\">또한 이 모델들은 처음으로 이미지를 직접 사고 과정에 통합할 수 있습니다. 단순히 이미지를 보는 것이 아니라, 그것을 가지고 생각합니다. 이는 시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결을 가능하게 하며, 이는 다양한 다중모달 벤치마크에서의 최첨단 성능으로 반영됩니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>실생활에서의 응용 가능성  ️</b></span></h2>\n<p data-ke-size=\"size16\">이 새로운 모델들의 활용 가능성은 정말 광범위해요. 일상적인 작업부터 복잡한 비즈니스 문제, 교육, 연구까지 다양한 분야에서 활용될 수 있습니다. 예를 들어, 공공 유틸리티 데이터를 검색하고, 예측 모델을 구축하며, 결과를 시각화하는 복잡한 작업을 한 번에 처리할 수 있습니다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"edited_GPT O3, O4MINI.jpg\" data-origin-width=\"1000\" data-origin-height=\"668\"><span data-url=\"https://blog.kakaocdn.net/dn/86LNl/btsNn8iMy87/IKK7KcXRwKEGOZiMYkk4RK/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/86LNl/btsNn8iMy87/IKK7KcXRwKEGOZiMYkk4RK/img.png\"><img src=\"https://blog.kakaocdn.net/dn/86LNl/btsNn8iMy87/IKK7KcXRwKEGOZiMYkk4RK/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F86LNl%2FbtsNn8iMy87%2FIKK7KcXRwKEGOZiMYkk4RK%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"챗GPT o3, o4 mini\" loading=\"lazy\" width=\"1000\" height=\"668\" data-filename=\"edited_GPT O3, O4MINI.jpg\" data-origin-width=\"1000\" data-origin-height=\"668\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이러한 유연하고 전략적인 접근 방식을 통해 모델은 모델의 내장 지식을 넘어서는 최신 정보에 대한 접근, 확장된 추론, 합성, 여러 양식에 걸친 출력 생성이 필요한 작업을 처리할 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">특히 비즈니스 분야에서는 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘할 것으로 기대됩니다. 또한 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력은 과학 연구 분야에서도 큰 도움이 될 것입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>앞으로의 발전 방향  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI의 o 시리즈 모델들은 인공지능의 미래를 보여주는 중요한 이정표라고 생각해요. 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 추세를 따른다는 사실은, 앞으로도 더 많은 컴퓨팅 파워를 투입하면 성능이 계속 향상될 수 있다는 것을 시사합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">또한 도구 사용에 대한 강화학습의 성공은 향후 AI 모델들이 더 다양한 도구를 효과적으로 활용할 수 있게 될 것임을 암시합니다. 이는 AI가 더 자율적이고 에이전트적인 역할을 할 수 있게 되는 방향으로 발전한다는 의미겠죠.</p>\n<p data-ke-size=\"size16\">시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결 능력은 앞으로 더 발전해 다양한 분야에서 혁신적인 응용을 가능하게 할 것입니다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"1013\" data-origin-height=\"678\"><span data-url=\"https://blog.kakaocdn.net/dn/d0uCQM/btsNn923Xa9/m2efxCnY5nJuAHpUYT1o70/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/d0uCQM/btsNn923Xa9/m2efxCnY5nJuAHpUYT1o70/img.png\"><img src=\"https://blog.kakaocdn.net/dn/d0uCQM/btsNn923Xa9/m2efxCnY5nJuAHpUYT1o70/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd0uCQM%2FbtsNn923Xa9%2Fm2efxCnY5nJuAHpUYT1o70%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"챗GPT o3와 o4-mini 성능\" loading=\"lazy\" width=\"1013\" height=\"678\" data-origin-width=\"1013\" data-origin-height=\"678\"/></span></figure>\n</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>정리해보자면...  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI의 o3와 o4-mini는 그저 작은 업데이트가 아니라 AI 기술의 중요한 도약이라고 생각해요. 최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘한다는 사실은 이 모델들이 실용적인 면에서도 큰 가치가 있음을 보여줍니다.</p>\n<p data-ke-size=\"size16\">이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이러한 능력은 AI 보조자의 역할과 가능성을 크게 확장시킬 것입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">앞으로 AI 기술이 어떻게 발전할지, 그리고 우리의 삶과 일에 어떤 변화를 가져올지 정말 기대가 되네요. 여러분은 이런 새로운 AI 모델들에 대해 어떻게 생각하시나요? 댓글로 여러분의 생각을 공유해주세요!  </p>\n<hr data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\"><b>자주 묻는 질문 (FAQ)</b></span></h2>\n<p data-ke-size=\"size16\"><b>Q: o3와 o4-mini는 언제부터 사용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: o3와 o4-mini의 가장 큰 차이점은 무엇인가요?</b></p>\n<p data-ke-size=\"size16\">A: O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 이 모델들은 이전 GPT 모델들과 어떻게 다른가요?</b></p>\n<p data-ke-size=\"size16\">A: 더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 이 모델들은 어떤 도구들을 사용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 일반 사용자들에게는 어떤 혜택이 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.</p>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini는 언제부터 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini의 가장 큰 차이점은 무엇인가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 이전 GPT 모델들과 어떻게 다른가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 어떤 도구들을 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"일반 사용자들에게는 어떤 혜택이 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.\"\n    }\n  }]\n}\n</script>",
        "contentSnippet": "OpenAI의 새 모델 o3와 o4-mini가 뭐길래 이렇게 화제인걸까요? 더 오래 생각하고, 도구를 사용하며, 이미지까지 이해하는 이 모델들이 AI의 미래를 어떻게 바꿀지 함께 알아보세요!  \n\n\n \n요즘 인공지능 업계는 진짜 숨 돌릴 틈이 없는 것 같아요. 오늘은 OpenAI가 또 새로운 모델을 내놨네요. 솔직히 따라가기 벅찬 느낌이랄까요? 특히 이번에 공개된 OpenAI의 o3와 o4-mini는 정말 많은 관심을 받고 있더라고요. 근데 이게 진짜 대단한 혁신인지, 아니면 그냥 마케팅 전략인지 궁금해서 한번 자세히 들여다봤어요. 여러분도 이런 고민 한번쯤 해보셨죠?\n \no 시리즈가 뭘까? 그리고 이게 왜 중요할까?  \nOpenAI의 새로운 o3와 o4-mini는 생각하는 시간을 더 길게 가지고 응답할 수 있도록 학습된 O 시리즈의 최신 모델입니다. 이 모델들은 지금까지 OpenAI가 출시한 모델 중 가장 똑똑한 모델로, ChatGPT의 기능에 큰 변화를 가져올 것으로 예상됩니다.\n특히 주목할 점은 이 모델들이 챗GPT 내의 모든 도구를 에이전트처럼 사용하고 결합할 수 있다는 것입니다. 여기에는 웹 검색, 업로드된 파일 및 기타 데이터를 Python으로 분석하는 기능, 시각적 입력에 대한 심층 추론, 심지어 이미지 생성까지 포함됩니다. 이건 진짜 획기적인 변화 아닐까요?  \n \n이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이를 통해 다면적인 질문을 더 효과적으로 해결할 수 있게 되었고, 이는 사용자를 대신해 독립적으로 작업을 실행할 수 있는 더 에이전트형 ChatGPT를 향한 한 걸음이라고 볼 수 있습니다.\n \n최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.\n \no3와 o4-mini의 차이점은 무엇일까?  \n모델\n주요 특징\n최적 사용 케이스\n\n\n\n\nOpenAI o3\n가장 강력한 추론 모델, 코딩/수학/과학/시각적 인식에서 최고 성능, o1보다 20% 더 적은 오류율\n복잡한 다면적 분석, 이미지/차트/그래픽 분석, 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상\n\n\nOpenAI o4-mini\n빠르고 비용 효율적인 추론에 최적화, 크기와 비용 대비 뛰어난 성능, AIME 2024/2025 벤치마크 1위\n수학, 코딩, 시각적 작업, 데이터 과학, 고용량/고처리량 필요 작업\n\n\n\nOpenAI o3는 회사의 가장 강력한 추론 모델로, 코딩, 수학, 과학, 시각적 인식 등 여러 분야에서 최첨단 성능을 발휘합니다. Codeforces, SWE-bench (별도의 모델별 스캐폴드 없이), MMMU 등의 벤치마크에서 새로운 최고 성능을 기록했죠. 이 모델은 복잡한 다면적 분석이 필요하고 즉각적인 답이 명확하지 않은 복잡한 질의에 이상적입니다. 특히 이미지, 차트, 그래픽 분석과 같은 시각적 작업에서 강점을 보입니다.\n \n외부 전문가들의 평가에 따르면, o3는 어려운 실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘합니다. 초기 테스터들은 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력을 강조했습니다.\n \n반면에, OpenAI o4-mini는 빠르고 비용 효율적인 추론에 최적화된 더 작은 모델입니다. 크기와 비용 대비 놀라운 성능을 보이며, 특히 수학, 코딩, 시각적 작업에서 뛰어납니다. AIME 2024와 2025 벤치마크에서 가장 뛰어난 성능을 보이는 모델입니다. 전문가 평가에서도 데이터 과학과 같은 분야뿐만 아니라 비-STEM 작업에서도 이전 모델인 o3-mini보다 뛰어난 성능을 보였습니다.\n효율성 덕분에 o3보다 훨씬 더 높은 사용 제한을 지원하여, 추론이 필요한 질문에 대해 강력한 고용량, 고처리량 옵션이 됩니다.\n \n실제 성능은 어떨까?  \n벤치마크/작업\no1\no3-mini\no3\no4-mini\n\n\n\n\nAIME 2024 (경쟁 수학)\n74.3%\n87.3%\n91.6%\n93.4%\n\n\nCodeforces (경쟁 코딩)\n1891\n2073\n2706\n2719\n\n\nMMMU (대학 수준 시각적 문제 해결)\n77.6%\n-\n82.9%\n81.6%\n\n\n\n벤치마크 성능을 보면 정말 놀랍습니다. 외부 전문가 평가자들은 두 모델 모두 향상된 명령 준수와 이전 모델보다 더 유용하고 검증 가능한 응답을 보여준다고 평가했습니다. 이는 향상된 지능과 웹 소스의 통합 덕분입니다. 이전 추론 모델 반복과 비교할 때, 이 두 모델은 특히 기억과 과거 대화를 참조하여 응답을 더 개인화하고 관련성을 높이는 데 있어 더 자연스럽고 대화적이라고 합니다.\n \nOpenAI o3는 ChatGPT 내 전체 도구 접근권과 함께 API를 통한 사용자 지정 도구에도 접근할 수 있습니다. 이 모델들은 문제 해결 방법을 추론하고, 도구를 언제, 어떻게 사용할지 선택하여 일반적으로 1분 이내에 올바른 출력 형식으로 상세하고 사려 깊은 답변을 빠르게 생성하도록 학습되었습니다.\n \n예를 들어, 사용자가 \"캘리포니아의 여름 에너지 사용량이 작년과 비교하여 어떻게 될까요?\"라고 물을 수 있습니다. 이때 모델은 공공 유틸리티 데이터에 대한 웹 검색을 하고, 예측을 구축하기 위한 Python 코드를 작성하고, 그래프나 이미지를 생성한 다음, 예측 뒤에 있는 주요 요소를 설명할 수 있습니다. 이 과정에서 여러 도구 호출을 연결합니다.\n \n추론을 통해 모델은 접하는 정보에 따라 필요에 따라 반응하고 방향을 전환할 수 있습니다. 예를 들어, 검색 제공업체의 도움을 받아 웹을 여러 번 검색하고, 결과를 살펴보고, 더 많은 정보가 필요한 경우 새로운 검색을 시도할 수 있습니다.\n \n예를 통해 본 성능 차이  \nOpenAI는 이 모델들의 뛰어난 성능을 보여주는 몇 가지 예시를 제공했습니다. o3와 o1의 성능을 비교하면 그 차이가 확연히 드러납니다.\n \n예를 들어, 복잡한 수학 문제에서 o3는 디크슨 다항식(Dickson polynomial)을 사용해 문제를 정확히 풀어내는 반면, o1은 시간이 더 걸리고 부정확한 해결책을 제시합니다.\n \n또한 호텔 체인 확장에 관한 질문에서도 o3는 실제 데이터를 활용한 철저한 분석을 통해 아테네와 오사카를 목표 도시로 추천했습니다. 각 도시의 점유율, RevPAR 성장률, 승객 증가율 등 구체적인 지표와 2024년 통계자료를 바탕으로 상세한 비교 테이블까지 제공했죠.\n \n배터리 기술 발전에 관한 질문에서도 o3는 리튬 이온 배터리, 솔리드 스테이트 배터리, 나트륨 이온 배터리 등 최신 기술의 영향을 상세히 분석하며, 2011년부터 2024년까지의 전기차 주행거리, 충전 속도, 보급률 등의 변화를 그래프로 시각화해 보여주었습니다.\nMLB 피치 클럭 규칙이 투수 성능과 게임 시간에 미친 영향에 관한 질문에서도 o3는 구체적인 통계 데이터를 활용해 2021년부터 2024년까지의 변화를 상세히 분석했습니다. 규칙 도입 이후 게임 시간이 24분 단축됐고, 초기에는 투수들의 ERA가 상승했지만 적응 기간을 거쳐 다시 안정되었다는 흥미로운 분석을 제공했죠.\n \n이런 예시들을 보면 o3와 o4-mini의 성능이 정말 인상적이라는 걸 알 수 있어요.\n \n핵심 기술적 특징  \n기술적 혁신\n특징\n영향\n\n\n\n\n강화학습 확장\n\"더 많은 컴퓨팅 = 더 나은 성능\" 트렌드 확인\n더 오래 생각할수록 성능이 지속적으로 향상\n\n\n에이전트형 도구 사용\n도구를 언제, 어떻게 사용할지 추론하는 능력\n시각적 추론, 다단계 워크플로우 처리 능력 향상\n\n\n이미지 통합 사고\n이미지를 사고 과정에 직접 통합\n시각적, 텍스트 추론을 혼합한 새로운 문제 해결 가능\n\n\n\nOpenAI의 o3 개발 과정에서, 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 GPT 시리즈 사전 학습에서 관찰된 것과 동일한 추세를 보여주는 것으로 확인됐습니다. OpenAI는 현재 강화학습에서 이 확장 경로를 다시 따라가며, 학습 컴퓨팅과 추론 시간을 추가로 10배 증가시켰음에도 여전히 성능 향상이 명확하게 보이는 것을 확인했습니다. 이는 모델이 더 오래 생각할수록 성능이 계속 향상된다는 것을 검증합니다.\n \no3와 o4-mini는 강화학습을 통해 도구를 사용하도록 학습되었습니다. 이는 단순히 도구 사용법을 학습하는 것이 아니라, 언제 도구를 사용할지에 대해 추론하는 능력을 키웠다는 의미입니다. 원하는 결과에 따라 도구를 배치하는 능력은 특히 시각적 추론과 다단계 워크플로우를 포함하는 개방형 상황에서 더 유능하게 만듭니다.\n \n이러한 개선은 학술 벤치마크와 실제 작업 모두에서 반영되어, 초기 테스터들의 보고에서도 확인됩니다.\n또한 이 모델들은 처음으로 이미지를 직접 사고 과정에 통합할 수 있습니다. 단순히 이미지를 보는 것이 아니라, 그것을 가지고 생각합니다. 이는 시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결을 가능하게 하며, 이는 다양한 다중모달 벤치마크에서의 최첨단 성능으로 반영됩니다.\n \n실생활에서의 응용 가능성  ️\n이 새로운 모델들의 활용 가능성은 정말 광범위해요. 일상적인 작업부터 복잡한 비즈니스 문제, 교육, 연구까지 다양한 분야에서 활용될 수 있습니다. 예를 들어, 공공 유틸리티 데이터를 검색하고, 예측 모델을 구축하며, 결과를 시각화하는 복잡한 작업을 한 번에 처리할 수 있습니다.\n\n\n \n이러한 유연하고 전략적인 접근 방식을 통해 모델은 모델의 내장 지식을 넘어서는 최신 정보에 대한 접근, 확장된 추론, 합성, 여러 양식에 걸친 출력 생성이 필요한 작업을 처리할 수 있습니다.\n \n특히 비즈니스 분야에서는 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘할 것으로 기대됩니다. 또한 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력은 과학 연구 분야에서도 큰 도움이 될 것입니다.\n \n앞으로의 발전 방향  \nOpenAI의 o 시리즈 모델들은 인공지능의 미래를 보여주는 중요한 이정표라고 생각해요. 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 추세를 따른다는 사실은, 앞으로도 더 많은 컴퓨팅 파워를 투입하면 성능이 계속 향상될 수 있다는 것을 시사합니다.\n \n또한 도구 사용에 대한 강화학습의 성공은 향후 AI 모델들이 더 다양한 도구를 효과적으로 활용할 수 있게 될 것임을 암시합니다. 이는 AI가 더 자율적이고 에이전트적인 역할을 할 수 있게 되는 방향으로 발전한다는 의미겠죠.\n시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결 능력은 앞으로 더 발전해 다양한 분야에서 혁신적인 응용을 가능하게 할 것입니다.\n\n\n정리해보자면...  \nOpenAI의 o3와 o4-mini는 그저 작은 업데이트가 아니라 AI 기술의 중요한 도약이라고 생각해요. 최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.\n \n실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘한다는 사실은 이 모델들이 실용적인 면에서도 큰 가치가 있음을 보여줍니다.\n이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이러한 능력은 AI 보조자의 역할과 가능성을 크게 확장시킬 것입니다.\n \n앞으로 AI 기술이 어떻게 발전할지, 그리고 우리의 삶과 일에 어떤 변화를 가져올지 정말 기대가 되네요. 여러분은 이런 새로운 AI 모델들에 대해 어떻게 생각하시나요? 댓글로 여러분의 생각을 공유해주세요!  \n자주 묻는 질문 (FAQ)\nQ: o3와 o4-mini는 언제부터 사용할 수 있나요?\nA: 이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.\nQ: o3와 o4-mini의 가장 큰 차이점은 무엇인가요?\nA: O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.\nQ: 이 모델들은 이전 GPT 모델들과 어떻게 다른가요?\nA: 더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.\nQ: 이 모델들은 어떤 도구들을 사용할 수 있나요?\nA: 웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.\nQ: 일반 사용자들에게는 어떤 혜택이 있나요?\nA: 더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.\n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini는 언제부터 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini의 가장 큰 차이점은 무엇인가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 이전 GPT 모델들과 어떻게 다른가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 어떤 도구들을 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"일반 사용자들에게는 어떤 혜택이 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.\"\n    }\n  }]\n}",
        "guid": "http://muzbox.tistory.com/483570",
        "categories": [
          "AI, 미래기술/AI 챗봇 및 언어 모델",
          "AI 모델",
          "o4-mini",
          "openai o3",
          "강화학습",
          "도구 사용",
          "문제 해결",
          "벤치마크 성능",
          "시각적 추론",
          "에이전트 ai",
          "추론 능력"
        ],
        "isoDate": "2025-04-16T23:39:33.000Z"
      },
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "GPT-4.1, mini, nano 총정리: 성능, 가격, 활용법까지 한번에",
        "link": "http://muzbox.tistory.com/483569",
        "pubDate": "Wed, 16 Apr 2025 10:06:48 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483569#entry483569comment",
        "content": "<p data-ke-size=\"size16\">GPT-4.1 시리즈의 혁신적 기능과 성능 향상을 소개합니다. 코딩, 긴 컨텍스트 처리, 지시 이행 능력이 크게 개선되었고, 최초의 나노 모델까지 출시된 GPT-4.1의 모든 것을 파헤쳐볼게요!</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"edited_GPT-4.1 패밀리 총정리.jpg\" data-origin-width=\"1920\" data-origin-height=\"1080\"><span data-url=\"https://blog.kakaocdn.net/dn/bso32X/btsNmvyyFST/RQI7KTppDTErnKLy2rDZuk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/bso32X/btsNmvyyFST/RQI7KTppDTErnKLy2rDZuk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/bso32X/btsNmvyyFST/RQI7KTppDTErnKLy2rDZuk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbso32X%2FbtsNmvyyFST%2FRQI7KTppDTErnKLy2rDZuk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"GPT-4.1, mini, nano 총정리: 성능, 가격, 활용법까지 한번에\" loading=\"lazy\" width=\"1920\" height=\"1080\" data-filename=\"edited_GPT-4.1 패밀리 총정리.jpg\" data-origin-width=\"1920\" data-origin-height=\"1080\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">어제 정말 신기한 뉴스를 봤어요. OpenAI가 또 새로운 모델을 출시했더라고요. 요새 AI 기술이 진짜 미친 속도로 발전하는데, 그냥 따라가기도 버거울 지경이에요. 근데 이번에 나온 GPT-4.1 시리즈는 뭔가 특별해 보이더라고요. 코딩 능력이 확 좋아졌다는데, 개발자분들은 어떻게 생각하세요? 저같은 일반인한테도 도움될까요?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>GPT-4.1 시리즈, 무엇이 달라졌을까?  </b></span></h2>\n<p data-ke-size=\"size16\">OpenAI가 API를 통해 제공하는 세 가지 새로운 모델을 소개했어요. GPT-4.1, GPT-4.1 mini, 그리고 GPT-4.1 nano까지. 이 모델들은 기존의 GPT-4o와 GPT-4o mini보다 전반적으로 더 뛰어난 성능을 보여준다고 해요. 특히 코딩과 지시사항 이행 능력에서 엄청난 발전이 있었다고 하네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">가장 눈에 띄는 변화는 <b>컨텍스트 윈도우</b>의 크기예요. 무려 100만 토큰까지 처리할 수 있게 되었다고 해요! 이전 모델들이 128,000 토큰까지 처리할 수 있었던 것과 비교하면 정말 큰 발전이죠. 그리고 단순히 더 많은 컨텍스트를 처리하는 것뿐만 아니라, 그 컨텍스트를 더 효율적으로 이해하고 활용할 수 있게 되었다고 해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">또한 지식 기반도 업데이트되어 2024년 6월까지의 정보를 담고 있어요. 이제 좀 더 최신 정보에 대해서도 물어볼 수 있겠네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>코딩 능력이 대폭 향상됐어요  </b></span></h2>\n<p data-ke-size=\"size16\">제가 개인적으로 가장 흥미로웠던 부분은 코딩 능력의 향상이에요. GPT-4.1은 SWE-bench Verified에서 54.6%의 점수를 받았다고 해요. 이는 GPT-4o의 33.2%보다 무려 21.4% 포인트나 높은 점수예요!</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #4285f4; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">모델</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">SWE-bench Verified 점수</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">향상된 정도</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">54.6%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">기준</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4o</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">33.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">-21.4%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.5</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">38.0%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">-16.6%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">실제 사용자들의 반응도 놀라웠어요. Windsurf라는 회사에서는 GPT-4.1이 내부 코딩 벤치마크에서 GPT-4o보다 60% 높은 점수를 받았다고 해요. 특히 도구 호출에서 30% 더 효율적이었고, 불필요한 편집을 반복할 가능성이 약 50% 낮았다고 하네요.</p>\n<p data-ke-size=\"size16\">이거 진짜 대단한 발전 아닌가요? 개발자들이 코드를 작성하고, 디버깅하는 데 훨씬 더 도움이 될 것 같아요. 제가 개발자는 아니지만, 이런 발전이 미래의 소프트웨어 개발에 어떤 영향을 미칠지 정말 궁금해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>지시 이행 능력도 확실히 좋아졌어요  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4.1은 지시 이행 능력도 크게 향상되었어요. 특히 Format following, Negative instructions, Ordered instructions, Content requirements, Ranking, Overconfidence 등 여러 범주에서 성능이 향상되었다고 해요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #34a853; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">벤치마크</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4.1</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4o</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">향상도</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">MultiChallenge</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">38.3%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">27.8%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">+10.5%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">IFEval</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">87.4%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">81.0%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">+6.4%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">내부 API 지시 이행 (어려운 유형)</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">49.1%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">29.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">+19.9%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">실제로 세금 관련 회사인 Blue J에서는 GPT-4.1이 내부 벤치마크에서 GPT-4o보다 53% 더 정확했다고 해요. Hex라는 회사에서는 SQL 평가 세트에서 거의 2배 향상된 성능을 보였다고 하네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">이런 개선은 복잡한 지시사항을 더 잘 따를 수 있게 해준다는 뜻이니까, 실무에서 활용도가 훨씬 높아질 것 같아요. 솔직히 말해서, 이전 모델들도 간단한 지시는 잘 따랐지만 복잡한 지시나 여러 단계의 지시는 종종 헷갈려 했잖아요? 이제 그런 문제가 많이 해결될 것 같네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>100만 토큰의 긴 컨텍스트, 어떻게 활용할까?  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4.1 시리즈의 가장 큰 변화 중 하나는 100만 토큰의 컨텍스트 윈도우예요. 이건 React 코드베이스 전체를 8개 넣을 수 있는 양이라고 하네요. 진짜 엄청난 양이죠?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">OpenAI는 GPT-4.1이 이 긴 컨텍스트에서 정보를 효과적으로 찾고 활용할 수 있도록 특별히 훈련시켰다고 해요. 'Needle in a Haystack' 테스트에서 GPT-4.1은 100만 토큰 안에 숨겨진 정보를 정확하게 찾아낼 수 있었다고 해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">또 흥미로운 점은 OpenAI가 새로운 평가 방식인 OpenAI-MRCR과 Graphwalks를 공개했다는 거예요. 이 평가들은 모델이 긴 컨텍스트에서 여러 정보를 어떻게 찾고 연결하는지 테스트하는 방식이라고 해요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #ea4335; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">모델</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">컨텍스트 윈도우</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">OpenAI-MRCR (2 바늘) 128k</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">Graphwalks bfs &lt;128k</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">100만 토큰</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">57.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">61.7%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 mini</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">100만 토큰</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">47.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">61.7%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 nano</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">100만 토큰</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">36.6%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">25.0%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4o</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">128k 토큰</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">31.9%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">41.7%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">실제 사용 사례도 인상적이었어요. Thomson Reuters는 GPT-4.1을 사용해 다중 문서 검토 정확도를 17% 향상시켰고, Carlyle은 매우 큰 문서에서 세부적인 재무 데이터를 추출하는 성능이 50% 향상되었다고 해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">솔직히 말해서, 이런 긴 컨텍스트 기능은 법률, 금융, 의료 등 복잡한 문서를 다루는 분야에서 정말 혁신적인 변화를 가져올 것 같아요. 생각해보세요, 수백 페이지의 계약서나 의료 기록을 한 번에 분석할 수 있다면 얼마나 편리할까요?</p>\n<blockquote data-ke-style=\"style3\"><b> 컨텍스트</b>는 AI 모델이 대화나 질문을 이해하기 위해 고려하는 배경 정보나 이전 대화 내용을 의미해요. 쉽게 설명하자면, 사람과 대화할 때 이전에 나눈 모든 대화를 기억하고 참고하는 것과 비슷해요.</blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>비전(Vision) 능력도 강화됐어요  ️</b></span></h2>\n<p data-ke-size=\"size16\">GPT-4.1 시리즈는 이미지 이해 능력도 크게 향상되었어요. 특히 GPT-4.1 mini는 이미지 벤치마크에서 종종 GPT-4o보다 더 좋은 성능을 보여줬다고 해요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #fbbc05; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">벤치마크</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4.1</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4.1 mini</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">GPT-4o</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">MMMU</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">74.8%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">72.7%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">68.7%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">MathVista</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">72.2%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">73.1%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">61.4%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">CharXiv-R</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">56.7%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">56.8%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">52.7%</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">Video-MME (자막 없음)</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">72.0%</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">-</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">65.3%</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">MMMU에서 GPT-4.1은 74.8%, GPT-4.1 mini는 72.7%의 점수를 받았어요. 이는 GPT-4o의 68.7%보다 훨씬 높은 점수죠. MathVista에서도 GPT-4.1은 72.2%, GPT-4.1 mini는 73.1%로 GPT-4o의 61.4%를 크게 앞섰어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">Video-MME 테스트에서는 GPT-4.1이 72.0%의 점수를 얻어 GPT-4o의 65.3%보다 훨씬 좋은 성적을 거뒀어요. 이 테스트는 30-60분 길이의 자막 없는 비디오를 기반으로 질문에 답하는 테스트인데, 정말 인상적인 성능이죠?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">아직 사진이나 비디오를 많이 활용하진 않지만, 앞으로는 이런 비전 능력을 활용한 애플리케이션이 더 많아질 것 같아요. 제 생각엔 교육이나 의료 분야에서 특히 유용할 것 같네요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>가격은 어떻게 변했을까?  </b></span></h2>\n<p data-ke-size=\"size16\">가격도 상당히 흥미로웠어요. OpenAI는 추론 시스템의 효율성 향상으로 GPT-4.1 시리즈의 가격을 낮출 수 있었다고 해요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #673ab7; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">모델</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">입력 (100만 토큰)</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">캐시된 입력 (100만 토큰)</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">출력 (100만 토큰)</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">혼합 가격*</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$2.00</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.50</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$8.00</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$1.84</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 mini</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.40</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.10</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$1.60</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.42</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 nano</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.10</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.025</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.40</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">$0.12</td>\n</tr>\n</tbody>\n</table>\n<p style=\"font-size: 0.9em; font-style: italic;\" data-ke-size=\"size16\">*일반적인 입력/출력 및 캐시 비율 기준</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">GPT-4.1은 중간 규모 쿼리의 경우 GPT-4o보다 26% 저렴하고, GPT-4.1 nano는 가장 저렴하고 빠른 모델이라고 해요.</p>\n<p data-ke-size=\"size16\">또 하나 좋은 점은 캐시된 입력에 대한 할인이 이전의 50%에서 75%로 증가했다는 거예요. 같은 컨텍스트를 반복해서 전달하는 경우에 더 많은 비용을 절약할 수 있게 된 거죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">확실히 더 저렴해진 가격은 중소기업이나 개인 개발자들에게 큰 도움이 될 것 같아요. 특히 GPT-4.1 nano는 정말 매력적인 가격대라고 생각해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>내가 받은 느낌은?  </b></span></h2>\n<p data-ke-size=\"size16\">이번 GPT-4.1 시리즈 발표를 보면서 정말 많은 생각이 들었어요. AI 기술이 이렇게 빠르게 발전하는 걸 보니 약간 두렵기도 하지만, 동시에 정말 기대되기도 해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">특히 코딩 능력의 향상은 소프트웨어 개발 방식을 완전히 바꿀 수 있을 것 같아요. 개발자들이 복잡한 코드를 더 쉽게 작성하고 수정할 수 있게 되면, 더 빠르게 혁신적인 제품들이 나올 수 있겠죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">긴 컨텍스트 기능도 정말 흥미로워요. 법률 문서, 의학 연구, 학술 논문 등 긴 문서를 분석하는 데 엄청난 도움이 될 것 같아요. 이전에는 불가능했던 방식으로 정보를 처리하고 통찰력을 얻을 수 있게 될 거예요.</p>\n<p data-ke-size=\"size16\">지시 이행 능력의 향상은 AI가 더 신뢰할 수 있는 도구가 되었다는 걸 의미해요. 사용자가 원하는 정확한 결과를 더 쉽게 얻을 수 있게 되었으니까요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">하지만 여전히 몇 가지 질문도 남아있어요. 이런 강력한 AI 도구들이 사회에 어떤 영향을 미칠까요? 직업 시장은 어떻게 변할까요? 우리는 어떻게 이 기술을 책임감 있게 사용할 수 있을까요?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>GPT-4.1 시리즈, 누구를 위한 모델일까?  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4.1 시리즈는 다양한 사용자와 사용 사례를 위해 설계되었어요.</p>\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\" data-ke-align=\"alignLeft\">\n<thead>\n<tr style=\"background-color: #009688; color: white;\">\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: left;\">모델</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">주요 사용자층</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">주요 특징</th>\n<th style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">비용 효율성</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">최고 성능을 원하는 사용자</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">코딩 능력, 정확한 지시 이행, 긴 문서 분석</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">중간</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 mini</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">균형 잡힌 성능과 비용을 원하는 사용자</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4o보다 더 좋은 성능, 지연 시간 절반</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">높음</td>\n</tr>\n<tr>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">GPT-4.1 nano</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">짧은 대기 시간이 중요한 작업</td>\n<td style=\"padding: 10px; border: 1px solid #ddd;\">분류, 자동 완성, 100만 토큰 컨텍스트</td>\n<td style=\"padding: 10px; border: 1px solid #ddd; text-align: center;\">매우 높음</td>\n</tr>\n</tbody>\n</table>\n<p data-ke-size=\"size16\">GPT-4.1은 최고의 성능을 원하는 사용자를 위한 모델이에요. 복잡한 코딩 작업, 정확한 지시 이행이 필요한 작업, 긴 문서 분석 등에 적합해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">GPT-4.1 mini는 균형 잡힌 성능과 비용을 원하는 사용자에게 적합해요. GPT-4o보다 여러 벤치마크에서 더 좋은 성능을 보이면서도 지연 시간은 절반으로 줄고 비용은 83% 감소했다고 하니 정말 매력적이죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">GPT-4.1 nano는 짧은 대기 시간이 중요한 작업에 적합해요. 분류나 자동 완성과 같은 작업에 이상적이라고 해요. 100만 토큰의 컨텍스트 윈도우를 가지고 있으면서도 MMLU에서 80.1%, GPQA에서 50.3%의 높은 점수를 받았대요.</p>\n<p data-ke-size=\"size16\">저는 개인적으로 GPT-4.1 mini가 가성비 면에서 가장 좋은 선택일 것 같다는 생각이 들어요. 대부분의 일반적인 작업에 충분한 성능을 제공하면서도 비용은 상당히 저렴하니까요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"1263\" data-origin-height=\"794\"><span data-url=\"https://blog.kakaocdn.net/dn/k8Dbg/btsNnx9IUT0/EblLfRQjlhiSN4qaUeA101/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/k8Dbg/btsNnx9IUT0/EblLfRQjlhiSN4qaUeA101/img.png\"><img src=\"https://blog.kakaocdn.net/dn/k8Dbg/btsNnx9IUT0/EblLfRQjlhiSN4qaUeA101/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fk8Dbg%2FbtsNnx9IUT0%2FEblLfRQjlhiSN4qaUeA101%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"GPT-4.1 시리즈, 무엇이 달라졌을까?\" loading=\"lazy\" width=\"1263\" height=\"794\" data-origin-width=\"1263\" data-origin-height=\"794\"/></span></figure>\n</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\"><b>자주 묻는 질문 (FAQ) ❓</b></span></h2>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.1은 ChatGPT에서도 사용할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?</b></p>\n<p data-ke-size=\"size16\">A: GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.1 시리즈의 가격은 어떻게 되나요?</b></p>\n<p data-ke-size=\"size16\">A: GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.5 Preview는 어떻게 되나요?</b></p>\n<p data-ke-size=\"size16\">A: GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 2024년 6월까지의 정보를 담고 있습니다.</p>\n<div style=\"margin: 0px auto; border: 2px dashed #ff5722; position: absolute; z-index: 2147483647; visibility: hidden; background-color: rgba(255, 87, 34, 0.1); left: 738px; width: 0px; top: 2092px; height: 0px;\">&nbsp;</div>\n<div style=\"z-index: 2147483647; position: absolute; visibility: hidden; padding: 5px 10px; font-size: 14px; font-family: Arial, sans-serif; color: #ffffff; background-color: #00633e; border-radius: 15px; box-shadow: rgba(0, 0, 0, 0.2) 0px 2px 5px; font-weight: bold; left: 753px; top: 2052px;\">&nbsp;</div>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1은 ChatGPT에서도 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 가격은 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.5 Preview는 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"2024년 6월까지의 정보를 담고 있습니다.\"\n    }\n  }]\n}\n</script>",
        "contentSnippet": "GPT-4.1 시리즈의 혁신적 기능과 성능 향상을 소개합니다. 코딩, 긴 컨텍스트 처리, 지시 이행 능력이 크게 개선되었고, 최초의 나노 모델까지 출시된 GPT-4.1의 모든 것을 파헤쳐볼게요!\n\n\n \n어제 정말 신기한 뉴스를 봤어요. OpenAI가 또 새로운 모델을 출시했더라고요. 요새 AI 기술이 진짜 미친 속도로 발전하는데, 그냥 따라가기도 버거울 지경이에요. 근데 이번에 나온 GPT-4.1 시리즈는 뭔가 특별해 보이더라고요. 코딩 능력이 확 좋아졌다는데, 개발자분들은 어떻게 생각하세요? 저같은 일반인한테도 도움될까요?\n \nGPT-4.1 시리즈, 무엇이 달라졌을까?  \nOpenAI가 API를 통해 제공하는 세 가지 새로운 모델을 소개했어요. GPT-4.1, GPT-4.1 mini, 그리고 GPT-4.1 nano까지. 이 모델들은 기존의 GPT-4o와 GPT-4o mini보다 전반적으로 더 뛰어난 성능을 보여준다고 해요. 특히 코딩과 지시사항 이행 능력에서 엄청난 발전이 있었다고 하네요.\n \n가장 눈에 띄는 변화는 컨텍스트 윈도우의 크기예요. 무려 100만 토큰까지 처리할 수 있게 되었다고 해요! 이전 모델들이 128,000 토큰까지 처리할 수 있었던 것과 비교하면 정말 큰 발전이죠. 그리고 단순히 더 많은 컨텍스트를 처리하는 것뿐만 아니라, 그 컨텍스트를 더 효율적으로 이해하고 활용할 수 있게 되었다고 해요.\n \n또한 지식 기반도 업데이트되어 2024년 6월까지의 정보를 담고 있어요. 이제 좀 더 최신 정보에 대해서도 물어볼 수 있겠네요.\n \n코딩 능력이 대폭 향상됐어요  \n제가 개인적으로 가장 흥미로웠던 부분은 코딩 능력의 향상이에요. GPT-4.1은 SWE-bench Verified에서 54.6%의 점수를 받았다고 해요. 이는 GPT-4o의 33.2%보다 무려 21.4% 포인트나 높은 점수예요!\n모델\nSWE-bench Verified 점수\n향상된 정도\n\n\n\n\nGPT-4.1\n54.6%\n기준\n\n\nGPT-4o\n33.2%\n-21.4%\n\n\nGPT-4.5\n38.0%\n-16.6%\n\n\n\n실제 사용자들의 반응도 놀라웠어요. Windsurf라는 회사에서는 GPT-4.1이 내부 코딩 벤치마크에서 GPT-4o보다 60% 높은 점수를 받았다고 해요. 특히 도구 호출에서 30% 더 효율적이었고, 불필요한 편집을 반복할 가능성이 약 50% 낮았다고 하네요.\n이거 진짜 대단한 발전 아닌가요? 개발자들이 코드를 작성하고, 디버깅하는 데 훨씬 더 도움이 될 것 같아요. 제가 개발자는 아니지만, 이런 발전이 미래의 소프트웨어 개발에 어떤 영향을 미칠지 정말 궁금해요.\n \n지시 이행 능력도 확실히 좋아졌어요  \nGPT-4.1은 지시 이행 능력도 크게 향상되었어요. 특히 Format following, Negative instructions, Ordered instructions, Content requirements, Ranking, Overconfidence 등 여러 범주에서 성능이 향상되었다고 해요.\n벤치마크\nGPT-4.1\nGPT-4o\n향상도\n\n\n\n\nMultiChallenge\n38.3%\n27.8%\n+10.5%\n\n\nIFEval\n87.4%\n81.0%\n+6.4%\n\n\n내부 API 지시 이행 (어려운 유형)\n49.1%\n29.2%\n+19.9%\n\n\n\n실제로 세금 관련 회사인 Blue J에서는 GPT-4.1이 내부 벤치마크에서 GPT-4o보다 53% 더 정확했다고 해요. Hex라는 회사에서는 SQL 평가 세트에서 거의 2배 향상된 성능을 보였다고 하네요.\n \n이런 개선은 복잡한 지시사항을 더 잘 따를 수 있게 해준다는 뜻이니까, 실무에서 활용도가 훨씬 높아질 것 같아요. 솔직히 말해서, 이전 모델들도 간단한 지시는 잘 따랐지만 복잡한 지시나 여러 단계의 지시는 종종 헷갈려 했잖아요? 이제 그런 문제가 많이 해결될 것 같네요.\n \n100만 토큰의 긴 컨텍스트, 어떻게 활용할까?  \nGPT-4.1 시리즈의 가장 큰 변화 중 하나는 100만 토큰의 컨텍스트 윈도우예요. 이건 React 코드베이스 전체를 8개 넣을 수 있는 양이라고 하네요. 진짜 엄청난 양이죠?\n \nOpenAI는 GPT-4.1이 이 긴 컨텍스트에서 정보를 효과적으로 찾고 활용할 수 있도록 특별히 훈련시켰다고 해요. 'Needle in a Haystack' 테스트에서 GPT-4.1은 100만 토큰 안에 숨겨진 정보를 정확하게 찾아낼 수 있었다고 해요.\n \n또 흥미로운 점은 OpenAI가 새로운 평가 방식인 OpenAI-MRCR과 Graphwalks를 공개했다는 거예요. 이 평가들은 모델이 긴 컨텍스트에서 여러 정보를 어떻게 찾고 연결하는지 테스트하는 방식이라고 해요.\n모델\n컨텍스트 윈도우\nOpenAI-MRCR (2 바늘) 128k\nGraphwalks bfs <128k\n\n\n\n\nGPT-4.1\n100만 토큰\n57.2%\n61.7%\n\n\nGPT-4.1 mini\n100만 토큰\n47.2%\n61.7%\n\n\nGPT-4.1 nano\n100만 토큰\n36.6%\n25.0%\n\n\nGPT-4o\n128k 토큰\n31.9%\n41.7%\n\n\n\n실제 사용 사례도 인상적이었어요. Thomson Reuters는 GPT-4.1을 사용해 다중 문서 검토 정확도를 17% 향상시켰고, Carlyle은 매우 큰 문서에서 세부적인 재무 데이터를 추출하는 성능이 50% 향상되었다고 해요.\n \n솔직히 말해서, 이런 긴 컨텍스트 기능은 법률, 금융, 의료 등 복잡한 문서를 다루는 분야에서 정말 혁신적인 변화를 가져올 것 같아요. 생각해보세요, 수백 페이지의 계약서나 의료 기록을 한 번에 분석할 수 있다면 얼마나 편리할까요?\n 컨텍스트는 AI 모델이 대화나 질문을 이해하기 위해 고려하는 배경 정보나 이전 대화 내용을 의미해요. 쉽게 설명하자면, 사람과 대화할 때 이전에 나눈 모든 대화를 기억하고 참고하는 것과 비슷해요.\n \n비전(Vision) 능력도 강화됐어요  ️\nGPT-4.1 시리즈는 이미지 이해 능력도 크게 향상되었어요. 특히 GPT-4.1 mini는 이미지 벤치마크에서 종종 GPT-4o보다 더 좋은 성능을 보여줬다고 해요.\n벤치마크\nGPT-4.1\nGPT-4.1 mini\nGPT-4o\n\n\n\n\nMMMU\n74.8%\n72.7%\n68.7%\n\n\nMathVista\n72.2%\n73.1%\n61.4%\n\n\nCharXiv-R\n56.7%\n56.8%\n52.7%\n\n\nVideo-MME (자막 없음)\n72.0%\n-\n65.3%\n\n\n\nMMMU에서 GPT-4.1은 74.8%, GPT-4.1 mini는 72.7%의 점수를 받았어요. 이는 GPT-4o의 68.7%보다 훨씬 높은 점수죠. MathVista에서도 GPT-4.1은 72.2%, GPT-4.1 mini는 73.1%로 GPT-4o의 61.4%를 크게 앞섰어요.\n \nVideo-MME 테스트에서는 GPT-4.1이 72.0%의 점수를 얻어 GPT-4o의 65.3%보다 훨씬 좋은 성적을 거뒀어요. 이 테스트는 30-60분 길이의 자막 없는 비디오를 기반으로 질문에 답하는 테스트인데, 정말 인상적인 성능이죠?\n \n아직 사진이나 비디오를 많이 활용하진 않지만, 앞으로는 이런 비전 능력을 활용한 애플리케이션이 더 많아질 것 같아요. 제 생각엔 교육이나 의료 분야에서 특히 유용할 것 같네요.\n \n가격은 어떻게 변했을까?  \n가격도 상당히 흥미로웠어요. OpenAI는 추론 시스템의 효율성 향상으로 GPT-4.1 시리즈의 가격을 낮출 수 있었다고 해요.\n모델\n입력 (100만 토큰)\n캐시된 입력 (100만 토큰)\n출력 (100만 토큰)\n혼합 가격*\n\n\n\n\nGPT-4.1\n$2.00\n$0.50\n$8.00\n$1.84\n\n\nGPT-4.1 mini\n$0.40\n$0.10\n$1.60\n$0.42\n\n\nGPT-4.1 nano\n$0.10\n$0.025\n$0.40\n$0.12\n\n\n\n*일반적인 입력/출력 및 캐시 비율 기준\n \nGPT-4.1은 중간 규모 쿼리의 경우 GPT-4o보다 26% 저렴하고, GPT-4.1 nano는 가장 저렴하고 빠른 모델이라고 해요.\n또 하나 좋은 점은 캐시된 입력에 대한 할인이 이전의 50%에서 75%로 증가했다는 거예요. 같은 컨텍스트를 반복해서 전달하는 경우에 더 많은 비용을 절약할 수 있게 된 거죠.\n \n확실히 더 저렴해진 가격은 중소기업이나 개인 개발자들에게 큰 도움이 될 것 같아요. 특히 GPT-4.1 nano는 정말 매력적인 가격대라고 생각해요.\n \n내가 받은 느낌은?  \n이번 GPT-4.1 시리즈 발표를 보면서 정말 많은 생각이 들었어요. AI 기술이 이렇게 빠르게 발전하는 걸 보니 약간 두렵기도 하지만, 동시에 정말 기대되기도 해요.\n \n특히 코딩 능력의 향상은 소프트웨어 개발 방식을 완전히 바꿀 수 있을 것 같아요. 개발자들이 복잡한 코드를 더 쉽게 작성하고 수정할 수 있게 되면, 더 빠르게 혁신적인 제품들이 나올 수 있겠죠.\n \n긴 컨텍스트 기능도 정말 흥미로워요. 법률 문서, 의학 연구, 학술 논문 등 긴 문서를 분석하는 데 엄청난 도움이 될 것 같아요. 이전에는 불가능했던 방식으로 정보를 처리하고 통찰력을 얻을 수 있게 될 거예요.\n지시 이행 능력의 향상은 AI가 더 신뢰할 수 있는 도구가 되었다는 걸 의미해요. 사용자가 원하는 정확한 결과를 더 쉽게 얻을 수 있게 되었으니까요.\n \n하지만 여전히 몇 가지 질문도 남아있어요. 이런 강력한 AI 도구들이 사회에 어떤 영향을 미칠까요? 직업 시장은 어떻게 변할까요? 우리는 어떻게 이 기술을 책임감 있게 사용할 수 있을까요?\n \nGPT-4.1 시리즈, 누구를 위한 모델일까?  \nGPT-4.1 시리즈는 다양한 사용자와 사용 사례를 위해 설계되었어요.\n모델\n주요 사용자층\n주요 특징\n비용 효율성\n\n\n\n\nGPT-4.1\n최고 성능을 원하는 사용자\n코딩 능력, 정확한 지시 이행, 긴 문서 분석\n중간\n\n\nGPT-4.1 mini\n균형 잡힌 성능과 비용을 원하는 사용자\nGPT-4o보다 더 좋은 성능, 지연 시간 절반\n높음\n\n\nGPT-4.1 nano\n짧은 대기 시간이 중요한 작업\n분류, 자동 완성, 100만 토큰 컨텍스트\n매우 높음\n\n\n\nGPT-4.1은 최고의 성능을 원하는 사용자를 위한 모델이에요. 복잡한 코딩 작업, 정확한 지시 이행이 필요한 작업, 긴 문서 분석 등에 적합해요.\n \nGPT-4.1 mini는 균형 잡힌 성능과 비용을 원하는 사용자에게 적합해요. GPT-4o보다 여러 벤치마크에서 더 좋은 성능을 보이면서도 지연 시간은 절반으로 줄고 비용은 83% 감소했다고 하니 정말 매력적이죠.\n \nGPT-4.1 nano는 짧은 대기 시간이 중요한 작업에 적합해요. 분류나 자동 완성과 같은 작업에 이상적이라고 해요. 100만 토큰의 컨텍스트 윈도우를 가지고 있으면서도 MMLU에서 80.1%, GPQA에서 50.3%의 높은 점수를 받았대요.\n저는 개인적으로 GPT-4.1 mini가 가성비 면에서 가장 좋은 선택일 것 같다는 생각이 들어요. 대부분의 일반적인 작업에 충분한 성능을 제공하면서도 비용은 상당히 저렴하니까요.\n \n\n\n\n자주 묻는 질문 (FAQ) ❓\nQ: GPT-4.1은 ChatGPT에서도 사용할 수 있나요?\nA: 아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.\nQ: GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?\nA: GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.\nQ: GPT-4.1 시리즈의 가격은 어떻게 되나요?\nA: GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.\nQ: GPT-4.5 Preview는 어떻게 되나요?\nA: GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.\nQ: GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?\nA: 2024년 6월까지의 정보를 담고 있습니다.\n \n \n \n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1은 ChatGPT에서도 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 가격은 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.5 Preview는 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"2024년 6월까지의 정보를 담고 있습니다.\"\n    }\n  }]\n}",
        "guid": "http://muzbox.tistory.com/483569",
        "categories": [
          "AI, 미래기술/AI 챗봇 및 언어 모델",
          "AI 개발",
          "gpt-4.1",
          "gpt-4.1 mini",
          "gpt-4.1 nano",
          "OpenAI",
          "긴 컨텍스트",
          "인공지능",
          "지시 이행",
          "컨텍스트 윈도우",
          "코딩 능력"
        ],
        "isoDate": "2025-04-16T01:06:48.000Z"
      },
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "ChatGPT의 GPT-4o 이미지 생성, DALL-E를 어떻게 뛰어넘었나?",
        "link": "http://muzbox.tistory.com/483568",
        "pubDate": "Tue, 15 Apr 2025 08:42:07 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483568#entry483568comment",
        "content": "<p data-ke-size=\"size16\">&nbsp;ChatGPT의 GPT-4o 이미지 생성 기능의 혁신적인 변화! DALL-E와는 무엇이 다른지, 실제 사용해보니 드러난 장단점과 창작계에 미칠 파장까지. AI 이미지 생성의 새 시대가 열렸다고? 디자이너라면 꼭 알아야 할 모든 것.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"><span data-url=\"https://blog.kakaocdn.net/dn/beQ5vI/btsNhu8ooKq/CucFTaHTYCcozipDc2eF1K/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/beQ5vI/btsNhu8ooKq/CucFTaHTYCcozipDc2eF1K/img.png\"><img src=\"https://blog.kakaocdn.net/dn/beQ5vI/btsNhu8ooKq/CucFTaHTYCcozipDc2eF1K/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbeQ5vI%2FbtsNhu8ooKq%2FCucFTaHTYCcozipDc2eF1K%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"ChatGPT의 GPT-4o 이미지 생성, DALL-E를 어떻게 뛰어넘었나?\" loading=\"lazy\" width=\"1280\" height=\"853\" data-filename=\"blob\" data-origin-width=\"1280\" data-origin-height=\"853\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">요즘 들어 SNS를 보면 지브리풍 일러스트부터 놀라울 정도로 사실적인 사진까지, 모두 ChatGPT로 만들었다는 이미지들이 넘쳐나고 있어요. \"뭐야, ChatGPT도 이제 이미지를 만들어?\" 라고 생각하시는 분들 많으실 텐데요. 네, 맞습니다. 2025년 3월 26일, OpenAI가 GPT-4o를 출시하면서 DALL-E를 대체하는 이미지 생성 기능을 통합했거든요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">저는 디자인 분야에서 일하다 보니 미드저니, 스테이블 디퓨전부터 DALL-E까지 거의 모든 AI 이미지 생성 도구를 업무에 활용해왔는데요. GPT-4o의 이미지 생성 기능을 처음 접했을 때는 정말 놀랐어요. 왜 그랬는지, 그리고 이 변화가 우리에게 어떤 의미인지 함께 알아볼까요?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>DALL-E에서 GPT-4o로, 무엇이 바뀌었나?  </b></span></h2>\n<p data-ke-size=\"size16\">이전까지 ChatGPT에서 이미지를 생성하려면 별도의 DALL-E 모델을 호출해야 했어요. 대화하다가 \"이 설명을 이미지로 만들어줘\"라고 하면 모드 전환이 일어나면서 DALL-E가 작동했죠. 하지만 이제는 GPT-4o 하나로 대화와 이미지 생성이 모두 가능해졌어요.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">주요 변화점  </span></h3>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>통합된 사용자 경험</b> - 대화 흐름 중에 자연스럽게 이미지 생성이 가능해졌어요. 모드 전환 없이 대화하듯 이미지를 요청하면 바로 만들어줍니다.</li>\n<li><b>향상된 응답 속도</b> - DALL-E는 이미지 생성에 10-20초가 걸렸는데, GPT-4o는 대략 절반 정도로 시간이 단축됐어요.</li>\n<li><b>텍스트 렌더링 성능 향상</b> - 이전 DALL-E의 큰 약점 중 하나가 이미지 속 텍스트 처리였는데, GPT-4o는 이 부분이 획기적으로 개선되었어요. 포스터나 책 표지 같은 텍스트가 포함된 이미지 생성이 훨씬 정확해졌답니다.</li>\n<li><b>스타일 일관성</b> - 다양한 예술 스타일을 요청했을 때 일관된 퀄리티를 유지하는 능력이 향상되었어요. 특히 '지브리풍'으로 유명해진 애니메이션 스타일 구현이 뛰어나죠.</li>\n</ol>\n<p data-ke-size=\"size16\">솔직히 말하자면, 순수하게 사진 같은 사실적 이미지만 놓고 보면 기존 DALL-E가 약간 더 나은 경우도 있었어요. 하지만 전반적인 성능과 사용성은 GPT-4o가 훨씬 뛰어납니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>실제 사용해보니 느낀 GPT-4o 이미지 생성의 강점  </b></span></h2>\n<p data-ke-size=\"size16\">실제로 제가 업무에 활용해보니 GPT-4o의 강점이 확실히 드러나더라고요.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">1. 맥락 이해 능력</span></h3>\n<p data-ke-size=\"size16\">제가 가장 놀란 부분은 대화 맥락을 기반으로 이미지를 생성한다는 점이에요. 예를 들어, 로고 디자인에 대해 길게 대화를 나눈 후 \"이걸 이미지로 만들어줘\"라고 하면 이전 대화 내용을 모두 고려한 이미지를 만들어줍니다. DALL-E는 그냥 그 한 문장만 고려했죠.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">2. 디테일 컨트롤</span></h3>\n<p data-ke-size=\"size16\">\"조금 더 밝게\", \"왼쪽 캐릭터의 표정을 더 행복하게\" 같은 세부 수정 요청에 훨씬 더 정확하게 반응해요. 이전에는 비슷한 프롬프트로 처음부터 다시 생성하는 경우가 많았는데, GPT-4o는 원하는 부분만 정확히 수정해주는 경우가 많아요.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">3. 텍스트와 이미지의 완벽한 조화</span></h3>\n<p data-ke-size=\"size16\">포스터나 인포그래픽처럼 텍스트가 포함된 이미지를 만들 때 정말 빛을 발해요. DALL-E에서는 \"Happy Birthday\"라는 간단한 문구조차 \"Ha9py Birtиday\" 같은 이상한 글자로 나오는 경우가 많았는데, GPT-4o는 거의 완벽하게 텍스트를 렌더링합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>아직 아쉬운 점들  </b></span></h2>\n<p data-ke-size=\"size16\">물론 완벽하진 않아요. 제가 실제 사용하면서 느낀 한계점도 있습니다:</p>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>복잡한 구도의 한계</b> - 여러 사람이 특정 동작을 취하고 있는 복잡한 장면을 요청하면 여전히 손이나 발이 이상하게 나오는 경우가 있어요.</li>\n<li><b>해상도 제한</b> - 현재 생성되는 이미지의 해상도가 제한적이라 고품질 인쇄물용으로 사용하기엔 부족해요.</li>\n<li><b>스타일 제한</b> - 특정 작가나 브랜드의 스타일을 정확하게 모방하는 데는 여전히 한계가 있습니다.</li>\n</ol>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>이 변화가 창작 산업에 미칠 영향  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4o의 이미지 생성 기능은 단순한 기술적 발전을 넘어 창작 방식 자체를 바꿀 잠재력이 있어요. 이제 누구나 쉽게 자신의 아이디어를 시각화할 수 있게 되었으니까요.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">디자이너와 일러스트레이터에게는?</span></h3>\n<p data-ke-size=\"size16\">솔직히 말해서, 불안함을 느끼는 디자이너분들 많으실 거예요. 하지만 저는 이걸 위협보다는 도구로 봐야 한다고 생각해요. 디자인 초안을 빠르게 만들거나, 클라이언트와 소통하는 과정에서 아이디어를 시각화하는 데 정말 유용하거든요.</p>\n<p data-ke-size=\"size16\">실제로 저는 로고 디자인 작업할 때 클라이언트에게 다양한 방향성을 빠르게 제시하기 위해 GPT-4o를 활용하고 있어요. 물론 최종 결과물은 직접 다듬지만, 아이디어 발상 과정이 훨씬 효율적으로 바뀌었답니다.</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">마케팅과 콘텐츠 제작에는?</span></h3>\n<p data-ke-size=\"size16\">SNS 마케팅이나 블로그 콘텐츠 제작자들에게는 정말 혁명적인 변화에요. 이제 디자이너 없이도 괜찮은 퀄리티의 이미지를 즉석에서 만들 수 있으니까요. 특히 텍스트 렌더링이 개선되어 광고나 프로모션 이미지 제작이 훨씬 쉬워졌어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>GPT-4o 이미지 생성, 어떻게 활용해야 할까?  </b></span></h2>\n<p data-ke-size=\"size16\">제가 실제로 GPT-4o 이미지 생성을 활용하면서 터득한 팁을 몇 가지 공유할게요:</p>\n<ol style=\"list-style-type: decimal;\" data-ke-list-type=\"decimal\">\n<li><b>맥락이 풍부한 프롬프트 작성하기</b> - 단순히 \"고양이 그림\"보다는 \"푸른 하늘 아래 햇살을 받으며 창가에 앉아있는 티베트산 하얀 고양이, 스튜디오 조명, 소니 A7 카메라로 촬영한 느낌\"처럼 구체적으로 설명하세요.</li>\n<li><b>대화 맥락 활용하기</b> - 이미지를 생성하기 전에 원하는 스타일이나 분위기에 대해 충분히 설명하면 더 좋은 결과물을 얻을 수 있어요.</li>\n<li><b>반복 생성으로 완성도 높이기</b> - 첫 결과물에 만족하지 못했다면 \"이 이미지에서 배경을 더 밝게, 인물의 표정을 더 행복하게 수정해줘\"처럼 구체적인 피드백을 주세요.</li>\n<li><b>텍스트 활용하기</b> - GPT-4o는 텍스트 렌더링이 강점이니 포스터, 책 표지, 로고 등 텍스트가 포함된 이미지 생성에 적극 활용해보세요.</li>\n</ol>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blob\" data-origin-width=\"866\" data-origin-height=\"486\"><span data-url=\"https://blog.kakaocdn.net/dn/Hb7rL/btsNlgBaU4F/E9DvsnoyK3BIXSZdfToNnk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/Hb7rL/btsNlgBaU4F/E9DvsnoyK3BIXSZdfToNnk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/Hb7rL/btsNlgBaU4F/E9DvsnoyK3BIXSZdfToNnk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHb7rL%2FbtsNlgBaU4F%2FE9DvsnoyK3BIXSZdfToNnk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"ChatGPT의 GPT-4o 이미지 생성 시대\" loading=\"lazy\" width=\"866\" height=\"486\" data-filename=\"blob\" data-origin-width=\"866\" data-origin-height=\"486\"/></span></figure>\n</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #009a87;\"><b>결론: 창작의 민주화가 시작됐다  </b></span></h2>\n<p data-ke-size=\"size16\">GPT-4o의 이미지 생성 기능은 DALL-E를 단순히 대체한 것이 아니라, AI 이미지 생성의 패러다임 자체를 바꾸고 있어요. 기술적으로는 더 정교해졌고, 사용자 경험 측면에서는 훨씬 더 접근성이 높아졌죠.</p>\n<p data-ke-size=\"size16\">물론 전문 디자이너나 사진작가의 창의적 작업을 완전히 대체하진 못하겠지만, 창작의 문턱을 크게 낮췄다는 점은 분명해요. 이제 \"난 그림을 못 그려\"라는 말은 더 이상 변명이 되지 않을지도 모르겠네요.</p>\n<p data-ke-size=\"size16\">여러분도 GPT-4o의 이미지 생성 기능을 사용해보셨나요? 어떤 경험을 하셨는지, 또 어떻게 활용하고 계신지 댓글로 공유해주세요!  </p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\"><b>자주 묻는 질문  </b></span></h2>\n<p data-ke-size=\"size16\"><b>Q: GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?</b></p>\n<p data-ke-size=\"size16\">A: OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.</p>\n<p data-ke-size=\"size16\"><b>Q: GPT-4o 이미지 생성은 무료인가요?</b></p>\n<p data-ke-size=\"size16\">A: ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: DALL-E는 이제 완전히 사라진 건가요?</b></p>\n<p data-ke-size=\"size16\">A: 네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 생성된 이미지를 편집할 수 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 생성된 이미지의 해상도는 어떻게 되나요?</b></p>\n<p data-ke-size=\"size16\">A: 현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.</p>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o 이미지 생성은 무료인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"DALL-E는 이제 완전히 사라진 건가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지를 편집할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지의 해상도는 어떻게 되나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.\"\n      }\n    }\n  ]\n}\n</script>",
        "contentSnippet": "ChatGPT의 GPT-4o 이미지 생성 기능의 혁신적인 변화! DALL-E와는 무엇이 다른지, 실제 사용해보니 드러난 장단점과 창작계에 미칠 파장까지. AI 이미지 생성의 새 시대가 열렸다고? 디자이너라면 꼭 알아야 할 모든 것.\n\n\n \n요즘 들어 SNS를 보면 지브리풍 일러스트부터 놀라울 정도로 사실적인 사진까지, 모두 ChatGPT로 만들었다는 이미지들이 넘쳐나고 있어요. \"뭐야, ChatGPT도 이제 이미지를 만들어?\" 라고 생각하시는 분들 많으실 텐데요. 네, 맞습니다. 2025년 3월 26일, OpenAI가 GPT-4o를 출시하면서 DALL-E를 대체하는 이미지 생성 기능을 통합했거든요.\n \n저는 디자인 분야에서 일하다 보니 미드저니, 스테이블 디퓨전부터 DALL-E까지 거의 모든 AI 이미지 생성 도구를 업무에 활용해왔는데요. GPT-4o의 이미지 생성 기능을 처음 접했을 때는 정말 놀랐어요. 왜 그랬는지, 그리고 이 변화가 우리에게 어떤 의미인지 함께 알아볼까요?\n \nDALL-E에서 GPT-4o로, 무엇이 바뀌었나?  \n이전까지 ChatGPT에서 이미지를 생성하려면 별도의 DALL-E 모델을 호출해야 했어요. 대화하다가 \"이 설명을 이미지로 만들어줘\"라고 하면 모드 전환이 일어나면서 DALL-E가 작동했죠. 하지만 이제는 GPT-4o 하나로 대화와 이미지 생성이 모두 가능해졌어요.\n주요 변화점  \n통합된 사용자 경험 - 대화 흐름 중에 자연스럽게 이미지 생성이 가능해졌어요. 모드 전환 없이 대화하듯 이미지를 요청하면 바로 만들어줍니다.\n향상된 응답 속도 - DALL-E는 이미지 생성에 10-20초가 걸렸는데, GPT-4o는 대략 절반 정도로 시간이 단축됐어요.\n텍스트 렌더링 성능 향상 - 이전 DALL-E의 큰 약점 중 하나가 이미지 속 텍스트 처리였는데, GPT-4o는 이 부분이 획기적으로 개선되었어요. 포스터나 책 표지 같은 텍스트가 포함된 이미지 생성이 훨씬 정확해졌답니다.\n스타일 일관성 - 다양한 예술 스타일을 요청했을 때 일관된 퀄리티를 유지하는 능력이 향상되었어요. 특히 '지브리풍'으로 유명해진 애니메이션 스타일 구현이 뛰어나죠.\n솔직히 말하자면, 순수하게 사진 같은 사실적 이미지만 놓고 보면 기존 DALL-E가 약간 더 나은 경우도 있었어요. 하지만 전반적인 성능과 사용성은 GPT-4o가 훨씬 뛰어납니다.\n \n실제 사용해보니 느낀 GPT-4o 이미지 생성의 강점  \n실제로 제가 업무에 활용해보니 GPT-4o의 강점이 확실히 드러나더라고요.\n1. 맥락 이해 능력\n제가 가장 놀란 부분은 대화 맥락을 기반으로 이미지를 생성한다는 점이에요. 예를 들어, 로고 디자인에 대해 길게 대화를 나눈 후 \"이걸 이미지로 만들어줘\"라고 하면 이전 대화 내용을 모두 고려한 이미지를 만들어줍니다. DALL-E는 그냥 그 한 문장만 고려했죠.\n2. 디테일 컨트롤\n\"조금 더 밝게\", \"왼쪽 캐릭터의 표정을 더 행복하게\" 같은 세부 수정 요청에 훨씬 더 정확하게 반응해요. 이전에는 비슷한 프롬프트로 처음부터 다시 생성하는 경우가 많았는데, GPT-4o는 원하는 부분만 정확히 수정해주는 경우가 많아요.\n3. 텍스트와 이미지의 완벽한 조화\n포스터나 인포그래픽처럼 텍스트가 포함된 이미지를 만들 때 정말 빛을 발해요. DALL-E에서는 \"Happy Birthday\"라는 간단한 문구조차 \"Ha9py Birtиday\" 같은 이상한 글자로 나오는 경우가 많았는데, GPT-4o는 거의 완벽하게 텍스트를 렌더링합니다.\n \n아직 아쉬운 점들  \n물론 완벽하진 않아요. 제가 실제 사용하면서 느낀 한계점도 있습니다:\n복잡한 구도의 한계 - 여러 사람이 특정 동작을 취하고 있는 복잡한 장면을 요청하면 여전히 손이나 발이 이상하게 나오는 경우가 있어요.\n해상도 제한 - 현재 생성되는 이미지의 해상도가 제한적이라 고품질 인쇄물용으로 사용하기엔 부족해요.\n스타일 제한 - 특정 작가나 브랜드의 스타일을 정확하게 모방하는 데는 여전히 한계가 있습니다.\n \n이 변화가 창작 산업에 미칠 영향  \nGPT-4o의 이미지 생성 기능은 단순한 기술적 발전을 넘어 창작 방식 자체를 바꿀 잠재력이 있어요. 이제 누구나 쉽게 자신의 아이디어를 시각화할 수 있게 되었으니까요.\n디자이너와 일러스트레이터에게는?\n솔직히 말해서, 불안함을 느끼는 디자이너분들 많으실 거예요. 하지만 저는 이걸 위협보다는 도구로 봐야 한다고 생각해요. 디자인 초안을 빠르게 만들거나, 클라이언트와 소통하는 과정에서 아이디어를 시각화하는 데 정말 유용하거든요.\n실제로 저는 로고 디자인 작업할 때 클라이언트에게 다양한 방향성을 빠르게 제시하기 위해 GPT-4o를 활용하고 있어요. 물론 최종 결과물은 직접 다듬지만, 아이디어 발상 과정이 훨씬 효율적으로 바뀌었답니다.\n마케팅과 콘텐츠 제작에는?\nSNS 마케팅이나 블로그 콘텐츠 제작자들에게는 정말 혁명적인 변화에요. 이제 디자이너 없이도 괜찮은 퀄리티의 이미지를 즉석에서 만들 수 있으니까요. 특히 텍스트 렌더링이 개선되어 광고나 프로모션 이미지 제작이 훨씬 쉬워졌어요.\n \nGPT-4o 이미지 생성, 어떻게 활용해야 할까?  \n제가 실제로 GPT-4o 이미지 생성을 활용하면서 터득한 팁을 몇 가지 공유할게요:\n맥락이 풍부한 프롬프트 작성하기 - 단순히 \"고양이 그림\"보다는 \"푸른 하늘 아래 햇살을 받으며 창가에 앉아있는 티베트산 하얀 고양이, 스튜디오 조명, 소니 A7 카메라로 촬영한 느낌\"처럼 구체적으로 설명하세요.\n대화 맥락 활용하기 - 이미지를 생성하기 전에 원하는 스타일이나 분위기에 대해 충분히 설명하면 더 좋은 결과물을 얻을 수 있어요.\n반복 생성으로 완성도 높이기 - 첫 결과물에 만족하지 못했다면 \"이 이미지에서 배경을 더 밝게, 인물의 표정을 더 행복하게 수정해줘\"처럼 구체적인 피드백을 주세요.\n텍스트 활용하기 - GPT-4o는 텍스트 렌더링이 강점이니 포스터, 책 표지, 로고 등 텍스트가 포함된 이미지 생성에 적극 활용해보세요.\n\n\n결론: 창작의 민주화가 시작됐다  \nGPT-4o의 이미지 생성 기능은 DALL-E를 단순히 대체한 것이 아니라, AI 이미지 생성의 패러다임 자체를 바꾸고 있어요. 기술적으로는 더 정교해졌고, 사용자 경험 측면에서는 훨씬 더 접근성이 높아졌죠.\n물론 전문 디자이너나 사진작가의 창의적 작업을 완전히 대체하진 못하겠지만, 창작의 문턱을 크게 낮췄다는 점은 분명해요. 이제 \"난 그림을 못 그려\"라는 말은 더 이상 변명이 되지 않을지도 모르겠네요.\n여러분도 GPT-4o의 이미지 생성 기능을 사용해보셨나요? 어떤 경험을 하셨는지, 또 어떻게 활용하고 계신지 댓글로 공유해주세요!  \n자주 묻는 질문  \nQ: GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?\nA: OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.\nQ: GPT-4o 이미지 생성은 무료인가요?\nA: ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.\nQ: DALL-E는 이제 완전히 사라진 건가요?\nA: 네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.\nQ: 생성된 이미지를 편집할 수 있나요?\nA: 현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.\nQ: 생성된 이미지의 해상도는 어떻게 되나요?\nA: 현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.\n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o 이미지 생성은 무료인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"DALL-E는 이제 완전히 사라진 건가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지를 편집할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지의 해상도는 어떻게 되나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.\"\n      }\n    }\n  ]\n}",
        "guid": "http://muzbox.tistory.com/483568",
        "categories": [
          "AI, 미래기술/AI 이미지 및 아트 생성",
          "AI 이미지",
          "ai 창작 도구",
          "ai 프롬프트 작성법",
          "chatgpt 그림 기능",
          "dall-e 대체",
          "gpt-4o 이미지 생성",
          "디자인 자동화",
          "이미지 생성 프롬프트",
          "지브리풍 ai",
          "텍스트 렌더링"
        ],
        "isoDate": "2025-04-14T23:42:07.000Z"
      },
      {
        "creator": "어떤오후의 프리웨어 이야기",
        "title": "ChatGPT 검색 vs 추론 - 당신의 질문에 맞는 최적의 선택은?",
        "link": "http://muzbox.tistory.com/483567",
        "pubDate": "Fri, 11 Apr 2025 12:01:03 +0900",
        "author": "어떤오후의 프리웨어 이야기",
        "comments": "http://muzbox.tistory.com/483567#entry483567comment",
        "content": "<p data-ke-size=\"size16\">ChatGPT 검색과 추론 기능, 언제 어떤 걸 써야 할지 고민돼요? 실제 사용해보니 확실히 달라요! 사실 확인은 검색, 깊은 분석은 추론, 이 가이드로 AI 활용 효율성을 높여보세요.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"ChatGPT 검색 vs 추론 - 당신의 질문에 맞는 최적의 선택은.webp\" data-origin-width=\"1536\" data-origin-height=\"1024\"><span data-url=\"https://blog.kakaocdn.net/dn/xx1kF/btsNh65AIgZ/nkk7168qWy03AT3AMQ7KSk/img.webp\" data-phocus=\"https://blog.kakaocdn.net/dn/xx1kF/btsNh65AIgZ/nkk7168qWy03AT3AMQ7KSk/img.webp\"><img src=\"https://blog.kakaocdn.net/dn/xx1kF/btsNh65AIgZ/nkk7168qWy03AT3AMQ7KSk/img.webp\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fxx1kF%2FbtsNh65AIgZ%2Fnkk7168qWy03AT3AMQ7KSk%2Fimg.webp\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"ChatGPT 검색 vs 추론 - 당신의 질문에 맞는 최적의 선택은?\" loading=\"lazy\" width=\"1536\" height=\"1024\" data-filename=\"ChatGPT 검색 vs 추론 - 당신의 질문에 맞는 최적의 선택은.webp\" data-origin-width=\"1536\" data-origin-height=\"1024\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">ChatGPT 검색과 추론 기능, 어떻게 구분해서 써야 할까?</p>\n<p data-ke-size=\"size16\">어젯밤에 갑자기 궁금한 게 있어서 ChatGPT를 켰는데, 검색이랑 추론 중에 뭘 선택해야 할지 한참을 고민했어요. 여러분도 그런 경험 있으신가요? 이래저래 둘 다 써보니까 확실히 차이가 느껴지더라고요. 그래서 오늘은 제가 실제로 사용해보면서 알게 된 ChatGPT의 검색과 추론 기능의 차이점과 각각 언제 써야 좋은지 정리해봤습니다.  </p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>ChatGPT 검색 기능: 구체적인 사실이나 업데이트가 필요할 때  </b></span></h2>\n<p data-ke-size=\"size16\">ChatGPT의 검색 기능은 말 그대로 구체적인 정보나 최신 데이터가 필요할 때 딱이에요. 빠르고 정확한 답변을 원한다면 검색 기능을 사용하세요. 마치 여러분 옆에 앉아서 즉각적으로 정보를 찾아주는 비서 같은 느낌이랄까요?</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"ChatGPT 검색 기능 개요.png\" data-origin-width=\"720\" data-origin-height=\"628\"><span data-url=\"https://blog.kakaocdn.net/dn/2H2do/btsNhJC0M1l/o3UyeeH0Y2mgpeZkLWNNo0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/2H2do/btsNhJC0M1l/o3UyeeH0Y2mgpeZkLWNNo0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/2H2do/btsNhJC0M1l/o3UyeeH0Y2mgpeZkLWNNo0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2H2do%2FbtsNhJC0M1l%2Fo3UyeeH0Y2mgpeZkLWNNo0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"ChatGPT 검색 기능 개요\" loading=\"lazy\" width=\"631\" height=\"550\" data-filename=\"ChatGPT 검색 기능 개요.png\" data-origin-width=\"720\" data-origin-height=\"628\"/></span></figure>\n</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">최신 소식과 업데이트  </span></h3>\n<p data-ke-size=\"size16\">솔직히 말해서, 요즘 뉴스 보는 것도 귀찮을 때 있잖아요. 정치 소식이나 스포츠 경기 결과, 주식 시장 상황 같은 최신 정보가 필요하시다면 ChatGPT 검색이 짱이에요.</p>\n<p data-ke-size=\"size16\">저는 지난주에 K리그 순위표가 궁금했는데, 여러 사이트를 뒤적거릴 필요 없이 ChatGPT 검색으로 한방에 해결했어요. 진짜 편하더라구요!</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[검색] 현재 K리그1 순위표와 다음 경기 일정을 알려줘.\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">기본 상식과 정의  </span></h3>\n<p data-ke-size=\"size16\">가끔 갑자기 \"이 단어가 뭐였지?\" 하는 순간 있잖아요. 과학 개념이든, 어려운 단어 철자든, 역사적 사건이든 간단한 정보를 얻고 싶을 때 검색 기능이 제격이에요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어 \"애자일 방법론이 정확히 뭐야?\" 같은 질문이나 \"대한민국 제2대 대통령이 누구였지?\" 같은 기본 사실 확인에 아주 유용해요. 불필요한 세부 정보 없이 명확하고 간결한 답변을 받을 수 있어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[검색] 애자일 방법론의 정확한 의미와 장단점을 알려줘.\n[검색] 대한민국 제2대 대통령은 누구였고, 어떤 업적이 있었어?\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">최신 제품 정보  </span></h3>\n<p data-ke-size=\"size16\">요즘처럼 기술이 빠르게 발전하는 시대에는 최신 제품 사양이나 리뷰를 찾는 게 쉽지 않잖아요. ChatGPT 검색은 가젯, 자동차, 또는 다른 소비재를 비교할 때 특히 유용해요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">최신 아이폰의 스펙이 궁금하거나 구매하려는 차에 대한 리뷰를 알고 싶다면, 검색 기능이 가장 신뢰할 수 있는 출처에서 최신 데이터를 가져와 줍니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어, 최신 갤럭시폰이 이전 모델보다 성능이 더 좋은지 궁금하다면? 빠른 검색으로 새로운 기능, 스펙, 사용자 리뷰를 한눈에 볼 수 있어요. 여러 웹사이트를 뒤적거릴 필요가 없죠.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"angelscript\"><code>[검색] 최신 아이폰 15 Pro와 아이폰 14 Pro의 스펙, 가격, 카메라 성능을 비교해줘.\n[검색] 2025년 출시된 현대 아이오닉 7의 주행 거리와 충전 시간, 그리고 테슬라 모델 Y와 비교한 장단점은?\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">지역 정보  </span></h3>\n<p data-ke-size=\"size16\">날씨 예보, 주변 이벤트, 맛집 추천 같은 지역 정보도 ChatGPT 검색으로 쉽게 얻을 수 있어요. 여행 중이거나 주변에서 특별한 것을 찾고 있다면, 간단히 물어보세요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">명동 근처에서 맛있는 순두부찌개 맛집을 찾고 싶다고요? ChatGPT가 즉시 리뷰와 평점을 포함한 최고 평점의 음식점 목록을 알려줄 거예요. 소중한 시간을 최대한 활용할 수 있겠죠?</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[검색] 서울 강남역 근처 분위기 좋은 데이트 카페 추천해줘. 주차가 편한 곳으로 알려줘.\n[검색] 이번 주말 부산에서 열리는 문화 행사나 축제가 있을까?\n</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>ChatGPT 추론 기능: 깊이 있는 생각과 문제 해결이 필요할 때  </b></span></h2>\n<p data-ke-size=\"size16\">ChatGPT의 검색 기능이 빠르고 사실적인 답변에 좋다면, 추론 기능은 더 복잡한 작업에 진가를 발휘해요. 깊은 분석이나 창의적 사고가 필요한 까다로운 문제에 부딪혔을 때는 ChatGPT 추론의 문제 해결 능력을 활용하세요.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"ChatGPT의 추론 기능 활용.png\" data-origin-width=\"816\" data-origin-height=\"456\"><span data-url=\"https://blog.kakaocdn.net/dn/cFyw5M/btsNhRujHwW/0Fakjc9kGVkOU23NQK10N0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cFyw5M/btsNhRujHwW/0Fakjc9kGVkOU23NQK10N0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cFyw5M/btsNhRujHwW/0Fakjc9kGVkOU23NQK10N0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcFyw5M%2FbtsNhRujHwW%2F0Fakjc9kGVkOU23NQK10N0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"ChatGPT의 추론 기능 활용\" loading=\"lazy\" width=\"816\" height=\"456\" data-filename=\"ChatGPT의 추론 기능 활용.png\" data-origin-width=\"816\" data-origin-height=\"456\"/></span></figure>\n</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">복잡한 문제 해결  </span></h3>\n<p data-ke-size=\"size16\">여러 계층을 분석하거나 다양한 옵션을 평가해야 하는 작업에는 ChatGPT의 추론 능력이 정말 소중해요. 사업 전략을 계획하거나 기술적인 문제를 해결할 때, ChatGPT는 다양한 각도를 탐색하고 정보에 기반한 결정을 내리는 데 도움을 줍니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어, 스타트업을 위한 최적의 마케팅 전략을 결정하려 한다면, ChatGPT는 다양한 접근 방식의 장단점을 비교하고, 가능한 장애물을 고려하며, 유사한 사례 연구를 바탕으로 인사이트를 제공할 수 있어요. 단순히 빠른 사실만 제공하는 것이 아니라, 문제 해결을 위한 비판적 사고 과정을 안내해 줍니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[추론] 미용실 창업을 준비 중인데, 경쟁이 치열한 강남 지역에서 차별화된 마케팅 전략을 세우고 싶어. 소셜 미디어, 지역 특성, 타겟 고객층을 고려해서 구체적인 전략을 제안해줘.\n\n[추론] 우리 회사는 30명 규모의 소프트웨어 개발 스타트업인데, 재택근무와 사무실 근무를 어떻게 균형있게 조합할지 고민이야. 팀 문화, 생산성, 직원 만족도를 모두 고려한 하이브리드 근무 정책을 설계해줄 수 있을까?\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">창의적 작업  </span></h3>\n<p data-ke-size=\"size16\">ChatGPT의 추론은 창의적인 브레인스토밍에도 훌륭한 선택이에요. 이 기능은 논리, 패턴, 관련 데이터를 활용하여 혁신적인 아이디어를 개발하거나 기존 아이디어를 개선하는 데 도움을 줍니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">소설 플롯에 막혔다면, ChatGPT가 창의적인 프롬프트, 캐릭터 아크, 또는 대체 엔딩을 제안할 수 있어요. 마찬가지로, 지역 커뮤니티 이벤트를 계획한다면, ChatGPT는 독특한 테마, 인터랙티브 활동, 또는 관객을 참여시키는 방법을 브레인스토밍하는 데 도움을 줄 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[추론] 나는 현대판 판타지 소설을 쓰고 있어. 주인공은 평범한 대학생인데 어느날 자신이 꿈속에서 사람들의 병을 치유할 수 있는 능력이 있다는 걸 알게 돼. 이 설정을 바탕으로 흥미로운 플롯 전개와 갈등 요소를 제안해줘.\n\n[추론] 우리 동네 작은 도서관에서 아이들을 위한 여름 독서 프로그램을 기획 중이야. '바다와 모험'이라는 주제로 6-10세 아이들이 책에 흥미를 갖게 할 수 있는 창의적인 활동 아이디어를 5가지 제안해줘.\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">논증 분석 또는 의사 결정 ⚖️</span></h3>\n<p data-ke-size=\"size16\">여러 옵션과 많은 변수가 있는 결정에 직면했을 때, ChatGPT 추론은 필수적인 두 번째 의견이 됩니다. 추론 기능을 사용하면 각 선택지의 장단점을 분석하며 상황의 모든 측면을 고려할 수 있어요. 결정하기 어려운 순간에 균형 잡힌 선택을 할 수 있게 도와줍니다.</p>\n<p data-ke-size=\"size16\">예를 들어, 두 개의 채용 제안 중에서 고민하고 있다면, ChatGPT는 각 역할의 이점과 단점을 나열하는 데 도움을 줄 수 있어요. 회사 문화, 경력 성장, 보상, 일과 삶의 균형 같은 요소를 고려하도록 도와줍니다. 또한 ChatGPT는 여러분의 우선순위에 따라 대안 제안을 제공하여 의사 결정 과정을 더 쉽게 만들 수 있어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"angelscript\"><code>[추론] 현재 안정적인 대기업(연봉 7000)과 성장 가능성이 높은 스타트업(연봉 5500 + 스톡옵션)의 제안을 동시에 받았어. 경력 성장, 일-삶 균형, 재정적 안정성, 그리고 장기적 전망 측면에서 두 선택지를 분석해줘. 내 우선순위는 1) 성장 2) 안정성 3) 워라밸 순이야.\n\n[추론] 결혼식 장소로 자연 속 야외 웨딩과 고급 호텔 실내 웨딩 중에서 고민 중이야. 날씨 리스크, 비용, 접근성, 사진 퀄리티, 하객 편의성 등 다양한 요소를 비교 분석해줘. 우리는 5월에 결혼할 예정이고, 하객은 약 150명 정도야.\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">복잡한 아이디어 설명  </span></h3>\n<p data-ke-size=\"size16\">때로는 단순한 답변 이상이 필요할 때가 있죠. 복잡한 과학 개념, 고급 기술, 또는 이론을 이해하려고 할 때, ChatGPT의 추론 기능은 상세하게 설명해 줄 수 있어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">예를 들어, 블록체인이나 머신 러닝 같은 개념으로 고민하고 있다면, ChatGPT는 기본과 더 복잡한 측면 모두를 다루는 상세하고 쉽게 따라갈 수 있는 설명을 제공할 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[추론] 양자컴퓨팅의 기본 원리를 고등학생 수준에서 이해할 수 있게 설명해줘. 특히 기존 컴퓨터와의 차이점과 왜 특정 문제에서 더 효율적인지 비유를 들어 설명해주면 좋겠어.\n\n[추론] ESG 경영이 정확히 무엇이고, 기업과 사회에 어떤 영향을 미치는지 체계적으로 분석해줘. 실제 성공 사례와 비판적 시각도 함께 다루어주면 좋겠어.\n</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>두 기능을 모두 선택해야 할 때  </b></span></h2>\n<p data-ke-size=\"size16\">사실과 깊은 분석 모두가 필요할 때가 있어요. 이런 상황에서는 ChatGPT의 검색과 추론 기능을 결합하면 더 완전하고 미묘한 그림을 얻을 수 있습니다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"언제 검색과 추론을 모두 사용해야 할까.png\" data-origin-width=\"792\" data-origin-height=\"510\"><span data-url=\"https://blog.kakaocdn.net/dn/kXoh2/btsNhJpu1yb/Hy3qFMXvKKN74sgE4iCEzK/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/kXoh2/btsNhJpu1yb/Hy3qFMXvKKN74sgE4iCEzK/img.png\"><img src=\"https://blog.kakaocdn.net/dn/kXoh2/btsNhJpu1yb/Hy3qFMXvKKN74sgE4iCEzK/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkXoh2%2FbtsNhJpu1yb%2FHy3qFMXvKKN74sgE4iCEzK%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"언제 검색과 추론을 모두 사용해야 할까요?\" loading=\"lazy\" width=\"792\" height=\"510\" data-filename=\"언제 검색과 추론을 모두 사용해야 할까.png\" data-origin-width=\"792\" data-origin-height=\"510\"/></span></figure>\n</p>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">A). 주제를 자세히 이해하기  </span></h3>\n<p data-ke-size=\"size16\">주제를 파고들어 원시 사실과 이들이 어떻게 연결되는지 이해하고 싶다면, ChatGPT의 검색과 추론 기능을 함께 사용하는 것이 좋아요. 이렇게 하면 구체적인 세부 정보를 수집하고 이를 더 큰 그림으로 통합할 수 있습니다.</p>\n<p data-ke-size=\"size16\">예를 들어, 우주 탐사에 대해 연구한다면, 최신 임무, 기술, 발견을 검색하면서 동시에 이들이 사회에 미칠 잠재적 영향에 대해 추론할 수 있어요. 이렇게 하면 사실만 수집하는 것이 아니라, 그것들이 인간 지식, 우주 여행, 미래 노력에 미치는 영향도 한꺼번에 평가할 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[검색+추론] 최근 5년간 우주 개발 동향과 주요 발전 사항을 검색해주고, 이러한 발전이 향후 10년 내 지구 경제와 과학 기술에 미칠 영향을 종합적으로 분석해줘.\n\n[검색+추론] 현재 글로벌 반도체 산업의 주요 기업들과 시장 점유율을 조사하고, 미-중 기술 갈등이 장기적으로 반도체 공급망과 한국 기업들에게 어떤 영향을 미칠지 전망해줘.\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">B). 여러 변수가 있는 결정 내리기  </span></h3>\n<p data-ke-size=\"size16\">집 구매, 특정 소프트웨어 선택, 또는 휴가 목적지 선택과 같이 여러 옵션이나 요소를 고려해야 하는 상황에서는 검색과 추론이 모두 필요해요. 검색 기능은 각 옵션에 대한 하드 사실(비용, 기능, 리뷰)을 수집하고, 추론 기능은 장단점을 평가하여 특정 요구 사항에 가장 잘 맞는 선택을 내릴 수 있게 합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">새로운 도시로 이사를 고려하고 있다면, 주택 가격, 지역 편의 시설, 취업 기회를 조사하고 싶을 거예요. 동시에, 도시의 미적 감각, 라이프스타일, 가족이나 친구와의 거리 같은 추상적인 변수도 고려해야 합니다. 이러한 요소들을 개인 선호도와 결합하면 이사가 적합한지 파악하는 데 도움이 됩니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[검색+추론] 제주도와 부산에 1년 살 예정인데 두 도시를 비교해줘. 주거비용, 생활물가, 기후, 교통, 의료시설, 문화생활 등 객관적 데이터를 찾아주고, 30대 부부가 디지털 노마드로 살기에 어떤 곳이 더 적합할지 분석해줘.\n\n[검색+추론] 아이패드 프로와 삼성 갤럭시 탭 S9 울트라의 최신 스펙, 가격, 호환 액세서리를 비교해주고, 디지털 아트 작업과 영상 편집이 주 용도인 나에게 어떤 제품이 더 적합할지 분석해줘.\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">C). 여러 옵션이나 제품 비교하기  </span></h3>\n<p data-ke-size=\"size16\">제품, 서비스, 심지어 경력 경로를 비교할 때, 검색과 추론을 모두 사용하면 좋아요. 검색은 객관적인 사실을 제공하고, 추론은 어떤 옵션이 개인 또는 전문적 목표에 가장 적합한지 평가하거나 해당 제품에 대한 최신 정보를 얻는 데 도움을 줍니다.</p>\n<p data-ke-size=\"size16\">예를 들어, 두 노트북 중에서 고르고 있다면, 스펙과 리뷰를 확인하고(검색), 옵션을 신중히 평가해야 합니다(추론). 어떤 게 예산, 라이프스타일, 미래 필요에 맞을까요? 두 기능을 모두 활용하면 최종 결정을 내리는 데 도움이 될 수 있어요.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[검색+추론] 애플 맥북 프로 M2와 델 XPS 15의 최신 사양, 가격, 배터리 성능, 화면 품질을 비교해줘. 특히 영상 편집과 코딩을 주로 하는 내게 어떤 노트북이 더 적합할지 분석해줘.\n\n[검색+추론] 넷플릭스, 디즈니플러스, 티빙의 월 구독료, 콘텐츠 라이브러리 크기, 독점 콘텐츠를 비교해주고, 한국 드라마와 다큐멘터리를 주로 보는 내게 가장 가성비 좋은 서비스는 무엇인지 추천해줘.\n</code></pre>\n<h3 data-ke-size=\"size23\"><span style=\"color: #ee2323;\">D). 새로운 개념이나 트렌드 탐색하기  </span></h3>\n<p data-ke-size=\"size16\">검색과 추론을 함께 활용하면 새로운 개념이나 떠오르는 트렌드를 이해하는 데 도움이 될 수 있어요. 검색은 최신 정보를 수집하고, 추론은 잠재적 영향과 더 넓은 의미를 탐색합니다.</p>\n<p data-ke-size=\"size16\">예를 들어, 인공지능에 대해 궁금하다면, 검색을 사용하여 AI의 최신 발전 상황을 찾고, 추론을 사용하여 AI가 다양한 산업에 어떤 영향을 미치거나 미래에 우리 삶의 방식을 어떻게 변화시킬지 분석할 수 있습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><b>프롬프트 예시:</b></p>\n<pre class=\"prolog\"><code>[검색+추론] 웹3.0과 메타버스의 최신 발전 동향과 주요 플랫폼들을 조사해주고, 이러한 기술이 향후 5년 내 교육, 엔터테인먼트, 소매업에 어떤 변화를 가져올지 분석해줘.\n\n[검색+추론] '제로 웨이스트' 라이프스타일의 주요 원칙과 글로벌 트렌드를 조사해주고, 이를 한국의 도시 환경에서 실천하기 위한 현실적인 방법과 도전 과제를 분석해줘.\n</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"954\" data-origin-height=\"642\"><span data-url=\"https://blog.kakaocdn.net/dn/FUp69/btsNhkjtyXh/bJ0G0kJWIkmrbXTBYH9tA0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/FUp69/btsNhkjtyXh/bJ0G0kJWIkmrbXTBYH9tA0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/FUp69/btsNhkjtyXh/bJ0G0kJWIkmrbXTBYH9tA0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFUp69%2FbtsNhkjtyXh%2FbJ0G0kJWIkmrbXTBYH9tA0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" alt=\"챗GPT 검색 대 추론\" loading=\"lazy\" width=\"954\" height=\"642\" data-origin-width=\"954\" data-origin-height=\"642\"/></span></figure>\n</p>\n<h2 data-ke-size=\"size26\"><span style=\"color: #006dd7;\"><b>마치며: 상황에 맞는 선택이 중요해요  </b></span></h2>\n<p data-ke-size=\"size16\">ChatGPT의 검색 기능과 추론 기능을 언제 사용해야 할지 이해함으로써, 이러한 강력한 기능의 가치를 최대화할 수 있어요. 빠른 사실, 깊은 분석, 또는 둘 다 필요하든, ChatGPT는 거의 모든 결정을 내리고 문제에 명확하게 접근하는 데 도움을 줄 수 있으며, 종종 해당 작업에 대한 정말 유용한 두 번째 의견이나 목소리를 제공합니다.</p>\n<p data-ke-size=\"size16\">제 경우에는 일상적인 정보 검색에는 검색 기능을, 블로그 글이나 사업 계획처럼 깊은 사고가 필요한 일에는 추론 기능을 주로 사용하고 있어요. 여러분은 어떤 기능을 더 자주 사용하시나요? 댓글로 알려주세요!  </p>\n<hr data-ke-style=\"style1\" />\n<h2 data-ke-size=\"size26\"><span style=\"color: #ee2323;\"><b>Q&amp;A: ChatGPT 검색과 추론에 대해 자주 묻는 질문들</b></span></h2>\n<p data-ke-size=\"size16\"><b>Q: ChatGPT 검색 기능은 얼마나 최신 정보까지 알고 있나요?</b></p>\n<p data-ke-size=\"size16\">A: 검색 기능은 인터넷에 연결되어 있어 최신 정보를 가져옵니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 추론 기능의 한계는 무엇인가요?</b></p>\n<p data-ke-size=\"size16\">A: 복잡한 추론이 가능하지만 전문가 수준의 깊이 있는 분석은 제한적일 수 있어요.</p>\n<p data-ke-size=\"size16\"><b>Q: 검색과 추론을 동시에 사용할 때 더 느려지나요?</b></p>\n<p data-ke-size=\"size16\">A: 약간 더 시간이 걸릴 수 있지만 결과의 질이 높아져 가치가 있습니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 어떤 기능이 더 정확한가요?</b></p>\n<p data-ke-size=\"size16\">A: 사실 확인은 검색이, 복잡한 분석은 추론이 더 정확합니다.</p>\n<p data-ke-size=\"size16\"><b>Q: 추론 기능은 검색 기능보다 창의적인가요?</b></p>\n<p data-ke-size=\"size16\">A: 네, 추론 기능이 패턴 인식과 연결성을 활용해 더 창의적인 결과를 제공합니다.</p>\n<p data-ke-size=\"size16\">\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"ChatGPT 검색 기능은 얼마나 최신 정보까지 알고 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"검색 기능은 인터넷에 연결되어 있어 최신 정보를 가져옵니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"추론 기능의 한계는 무엇인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"복잡한 추론이 가능하지만 전문가 수준의 깊이 있는 분석은 제한적일 수 있어요.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"검색과 추론을 동시에 사용할 때 더 느려지나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"약간 더 시간이 걸릴 수 있지만 결과의 질이 높아져 가치가 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"어떤 기능이 더 정확한가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"사실 확인은 검색이, 복잡한 분석은 추론이 더 정확합니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"추론 기능은 검색 기능보다 창의적인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 추론 기능이 패턴 인식과 연결성을 활용해 더 창의적인 결과를 제공합니다.\"\n      }\n    }\n  ]\n}\n</script>\n</p>",
        "contentSnippet": "ChatGPT 검색과 추론 기능, 언제 어떤 걸 써야 할지 고민돼요? 실제 사용해보니 확실히 달라요! 사실 확인은 검색, 깊은 분석은 추론, 이 가이드로 AI 활용 효율성을 높여보세요.\n\n\n \nChatGPT 검색과 추론 기능, 어떻게 구분해서 써야 할까?\n어젯밤에 갑자기 궁금한 게 있어서 ChatGPT를 켰는데, 검색이랑 추론 중에 뭘 선택해야 할지 한참을 고민했어요. 여러분도 그런 경험 있으신가요? 이래저래 둘 다 써보니까 확실히 차이가 느껴지더라고요. 그래서 오늘은 제가 실제로 사용해보면서 알게 된 ChatGPT의 검색과 추론 기능의 차이점과 각각 언제 써야 좋은지 정리해봤습니다.  \n \n \nChatGPT 검색 기능: 구체적인 사실이나 업데이트가 필요할 때  \nChatGPT의 검색 기능은 말 그대로 구체적인 정보나 최신 데이터가 필요할 때 딱이에요. 빠르고 정확한 답변을 원한다면 검색 기능을 사용하세요. 마치 여러분 옆에 앉아서 즉각적으로 정보를 찾아주는 비서 같은 느낌이랄까요?\n\n\n최신 소식과 업데이트  \n솔직히 말해서, 요즘 뉴스 보는 것도 귀찮을 때 있잖아요. 정치 소식이나 스포츠 경기 결과, 주식 시장 상황 같은 최신 정보가 필요하시다면 ChatGPT 검색이 짱이에요.\n저는 지난주에 K리그 순위표가 궁금했는데, 여러 사이트를 뒤적거릴 필요 없이 ChatGPT 검색으로 한방에 해결했어요. 진짜 편하더라구요!\n \n프롬프트 예시:\n[검색] 현재 K리그1 순위표와 다음 경기 일정을 알려줘.\n\n기본 상식과 정의  \n가끔 갑자기 \"이 단어가 뭐였지?\" 하는 순간 있잖아요. 과학 개념이든, 어려운 단어 철자든, 역사적 사건이든 간단한 정보를 얻고 싶을 때 검색 기능이 제격이에요.\n \n예를 들어 \"애자일 방법론이 정확히 뭐야?\" 같은 질문이나 \"대한민국 제2대 대통령이 누구였지?\" 같은 기본 사실 확인에 아주 유용해요. 불필요한 세부 정보 없이 명확하고 간결한 답변을 받을 수 있어요.\n \n프롬프트 예시:\n[검색] 애자일 방법론의 정확한 의미와 장단점을 알려줘.\n[검색] 대한민국 제2대 대통령은 누구였고, 어떤 업적이 있었어?\n\n최신 제품 정보  \n요즘처럼 기술이 빠르게 발전하는 시대에는 최신 제품 사양이나 리뷰를 찾는 게 쉽지 않잖아요. ChatGPT 검색은 가젯, 자동차, 또는 다른 소비재를 비교할 때 특히 유용해요.\n \n최신 아이폰의 스펙이 궁금하거나 구매하려는 차에 대한 리뷰를 알고 싶다면, 검색 기능이 가장 신뢰할 수 있는 출처에서 최신 데이터를 가져와 줍니다.\n \n예를 들어, 최신 갤럭시폰이 이전 모델보다 성능이 더 좋은지 궁금하다면? 빠른 검색으로 새로운 기능, 스펙, 사용자 리뷰를 한눈에 볼 수 있어요. 여러 웹사이트를 뒤적거릴 필요가 없죠.\n \n프롬프트 예시:\n[검색] 최신 아이폰 15 Pro와 아이폰 14 Pro의 스펙, 가격, 카메라 성능을 비교해줘.\n[검색] 2025년 출시된 현대 아이오닉 7의 주행 거리와 충전 시간, 그리고 테슬라 모델 Y와 비교한 장단점은?\n\n지역 정보  \n날씨 예보, 주변 이벤트, 맛집 추천 같은 지역 정보도 ChatGPT 검색으로 쉽게 얻을 수 있어요. 여행 중이거나 주변에서 특별한 것을 찾고 있다면, 간단히 물어보세요.\n \n명동 근처에서 맛있는 순두부찌개 맛집을 찾고 싶다고요? ChatGPT가 즉시 리뷰와 평점을 포함한 최고 평점의 음식점 목록을 알려줄 거예요. 소중한 시간을 최대한 활용할 수 있겠죠?\n \n프롬프트 예시:\n[검색] 서울 강남역 근처 분위기 좋은 데이트 카페 추천해줘. 주차가 편한 곳으로 알려줘.\n[검색] 이번 주말 부산에서 열리는 문화 행사나 축제가 있을까?\n\n \n \nChatGPT 추론 기능: 깊이 있는 생각과 문제 해결이 필요할 때  \nChatGPT의 검색 기능이 빠르고 사실적인 답변에 좋다면, 추론 기능은 더 복잡한 작업에 진가를 발휘해요. 깊은 분석이나 창의적 사고가 필요한 까다로운 문제에 부딪혔을 때는 ChatGPT 추론의 문제 해결 능력을 활용하세요.\n\n\n복잡한 문제 해결  \n여러 계층을 분석하거나 다양한 옵션을 평가해야 하는 작업에는 ChatGPT의 추론 능력이 정말 소중해요. 사업 전략을 계획하거나 기술적인 문제를 해결할 때, ChatGPT는 다양한 각도를 탐색하고 정보에 기반한 결정을 내리는 데 도움을 줍니다.\n \n예를 들어, 스타트업을 위한 최적의 마케팅 전략을 결정하려 한다면, ChatGPT는 다양한 접근 방식의 장단점을 비교하고, 가능한 장애물을 고려하며, 유사한 사례 연구를 바탕으로 인사이트를 제공할 수 있어요. 단순히 빠른 사실만 제공하는 것이 아니라, 문제 해결을 위한 비판적 사고 과정을 안내해 줍니다.\n \n프롬프트 예시:\n[추론] 미용실 창업을 준비 중인데, 경쟁이 치열한 강남 지역에서 차별화된 마케팅 전략을 세우고 싶어. 소셜 미디어, 지역 특성, 타겟 고객층을 고려해서 구체적인 전략을 제안해줘.\n\n[추론] 우리 회사는 30명 규모의 소프트웨어 개발 스타트업인데, 재택근무와 사무실 근무를 어떻게 균형있게 조합할지 고민이야. 팀 문화, 생산성, 직원 만족도를 모두 고려한 하이브리드 근무 정책을 설계해줄 수 있을까?\n\n창의적 작업  \nChatGPT의 추론은 창의적인 브레인스토밍에도 훌륭한 선택이에요. 이 기능은 논리, 패턴, 관련 데이터를 활용하여 혁신적인 아이디어를 개발하거나 기존 아이디어를 개선하는 데 도움을 줍니다.\n \n소설 플롯에 막혔다면, ChatGPT가 창의적인 프롬프트, 캐릭터 아크, 또는 대체 엔딩을 제안할 수 있어요. 마찬가지로, 지역 커뮤니티 이벤트를 계획한다면, ChatGPT는 독특한 테마, 인터랙티브 활동, 또는 관객을 참여시키는 방법을 브레인스토밍하는 데 도움을 줄 수 있습니다.\n \n프롬프트 예시:\n[추론] 나는 현대판 판타지 소설을 쓰고 있어. 주인공은 평범한 대학생인데 어느날 자신이 꿈속에서 사람들의 병을 치유할 수 있는 능력이 있다는 걸 알게 돼. 이 설정을 바탕으로 흥미로운 플롯 전개와 갈등 요소를 제안해줘.\n\n[추론] 우리 동네 작은 도서관에서 아이들을 위한 여름 독서 프로그램을 기획 중이야. '바다와 모험'이라는 주제로 6-10세 아이들이 책에 흥미를 갖게 할 수 있는 창의적인 활동 아이디어를 5가지 제안해줘.\n\n논증 분석 또는 의사 결정 ⚖️\n여러 옵션과 많은 변수가 있는 결정에 직면했을 때, ChatGPT 추론은 필수적인 두 번째 의견이 됩니다. 추론 기능을 사용하면 각 선택지의 장단점을 분석하며 상황의 모든 측면을 고려할 수 있어요. 결정하기 어려운 순간에 균형 잡힌 선택을 할 수 있게 도와줍니다.\n예를 들어, 두 개의 채용 제안 중에서 고민하고 있다면, ChatGPT는 각 역할의 이점과 단점을 나열하는 데 도움을 줄 수 있어요. 회사 문화, 경력 성장, 보상, 일과 삶의 균형 같은 요소를 고려하도록 도와줍니다. 또한 ChatGPT는 여러분의 우선순위에 따라 대안 제안을 제공하여 의사 결정 과정을 더 쉽게 만들 수 있어요.\n \n프롬프트 예시:\n[추론] 현재 안정적인 대기업(연봉 7000)과 성장 가능성이 높은 스타트업(연봉 5500 + 스톡옵션)의 제안을 동시에 받았어. 경력 성장, 일-삶 균형, 재정적 안정성, 그리고 장기적 전망 측면에서 두 선택지를 분석해줘. 내 우선순위는 1) 성장 2) 안정성 3) 워라밸 순이야.\n\n[추론] 결혼식 장소로 자연 속 야외 웨딩과 고급 호텔 실내 웨딩 중에서 고민 중이야. 날씨 리스크, 비용, 접근성, 사진 퀄리티, 하객 편의성 등 다양한 요소를 비교 분석해줘. 우리는 5월에 결혼할 예정이고, 하객은 약 150명 정도야.\n\n복잡한 아이디어 설명  \n때로는 단순한 답변 이상이 필요할 때가 있죠. 복잡한 과학 개념, 고급 기술, 또는 이론을 이해하려고 할 때, ChatGPT의 추론 기능은 상세하게 설명해 줄 수 있어요.\n \n예를 들어, 블록체인이나 머신 러닝 같은 개념으로 고민하고 있다면, ChatGPT는 기본과 더 복잡한 측면 모두를 다루는 상세하고 쉽게 따라갈 수 있는 설명을 제공할 수 있습니다.\n \n프롬프트 예시:\n[추론] 양자컴퓨팅의 기본 원리를 고등학생 수준에서 이해할 수 있게 설명해줘. 특히 기존 컴퓨터와의 차이점과 왜 특정 문제에서 더 효율적인지 비유를 들어 설명해주면 좋겠어.\n\n[추론] ESG 경영이 정확히 무엇이고, 기업과 사회에 어떤 영향을 미치는지 체계적으로 분석해줘. 실제 성공 사례와 비판적 시각도 함께 다루어주면 좋겠어.\n\n \n \n두 기능을 모두 선택해야 할 때  \n사실과 깊은 분석 모두가 필요할 때가 있어요. 이런 상황에서는 ChatGPT의 검색과 추론 기능을 결합하면 더 완전하고 미묘한 그림을 얻을 수 있습니다.\n\n\nA). 주제를 자세히 이해하기  \n주제를 파고들어 원시 사실과 이들이 어떻게 연결되는지 이해하고 싶다면, ChatGPT의 검색과 추론 기능을 함께 사용하는 것이 좋아요. 이렇게 하면 구체적인 세부 정보를 수집하고 이를 더 큰 그림으로 통합할 수 있습니다.\n예를 들어, 우주 탐사에 대해 연구한다면, 최신 임무, 기술, 발견을 검색하면서 동시에 이들이 사회에 미칠 잠재적 영향에 대해 추론할 수 있어요. 이렇게 하면 사실만 수집하는 것이 아니라, 그것들이 인간 지식, 우주 여행, 미래 노력에 미치는 영향도 한꺼번에 평가할 수 있습니다.\n \n프롬프트 예시:\n[검색+추론] 최근 5년간 우주 개발 동향과 주요 발전 사항을 검색해주고, 이러한 발전이 향후 10년 내 지구 경제와 과학 기술에 미칠 영향을 종합적으로 분석해줘.\n\n[검색+추론] 현재 글로벌 반도체 산업의 주요 기업들과 시장 점유율을 조사하고, 미-중 기술 갈등이 장기적으로 반도체 공급망과 한국 기업들에게 어떤 영향을 미칠지 전망해줘.\n\nB). 여러 변수가 있는 결정 내리기  \n집 구매, 특정 소프트웨어 선택, 또는 휴가 목적지 선택과 같이 여러 옵션이나 요소를 고려해야 하는 상황에서는 검색과 추론이 모두 필요해요. 검색 기능은 각 옵션에 대한 하드 사실(비용, 기능, 리뷰)을 수집하고, 추론 기능은 장단점을 평가하여 특정 요구 사항에 가장 잘 맞는 선택을 내릴 수 있게 합니다.\n \n새로운 도시로 이사를 고려하고 있다면, 주택 가격, 지역 편의 시설, 취업 기회를 조사하고 싶을 거예요. 동시에, 도시의 미적 감각, 라이프스타일, 가족이나 친구와의 거리 같은 추상적인 변수도 고려해야 합니다. 이러한 요소들을 개인 선호도와 결합하면 이사가 적합한지 파악하는 데 도움이 됩니다.\n \n프롬프트 예시:\n[검색+추론] 제주도와 부산에 1년 살 예정인데 두 도시를 비교해줘. 주거비용, 생활물가, 기후, 교통, 의료시설, 문화생활 등 객관적 데이터를 찾아주고, 30대 부부가 디지털 노마드로 살기에 어떤 곳이 더 적합할지 분석해줘.\n\n[검색+추론] 아이패드 프로와 삼성 갤럭시 탭 S9 울트라의 최신 스펙, 가격, 호환 액세서리를 비교해주고, 디지털 아트 작업과 영상 편집이 주 용도인 나에게 어떤 제품이 더 적합할지 분석해줘.\n\nC). 여러 옵션이나 제품 비교하기  \n제품, 서비스, 심지어 경력 경로를 비교할 때, 검색과 추론을 모두 사용하면 좋아요. 검색은 객관적인 사실을 제공하고, 추론은 어떤 옵션이 개인 또는 전문적 목표에 가장 적합한지 평가하거나 해당 제품에 대한 최신 정보를 얻는 데 도움을 줍니다.\n예를 들어, 두 노트북 중에서 고르고 있다면, 스펙과 리뷰를 확인하고(검색), 옵션을 신중히 평가해야 합니다(추론). 어떤 게 예산, 라이프스타일, 미래 필요에 맞을까요? 두 기능을 모두 활용하면 최종 결정을 내리는 데 도움이 될 수 있어요.\n \n프롬프트 예시:\n[검색+추론] 애플 맥북 프로 M2와 델 XPS 15의 최신 사양, 가격, 배터리 성능, 화면 품질을 비교해줘. 특히 영상 편집과 코딩을 주로 하는 내게 어떤 노트북이 더 적합할지 분석해줘.\n\n[검색+추론] 넷플릭스, 디즈니플러스, 티빙의 월 구독료, 콘텐츠 라이브러리 크기, 독점 콘텐츠를 비교해주고, 한국 드라마와 다큐멘터리를 주로 보는 내게 가장 가성비 좋은 서비스는 무엇인지 추천해줘.\n\nD). 새로운 개념이나 트렌드 탐색하기  \n검색과 추론을 함께 활용하면 새로운 개념이나 떠오르는 트렌드를 이해하는 데 도움이 될 수 있어요. 검색은 최신 정보를 수집하고, 추론은 잠재적 영향과 더 넓은 의미를 탐색합니다.\n예를 들어, 인공지능에 대해 궁금하다면, 검색을 사용하여 AI의 최신 발전 상황을 찾고, 추론을 사용하여 AI가 다양한 산업에 어떤 영향을 미치거나 미래에 우리 삶의 방식을 어떻게 변화시킬지 분석할 수 있습니다.\n \n프롬프트 예시:\n[검색+추론] 웹3.0과 메타버스의 최신 발전 동향과 주요 플랫폼들을 조사해주고, 이러한 기술이 향후 5년 내 교육, 엔터테인먼트, 소매업에 어떤 변화를 가져올지 분석해줘.\n\n[검색+추론] '제로 웨이스트' 라이프스타일의 주요 원칙과 글로벌 트렌드를 조사해주고, 이를 한국의 도시 환경에서 실천하기 위한 현실적인 방법과 도전 과제를 분석해줘.\n\n \n\n\n마치며: 상황에 맞는 선택이 중요해요  \nChatGPT의 검색 기능과 추론 기능을 언제 사용해야 할지 이해함으로써, 이러한 강력한 기능의 가치를 최대화할 수 있어요. 빠른 사실, 깊은 분석, 또는 둘 다 필요하든, ChatGPT는 거의 모든 결정을 내리고 문제에 명확하게 접근하는 데 도움을 줄 수 있으며, 종종 해당 작업에 대한 정말 유용한 두 번째 의견이나 목소리를 제공합니다.\n제 경우에는 일상적인 정보 검색에는 검색 기능을, 블로그 글이나 사업 계획처럼 깊은 사고가 필요한 일에는 추론 기능을 주로 사용하고 있어요. 여러분은 어떤 기능을 더 자주 사용하시나요? 댓글로 알려주세요!  \nQ&A: ChatGPT 검색과 추론에 대해 자주 묻는 질문들\nQ: ChatGPT 검색 기능은 얼마나 최신 정보까지 알고 있나요?\nA: 검색 기능은 인터넷에 연결되어 있어 최신 정보를 가져옵니다.\nQ: 추론 기능의 한계는 무엇인가요?\nA: 복잡한 추론이 가능하지만 전문가 수준의 깊이 있는 분석은 제한적일 수 있어요.\nQ: 검색과 추론을 동시에 사용할 때 더 느려지나요?\nA: 약간 더 시간이 걸릴 수 있지만 결과의 질이 높아져 가치가 있습니다.\nQ: 어떤 기능이 더 정확한가요?\nA: 사실 확인은 검색이, 복잡한 분석은 추론이 더 정확합니다.\nQ: 추론 기능은 검색 기능보다 창의적인가요?\nA: 네, 추론 기능이 패턴 인식과 연결성을 활용해 더 창의적인 결과를 제공합니다.\n\n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"ChatGPT 검색 기능은 얼마나 최신 정보까지 알고 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"검색 기능은 인터넷에 연결되어 있어 최신 정보를 가져옵니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"추론 기능의 한계는 무엇인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"복잡한 추론이 가능하지만 전문가 수준의 깊이 있는 분석은 제한적일 수 있어요.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"검색과 추론을 동시에 사용할 때 더 느려지나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"약간 더 시간이 걸릴 수 있지만 결과의 질이 높아져 가치가 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"어떤 기능이 더 정확한가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"사실 확인은 검색이, 복잡한 분석은 추론이 더 정확합니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"추론 기능은 검색 기능보다 창의적인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 추론 기능이 패턴 인식과 연결성을 활용해 더 창의적인 결과를 제공합니다.\"\n      }\n    }\n  ]\n}",
        "guid": "http://muzbox.tistory.com/483567",
        "categories": [
          "AI, 미래기술/AI 챗봇 및 언어 모델",
          "ai 기능 비교",
          "ai 창의적 활용",
          "chatgpt 검색 기능",
          "chatgpt 추론 기능",
          "문제 해결 ai",
          "복잡한 문제 해결",
          "의사결정 도구",
          "인공지능 활용법",
          "정보 검색 최적화",
          "최신 정보 검색"
        ],
        "isoDate": "2025-04-11T03:01:03.000Z"
      }
    ]
  },
  {
    "name": "동우리의 블로그",
    "category": "개인",
    "posts": []
  },
  {
    "name": "하테나",
    "category": "개인",
    "posts": []
  },
  {
    "name": "늑돌이네 라지온",
    "category": "개인",
    "posts": []
  },
  {
    "name": "루리웹 - 루리웹 리뷰 게시판",
    "category": "게임",
    "posts": [
      {
        "creator": "｜RULIWEB｜",
        "title": "허벅지를 기회로, 유미아의 아틀리에",
        "link": "https://bbs.ruliweb.com/news/board/11/read/2298",
        "pubDate": "Fri, 11 Apr 2025 22:42:23 +0900",
        "author": "｜RULIWEB｜",
        "content": "<img width=\"236\" height=\"177\" src=\"https://i1.ruliweb.com/thumb/25/04/11/1962515400551ad6b.png\">",
        "contentSnippet": "",
        "categories": [
          "게임툰"
        ],
        "isoDate": "2025-04-11T13:42:23.000Z"
      },
      {
        "creator": "｜RULIWEB｜",
        "title": "우리는 빛을 섬기는 그림자다, 어쌔신 크리드 섀도우스",
        "link": "https://bbs.ruliweb.com/news/board/11/read/2297",
        "pubDate": "Fri, 11 Apr 2025 22:25:49 +0900",
        "author": "｜RULIWEB｜",
        "content": "<img width=\"236\" height=\"177\" src=\"https://i2.ruliweb.com/thumb/25/04/11/19625055fd551ad6b.png\">",
        "contentSnippet": "",
        "categories": [
          "게임툰"
        ],
        "isoDate": "2025-04-11T13:25:49.000Z"
      },
      {
        "creator": "［RULIWEB］",
        "title": "[NS] 더욱 완성되어 돌아온 미지로의 경험, 제노블레이드 크로스 DE",
        "link": "https://bbs.ruliweb.com/news/board/11/read/2296",
        "pubDate": "Fri, 11 Apr 2025 17:30:38 +0900",
        "author": "［RULIWEB］",
        "content": "<img width=\"236\" height=\"177\" src=\"https://i3.ruliweb.com/thumb/25/04/11/19623f858fb5104c1.jpg\">",
        "contentSnippet": "",
        "categories": [
          "리뷰"
        ],
        "isoDate": "2025-04-11T08:30:38.000Z"
      }
    ]
  },
  {
    "name": "Reasontobe",
    "category": "개인",
    "posts": []
  },
  {
    "name": "자유로운 생활",
    "category": "개인",
    "posts": []
  },
  {
    "name": "에스티마의 인터넷이야기 EstimaStory.com",
    "category": "개인",
    "posts": []
  },
  {
    "name": "나긋한 개발 - 데비안 리눅스와 프로그램 언어",
    "category": "개인",
    "posts": []
  },
  {
    "name": "일상을 여행처럼...",
    "category": "개인",
    "posts": []
  },
  {
    "name": "Just hack'em",
    "category": "개인",
    "posts": []
  },
  {
    "name": "C++ Truths",
    "category": "개인",
    "posts": []
  },
  {
    "name": "jacking75",
    "category": "개인",
    "posts": [
      {
        "title": "Visual Studio의 새로운 생산성 기능",
        "link": "https://jacking75.github.io/VS_20250416/",
        "pubDate": "Wed, 16 Apr 2025 00:00:00 +0900",
        "content": "<iframe width=\"1024\" height=\"1024\" src=\"https://docs.google.com/document/d/e/2PACX-1vTFg-bDiBWKSwkueR7UvfuAMhDRF9h-zLESCpCfJcleZlR4uNBrol_bOGeRN5Q6S7_l0EAozlgEncZG/pub?embedded=true\"></iframe>\n\n",
        "contentSnippet": "",
        "guid": "https://jacking75.github.io/VS_20250416/",
        "isoDate": "2025-04-15T15:00:00.000Z"
      },
      {
        "title": "DeepSeek-R1 로컬 실행 시 추천 모델(증류 모델)",
        "link": "https://jacking75.github.io/ai-llm_20250414/",
        "pubDate": "Mon, 14 Apr 2025 00:00:00 +0900",
        "content": "<iframe width=\"1024\" height=\"1024\" src=\"https://docs.google.com/document/d/e/2PACX-1vSIHfVUr4Phd-5HYiJu2sxaXF_WcjAXP2sgE9NzFk8OvawOBJC53dnCLlJtRj8SNUpmxDuM1seDAa6s/pub?embedded=true\"></iframe>\n\n",
        "contentSnippet": "",
        "guid": "https://jacking75.github.io/ai-llm_20250414/",
        "isoDate": "2025-04-13T15:00:00.000Z"
      }
    ]
  },
  {
    "name": "Joel on Software",
    "category": "개인",
    "posts": []
  },
  {
    "name": "벤자민로그",
    "category": "개인",
    "posts": []
  },
  {
    "name": "악보쓰는 프로그래머",
    "category": "개인",
    "posts": []
  },
  {
    "name": "쭌안아빠",
    "category": "개인",
    "posts": []
  },
  {
    "name": "A Gangster World",
    "category": "개인",
    "posts": []
  },
  {
    "name": "요우의 내맘대로 블로그",
    "category": "개인",
    "posts": []
  },
  {
    "name": "개발자스럽다",
    "category": "큐레이션",
    "posts": []
  },
  {
    "name": "Against All Odds.",
    "category": "개인",
    "posts": []
  },
  {
    "name": "움직이는 게임서버",
    "category": "개인",
    "posts": []
  },
  {
    "name": "이상욱",
    "category": "개인",
    "posts": []
  },
  {
    "name": "임철재",
    "category": "개인",
    "posts": []
  },
  {
    "name": "어쩐지 오늘은",
    "category": "개인",
    "posts": []
  },
  {
    "name": "oddpoet’s étude",
    "category": "개인",
    "posts": []
  },
  {
    "name": "0x00 - NULL",
    "category": "개인",
    "posts": []
  },
  {
    "name": "퇴근 후 서버다운",
    "category": "개인",
    "posts": [
      {
        "creator": "SIDNFT",
        "title": "게임 광고 300만원 태운 개발자 스토리",
        "link": "http://serverdown.tistory.com/1270",
        "pubDate": "Thu, 17 Apr 2025 16:20:25 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1270#entry1270comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"225\" data-origin-height=\"225\"><span data-url=\"https://blog.kakaocdn.net/dn/mJi32/btsNpo6VAcy/qTS1Wp0WcYIkA7Wd2uHXK0/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/mJi32/btsNpo6VAcy/qTS1Wp0WcYIkA7Wd2uHXK0/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/mJi32/btsNpo6VAcy/qTS1Wp0WcYIkA7Wd2uHXK0/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmJi32%2FbtsNpo6VAcy%2FqTS1Wp0WcYIkA7Wd2uHXK0%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"225\" height=\"225\" data-origin-width=\"225\" data-origin-height=\"225\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://www.youtube.com/watch?v=oIWW0aJHGaQ\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=oIWW0aJHGaQ</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=oIWW0aJHGaQ\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/TELyx/hyYIj6ssHh/3v0pJlEFsmmE0zv2glzsMk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/b9Sx1o/hyYIahnjdc/rOe2vMITtAWZ3HHMDuNLr1/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"게임 앱 만들어서 300만원 광고해보기 [EP 25]\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/oIWW0aJHGaQ\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">제 이야기는 아니고 영상 이야기</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">중요한것은&nbsp;</p>\n<p data-ke-size=\"size16\">광고를 태워야해서 홍보페이지를 만들어야합니다.</p>\n<p data-ke-size=\"size16\">미리미리 영상을 잘 준비해둬야한다는 뜻입니다.</p>\n<p data-ke-size=\"size16\">광고를 하든 안하든 멋진 연출이이 나오도록 만들어야겠습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "영상: https://www.youtube.com/watch?v=oIWW0aJHGaQ\n\n\n\n \n제 이야기는 아니고 영상 이야기\n \n중요한것은 \n광고를 태워야해서 홍보페이지를 만들어야합니다.\n미리미리 영상을 잘 준비해둬야한다는 뜻입니다.\n광고를 하든 안하든 멋진 연출이이 나오도록 만들어야겠습니다.",
        "guid": "http://serverdown.tistory.com/1270",
        "categories": [
          "프로그래밍/개발메모"
        ],
        "isoDate": "2025-04-17T07:20:25.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "Brick Away / 블록분해 v1 게임 제작 시작",
        "link": "http://serverdown.tistory.com/1269",
        "pubDate": "Thu, 17 Apr 2025 15:45:56 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1269#entry1269comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"512\" data-origin-height=\"512\"><span data-url=\"https://blog.kakaocdn.net/dn/cWhjbX/btsNmHeIczZ/Qgw6luFF7rBmHwsQeiHkt0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cWhjbX/btsNmHeIczZ/Qgw6luFF7rBmHwsQeiHkt0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cWhjbX/btsNmHeIczZ/Qgw6luFF7rBmHwsQeiHkt0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcWhjbX%2FbtsNmHeIczZ%2FQgw6luFF7rBmHwsQeiHkt0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"512\" height=\"512\" data-origin-width=\"512\" data-origin-height=\"512\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">갑자기 만들고 싶어졌습니다.</p>\n<p data-ke-size=\"size16\">기존에 Tap Away 가 그래픽이 밝아서 제 눈이 아파서 불편사항을 고쳐보려고</p>\n<p data-ke-size=\"size16\">만들기 시작했습니다.</p>\n<p data-ke-size=\"size16\">여기까지 만드는데 4시간 정도 걸린거 같군요</p>\n<p data-ke-size=\"size16\">시간 잘 가네</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://www.youtube.com/watch?v=KgW9pFfxSJA\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=KgW9pFfxSJA</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=KgW9pFfxSJA\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/cbNrBD/hyYIfXhRaw/HQk5SBDC7ZkrCpriDdIQI1/img.jpg?width=480&amp;height=360&amp;face=0_0_480_360,https://scrap.kakaocdn.net/dn/szEpP/hyYFx5oAUC/OyYIyKwsMB0VGeifTLgii0/img.jpg?width=480&amp;height=360&amp;face=0_0_480_360\" data-video-width=\"480\" data-video-height=\"360\" data-video-origin-width=\"480\" data-video-origin-height=\"360\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"brick away v1\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/KgW9pFfxSJA\" width=\"480\" height=\"360\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">별로 만들어진게 없습니다.&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">플레이:&nbsp; <a href=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1</a></p>\n<figure id=\"og_1744871969875\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"Brick Away V1 on Unity Play\" data-og-description=\"touch brick\" data-og-host=\"play.unity.com\" data-og-source-url=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\" data-og-url=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\" data-og-image=\"https://scrap.kakaocdn.net/dn/eD9g4/hyYIb8qipm/3KwknF0cKVuaIWfUfkkkaK/img.png?width=512&amp;height=512&amp;face=0_0_512_512,https://scrap.kakaocdn.net/dn/c3QxpG/hyYFFWDwEX/2dVkEIJKybPWSv8IPaaGK1/img.png?width=512&amp;height=512&amp;face=0_0_512_512\"><a href=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/eD9g4/hyYIb8qipm/3KwknF0cKVuaIWfUfkkkaK/img.png?width=512&amp;height=512&amp;face=0_0_512_512,https://scrap.kakaocdn.net/dn/c3QxpG/hyYFFWDwEX/2dVkEIJKybPWSv8IPaaGK1/img.png?width=512&amp;height=512&amp;face=0_0_512_512');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">Brick Away V1 on Unity Play</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">touch brick</p>\n<p class=\"og-host\" data-ke-size=\"size16\">play.unity.com</p>\n</div>\n</a></figure>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "갑자기 만들고 싶어졌습니다.\n기존에 Tap Away 가 그래픽이 밝아서 제 눈이 아파서 불편사항을 고쳐보려고\n만들기 시작했습니다.\n여기까지 만드는데 4시간 정도 걸린거 같군요\n시간 잘 가네\n \n영상: https://www.youtube.com/watch?v=KgW9pFfxSJA\n\n\n\n별로 만들어진게 없습니다. \n \n플레이:  https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\n\n \nBrick Away V1 on Unity Play\ntouch brick\nplay.unity.com",
        "guid": "http://serverdown.tistory.com/1269",
        "categories": [
          "블록 분해 게임 (자작)"
        ],
        "isoDate": "2025-04-17T06:45:56.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "Unbeatable Network / 갓챠맨 크라우즈 Gatchaman Crowds / 애니 음악 / OST",
        "link": "http://serverdown.tistory.com/1268",
        "pubDate": "Thu, 17 Apr 2025 14:56:49 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1268#entry1268comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"686\" data-origin-height=\"386\"><span data-url=\"https://blog.kakaocdn.net/dn/uyG8r/btsNpq4wnMF/Ngd0L7D3L3RUNYhZYcR6oK/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/uyG8r/btsNpq4wnMF/Ngd0L7D3L3RUNYhZYcR6oK/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/uyG8r/btsNpq4wnMF/Ngd0L7D3L3RUNYhZYcR6oK/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuyG8r%2FbtsNpq4wnMF%2FNgd0L7D3L3RUNYhZYcR6oK%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"686\" height=\"386\" data-origin-width=\"686\" data-origin-height=\"386\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">와 지금보니 11년 전 곡이군요</p>\n<p data-ke-size=\"size16\">갓챠맨 크라우즈 애니에 들어간 브금이라고 하는데</p>\n<p data-ke-size=\"size16\">당시엔 눈에 들어오지도 않던 애니이고 진행도&nbsp; 내용도 좀 이상한 애니였습니다.</p>\n<p data-ke-size=\"size16\">가차맨 붙으면 보통 독수리 오형제 가 나왔는데</p>\n<p data-ke-size=\"size16\">좀 다른 컨셉으로 나왔습니다.</p>\n<p data-ke-size=\"size16\">외게인이 나오고 신비한 힘으로 그걸 막는 사람들이 5명 나오나 그랬던거 같습니다.</p>\n<p data-ke-size=\"size16\">능력도 내용도 이해도 안되었던건 기억이 나고</p>\n<p data-ke-size=\"size16\">비주얼 퀄리티가 놓았습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">비슷한 시기에 취성의 가르간티아도 나왔는데</p>\n<p data-ke-size=\"size16\">그것은 매우 추천하는 작품입니다. 모든면에서 뛰어났었죠</p>\n<p data-ke-size=\"size16\">당시에 어떤 경쟁장 때문에 묻혔던거 같은데 그게 무었인지 기억에 없네요 뭔가 역사적인게 같이 나왔던거 같은데 ...</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">아래는 <span style=\"text-align: start;\">갓챠맨 크라우즈 애니에서 유일하게 건진 브금인데 좋습니다.</span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">표지가 사람 머리였군요 멀리서보니 파도 치는 바다 금인가 했는데</span></p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">원본 영상: <a href=\"https://www.youtube.com/watch?v=Z-vtOKppCjc\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=Z-vtOKppCjc</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=Z-vtOKppCjc\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/3kLJJ/hyYIizHBuU/mhd3ABoR3P6GNzaTuwaf2k/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/bpkFV1/hyYH8jyu8n/0E4hL6FpKJKu5QNQ0II0bk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"Gatchaman Crowds OST (Full) - 20 Unbeatable Network\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/Z-vtOKppCjc\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">피아노 영상: <a href=\"https://www.youtube.com/watch?v=YmTgA-QZk1k\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=YmTgA-QZk1k</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=YmTgA-QZk1k\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/8epQ7/hyYIkddtd1/IVCY9SQ8GAyz8cpQ9ItjCk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/d1DHNU/hyYG67RppG/Aa4AMCOVikEduMzYIf7KyK/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"Unbeatable Network - Gatchaman Crowds OST [Piano]\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/YmTgA-QZk1k\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "와 지금보니 11년 전 곡이군요\n갓챠맨 크라우즈 애니에 들어간 브금이라고 하는데\n당시엔 눈에 들어오지도 않던 애니이고 진행도  내용도 좀 이상한 애니였습니다.\n가차맨 붙으면 보통 독수리 오형제 가 나왔는데\n좀 다른 컨셉으로 나왔습니다.\n외게인이 나오고 신비한 힘으로 그걸 막는 사람들이 5명 나오나 그랬던거 같습니다.\n능력도 내용도 이해도 안되었던건 기억이 나고\n비주얼 퀄리티가 놓았습니다.\n \n비슷한 시기에 취성의 가르간티아도 나왔는데\n그것은 매우 추천하는 작품입니다. 모든면에서 뛰어났었죠\n당시에 어떤 경쟁장 때문에 묻혔던거 같은데 그게 무었인지 기억에 없네요 뭔가 역사적인게 같이 나왔던거 같은데 ...\n \n아래는 갓챠맨 크라우즈 애니에서 유일하게 건진 브금인데 좋습니다.\n표지가 사람 머리였군요 멀리서보니 파도 치는 바다 금인가 했는데\n \n원본 영상: https://www.youtube.com/watch?v=Z-vtOKppCjc\n\n\n\n \n \n피아노 영상: https://www.youtube.com/watch?v=YmTgA-QZk1k",
        "guid": "http://serverdown.tistory.com/1268",
        "categories": [
          "유튜브"
        ],
        "isoDate": "2025-04-17T05:56:49.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "기동전사 건담 지쿠악스 나왔군요 / 애니",
        "link": "http://serverdown.tistory.com/1267",
        "pubDate": "Thu, 17 Apr 2025 14:00:37 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1267#entry1267comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"200\" data-origin-height=\"282\"><span data-url=\"https://blog.kakaocdn.net/dn/wfFSI/btsNldZBaTS/wt9QtV5xs3g6GEW1RTiZN1/img.webp\" data-phocus=\"https://blog.kakaocdn.net/dn/wfFSI/btsNldZBaTS/wt9QtV5xs3g6GEW1RTiZN1/img.webp\"><img src=\"https://blog.kakaocdn.net/dn/wfFSI/btsNldZBaTS/wt9QtV5xs3g6GEW1RTiZN1/img.webp\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FwfFSI%2FbtsNldZBaTS%2Fwt9QtV5xs3g6GEW1RTiZN1%2Fimg.webp\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"200\" height=\"282\" data-origin-width=\"200\" data-origin-height=\"282\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"1184\" data-origin-height=\"421\"><span data-url=\"https://blog.kakaocdn.net/dn/cu4Yqs/btsNo6yqzhS/4mnAGQ1aR8fvgIk4JvsYj1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cu4Yqs/btsNo6yqzhS/4mnAGQ1aR8fvgIk4JvsYj1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cu4Yqs/btsNo6yqzhS/4mnAGQ1aR8fvgIk4JvsYj1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcu4Yqs%2FbtsNo6yqzhS%2F4mnAGQ1aR8fvgIk4JvsYj1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"1184\" height=\"421\" data-origin-width=\"1184\" data-origin-height=\"421\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">나왔군요 티비판</p>\n<p data-ke-size=\"size16\">이거 이름을 어떻게 쓰는지가 궁금했는데</p>\n<p data-ke-size=\"size16\">지쿠악스 군요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">건담이긴한데 에반게리온으로 유명한 안노히데아키 가 참여했고</p>\n<p data-ke-size=\"size16\">감독은 다른 사람입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">안노는 워낙 유명하지만 이분이 확장에 강하지만 마무리가 안되는 문제가 있다고 합니다.</p>\n<p data-ke-size=\"size16\">감독은 그 일을 마무리할 사람으로 보이구요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">츠루마키 카즈야 : <a href=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC</a></p>\n<figure id=\"og_1744865987716\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"article\" data-og-title=\"츠루마키 카즈야\" data-og-description=\"일본 애니메이션 감독 겸 애니메이터 이자 기업인 . 現 스튜디오 카라 의 이사직을 맡고 있다. 애칭은 맛\" data-og-host=\"namu.wiki\" data-og-source-url=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\" data-og-url=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\" data-og-image=\"https://scrap.kakaocdn.net/dn/badVUW/hyYG1yJJ9i/SbVkbi0mUFyQsRBj6OlZk0/img.jpg?width=260&amp;height=390&amp;face=63_116_179_243\"><a href=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/badVUW/hyYG1yJJ9i/SbVkbi0mUFyQsRBj6OlZk0/img.jpg?width=260&amp;height=390&amp;face=63_116_179_243');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">츠루마키 카즈야</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">일본 애니메이션 감독 겸 애니메이터 이자 기업인 . 現 스튜디오 카라 의 이사직을 맡고 있다. 애칭은 맛</p>\n<p class=\"og-host\" data-ke-size=\"size16\">namu.wiki</p>\n</div>\n</a></figure>\n<p data-ke-size=\"size16\">역사에 남을 사람이니 미리 기억해 둡시다.</p>\n<p data-ke-size=\"size16\">아직은 이름이 잘 알려지진 않은거 같군요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "나왔군요 티비판\n이거 이름을 어떻게 쓰는지가 궁금했는데\n지쿠악스 군요\n \n건담이긴한데 에반게리온으로 유명한 안노히데아키 가 참여했고\n감독은 다른 사람입니다.\n \n안노는 워낙 유명하지만 이분이 확장에 강하지만 마무리가 안되는 문제가 있다고 합니다.\n감독은 그 일을 마무리할 사람으로 보이구요\n \n츠루마키 카즈야 : https://namu.wiki/w/%EC%B8%A0%EB%A3%A8%EB%A7%88%ED%82%A4%20%EC%B9%B4%EC%A6%88%EC%95%BC\n\n \n츠루마키 카즈야\n일본 애니메이션 감독 겸 애니메이터 이자 기업인 . 現 스튜디오 카라 의 이사직을 맡고 있다. 애칭은 맛\nnamu.wiki\n\n역사에 남을 사람이니 미리 기억해 둡시다.\n아직은 이름이 잘 알려지진 않은거 같군요",
        "guid": "http://serverdown.tistory.com/1267",
        "categories": [
          "유튜브",
          "건담",
          "애니"
        ],
        "isoDate": "2025-04-17T05:00:37.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "node.js 대신에 bun (번) 사용합니다.",
        "link": "http://serverdown.tistory.com/1266",
        "pubDate": "Thu, 17 Apr 2025 13:17:49 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1266#entry1266comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"300\" data-origin-height=\"168\"><span data-url=\"https://blog.kakaocdn.net/dn/cMD3kI/btsNnU6NjF2/P4w3er5peRZWhH0ssBwSYK/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cMD3kI/btsNnU6NjF2/P4w3er5peRZWhH0ssBwSYK/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cMD3kI/btsNnU6NjF2/P4w3er5peRZWhH0ssBwSYK/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcMD3kI%2FbtsNnU6NjF2%2FP4w3er5peRZWhH0ssBwSYK%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"300\" height=\"168\" data-origin-width=\"300\" data-origin-height=\"168\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">node 실행 명령어 보다 빠르게 typescript 를 실행할 수 있는&nbsp;</p>\n<p data-ke-size=\"size16\">bun 을 사용하고 있습니다.</p>\n<p data-ke-size=\"size16\">어차피 동작도 동일하고 nodemon 같은 watch 기능도 포함되어있습니다.</p>\n<p data-ke-size=\"size16\">안쓸이유가 없슴니다.</p>\n<p data-ke-size=\"size16\">애플코딩 설명: <a href=\"https://www.youtube.com/watch?v=a8uPDppckQk\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=a8uPDppckQk</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=a8uPDppckQk\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/brPJCD/hyYH5AlMhC/CslKoPWj5Zz3gZMndtqXu1/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/JpY8F/hyYIahmeML/Awz8k5lKQaUGq51KKEVKzk/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"Bun 서버가 4배 빠르다는건 진짜인가 (vs Node.js)\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/a8uPDppckQk\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">이 영상이 나올때는 1.0 이였고 지금은 2.0 인거 같습니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">설명글에는 node&nbsp; 는 오래된 언어로 개발되어있구요</p>\n<p data-ke-size=\"size16\">bun 은 한세대 건너뛴 방법으로 다시 개발되었습니다.</p>\n<p data-ke-size=\"size16\">특히 typescript 를 컴파일 시간없이 돌리기 때문에 빠르게 실행이 가능합니다.</p>\n<h2 style=\"background-color: #000000; color: #000000;\" data-ke-size=\"size26\"><br />설치방법</h2>\n<p style=\"background-color: #000000; color: #000000;\" data-ke-size=\"size16\">설치문서:<span style=\"background-color: #000000; color: #000000;\">&nbsp;</span><a href=\"https://bun.sh/docs/installation\">https://bun.sh/docs/installation</a></p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"423\" data-origin-height=\"272\"><span data-url=\"https://blog.kakaocdn.net/dn/dDctPI/btsNpqJtgSY/kbMcvWGw2RwdUvJJFKK8L0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/dDctPI/btsNpqJtgSY/kbMcvWGw2RwdUvJJFKK8L0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/dDctPI/btsNpqJtgSY/kbMcvWGw2RwdUvJJFKK8L0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdDctPI%2FbtsNpqJtgSY%2FkbMcvWGw2RwdUvJJFKK8L0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"423\" height=\"272\" data-origin-width=\"423\" data-origin-height=\"272\"/></span></figure>\n</p>\n<p style=\"background-color: #000000; color: #000000;\" data-ke-size=\"size16\">npm 으로도 설치가능합니다.</p>\n<p style=\"background-color: #000000; color: #000000;\" data-ke-size=\"size16\">문저에 제공하는 방식으로 설치하세요</p>\n<p style=\"background-color: #000000; color: #000000;\" data-ke-size=\"size16\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"672\" data-origin-height=\"176\"><span data-url=\"https://blog.kakaocdn.net/dn/cBs1JB/btsNmGzWGmt/k91v6KokR2uyXdWqOSDnRk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cBs1JB/btsNmGzWGmt/k91v6KokR2uyXdWqOSDnRk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cBs1JB/btsNmGzWGmt/k91v6KokR2uyXdWqOSDnRk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcBs1JB%2FbtsNmGzWGmt%2Fk91v6KokR2uyXdWqOSDnRk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"672\" height=\"176\" data-origin-width=\"672\" data-origin-height=\"176\"/></span></figure>\n</p>\n<p style=\"background-color: #000000; color: #000000;\" data-ke-size=\"size16\">저도 이번에 업데이트 했습니다.</p>\n<p style=\"background-color: #000000; color: #000000;\" data-ke-size=\"size16\">1.1.26 -&gt; 1.2.9&nbsp;</p>\n<p style=\"background-color: #000000; color: #000000;\" data-ke-size=\"size16\">업그레이드가 잘 되고 있는 프로젝트 군요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\">실행망법</h2>\n<p style=\"background-color: #000000; color: #000000; text-align: start;\" data-ke-size=\"size16\">node index.ts&nbsp;</p>\n<p style=\"background-color: #000000; color: #000000; text-align: start;\" data-ke-size=\"size16\">대신에</p>\n<p style=\"background-color: #000000; color: #000000; text-align: start;\" data-ke-size=\"size16\">bun index.ts&nbsp;</p>\n<p style=\"background-color: #000000; color: #000000; text-align: start;\" data-ke-size=\"size16\">를 하면 되는거라 어려운 것도 없습니다.</p>\n<p style=\"background-color: #000000; color: #000000; text-align: start;\" data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"background-color: #000000; color: #000000; text-align: start;\" data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\">감시모드 watch</h2>\n<p data-ke-size=\"size16\">문서링크: <a href=\"https://bun.sh/docs/runtime/hot\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://bun.sh/docs/runtime/hot</a></p>\n<p data-ke-size=\"size16\">감시모드는 소스가 변경되면 재실행 시켜주는 기능이구요</p>\n<p data-ke-size=\"size16\">nodemon 으로 이런기능을 사용하셨는데&nbsp;</p>\n<p data-ke-size=\"size16\">bun 은 내장되어있습니다.</p>\n<p data-ke-size=\"size16\">명령어는</p>\n<p data-ke-size=\"size16\">bun --watch index.ts&nbsp;</p>\n<p data-ke-size=\"size16\">입니다.</p>\n<p data-ke-size=\"size16\">소스가 변경되면 재실행 해줍니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\">결론</h2>\n<p data-ke-size=\"size16\">시간 아낄 수 있으니 쓰세요</p>",
        "contentSnippet": "node 실행 명령어 보다 빠르게 typescript 를 실행할 수 있는 \nbun 을 사용하고 있습니다.\n어차피 동작도 동일하고 nodemon 같은 watch 기능도 포함되어있습니다.\n안쓸이유가 없슴니다.\n애플코딩 설명: https://www.youtube.com/watch?v=a8uPDppckQk\n\n\n\n이 영상이 나올때는 1.0 이였고 지금은 2.0 인거 같습니다.\n \n설명글에는 node  는 오래된 언어로 개발되어있구요\nbun 은 한세대 건너뛴 방법으로 다시 개발되었습니다.\n특히 typescript 를 컴파일 시간없이 돌리기 때문에 빠르게 실행이 가능합니다.\n설치방법\n설치문서: https://bun.sh/docs/installation\n\n\nnpm 으로도 설치가능합니다.\n문저에 제공하는 방식으로 설치하세요\n \n\n\n저도 이번에 업데이트 했습니다.\n1.1.26 -> 1.2.9 \n업그레이드가 잘 되고 있는 프로젝트 군요\n \n실행망법\nnode index.ts \n대신에\nbun index.ts \n를 하면 되는거라 어려운 것도 없습니다.\n \n \n \n감시모드 watch\n문서링크: https://bun.sh/docs/runtime/hot\n감시모드는 소스가 변경되면 재실행 시켜주는 기능이구요\nnodemon 으로 이런기능을 사용하셨는데 \nbun 은 내장되어있습니다.\n명령어는\nbun --watch index.ts \n입니다.\n소스가 변경되면 재실행 해줍니다.\n \n \n \n결론\n시간 아낄 수 있으니 쓰세요",
        "guid": "http://serverdown.tistory.com/1266",
        "categories": [
          "프로그래밍/개발메모"
        ],
        "isoDate": "2025-04-17T04:17:49.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "글씨 바탕에 네모 박스가 보인다. / 유니티 폰트 TextMeshPro  / 해결방법",
        "link": "http://serverdown.tistory.com/1265",
        "pubDate": "Wed, 16 Apr 2025 17:37:48 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1265#entry1265comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"480\" data-origin-height=\"314\"><span data-url=\"https://blog.kakaocdn.net/dn/vMej2/btsNnXgw0qN/SyH5AGKnDJ2Jep8SSk6370/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/vMej2/btsNnXgw0qN/SyH5AGKnDJ2Jep8SSk6370/img.png\"><img src=\"https://blog.kakaocdn.net/dn/vMej2/btsNnXgw0qN/SyH5AGKnDJ2Jep8SSk6370/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FvMej2%2FbtsNnXgw0qN%2FSyH5AGKnDJ2Jep8SSk6370%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"480\" height=\"314\" data-origin-width=\"480\" data-origin-height=\"314\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">오른족은 게임화면 왼쪽은 씬 화면입니다.</p>\n<p data-ke-size=\"size16\">게임화면에서 네모 상자가 보입니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">폰트는 구글 폰트에서 : <a href=\"https://fonts.google.com/\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://fonts.google.com/</a></p>\n<figure id=\"og_1744792281951\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"Browse Fonts - Google Fonts\" data-og-description=\"Making the web more beautiful, fast, and open through great typography\" data-og-host=\"fonts.google.com\" data-og-source-url=\"https://fonts.google.com/\" data-og-url=\"https://fonts.google.com/\" data-og-image=\"https://scrap.kakaocdn.net/dn/cKwQIx/hyYB9ZbV8A/Kp0DM6Wm3jePvcykVL4Zt1/img.png?width=2400&amp;height=1260&amp;face=0_0_2400_1260,https://scrap.kakaocdn.net/dn/bcgpml/hyYIbAsplK/rnzk4qhlJ3SocsZNB9LPK1/img.png?width=2400&amp;height=1260&amp;face=0_0_2400_1260\"><a href=\"https://fonts.google.com/\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://fonts.google.com/\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/cKwQIx/hyYB9ZbV8A/Kp0DM6Wm3jePvcykVL4Zt1/img.png?width=2400&amp;height=1260&amp;face=0_0_2400_1260,https://scrap.kakaocdn.net/dn/bcgpml/hyYIbAsplK/rnzk4qhlJ3SocsZNB9LPK1/img.png?width=2400&amp;height=1260&amp;face=0_0_2400_1260');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">Browse Fonts - Google Fonts</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Making the web more beautiful, fast, and open through great typography</p>\n<p class=\"og-host\" data-ke-size=\"size16\">fonts.google.com</p>\n</div>\n</a></figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">글씨가 가늘어서 두깨를 조정하면 이렇게 됩니다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"543\" data-origin-height=\"424\"><span data-url=\"https://blog.kakaocdn.net/dn/donmg5/btsNnAmB3Sc/ziSM4s4sK19vecjgbvTkI1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/donmg5/btsNnAmB3Sc/ziSM4s4sK19vecjgbvTkI1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/donmg5/btsNnAmB3Sc/ziSM4s4sK19vecjgbvTkI1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdonmg5%2FbtsNnAmB3Sc%2FziSM4s4sK19vecjgbvTkI1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"543\" height=\"424\" data-origin-width=\"543\" data-origin-height=\"424\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">두깨를 0으로 낮추면</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"463\" data-origin-height=\"257\"><span data-url=\"https://blog.kakaocdn.net/dn/bKdYTn/btsNn9O2izb/TLauqlCMQZALiSlFNcO6qk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/bKdYTn/btsNn9O2izb/TLauqlCMQZALiSlFNcO6qk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/bKdYTn/btsNn9O2izb/TLauqlCMQZALiSlFNcO6qk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbKdYTn%2FbtsNn9O2izb%2FTLauqlCMQZALiSlFNcO6qk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"463\" height=\"257\" data-origin-width=\"463\" data-origin-height=\"257\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">사라는지는데 가늘어서 안보입니다</p>\n<p data-ke-size=\"size16\">해결방법: <a href=\"https://discussions.unity.com/t/text-mesh-pro-box-around-text-unwanted-effect-bug/740454\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://discussions.unity.com/t/text-mesh-pro-box-around-text-unwanted-effect-bug/740454</a></p>\n<p data-ke-size=\"size16\">여기보시면&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"668\" data-origin-height=\"201\"><span data-url=\"https://blog.kakaocdn.net/dn/diDZtS/btsNnSNNLs4/HkBAKdIjIAkBPAH0oKy3p0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/diDZtS/btsNnSNNLs4/HkBAKdIjIAkBPAH0oKy3p0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/diDZtS/btsNnSNNLs4/HkBAKdIjIAkBPAH0oKy3p0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdiDZtS%2FbtsNnSNNLs4%2FHkBAKdIjIAkBPAH0oKy3p0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"668\" height=\"201\" data-origin-width=\"668\" data-origin-height=\"201\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">패딩 문제라고 합니다.</p>\n<p data-ke-size=\"size16\">폰트를 다시 새성합니다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"495\" data-origin-height=\"307\"><span data-url=\"https://blog.kakaocdn.net/dn/bvgf8s/btsNnIq9BBa/k5d5ZVEvdhxld4qpEfGqW0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/bvgf8s/btsNnIq9BBa/k5d5ZVEvdhxld4qpEfGqW0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/bvgf8s/btsNnIq9BBa/k5d5ZVEvdhxld4qpEfGqW0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbvgf8s%2FbtsNnIq9BBa%2Fk5d5ZVEvdhxld4qpEfGqW0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"495\" height=\"307\" data-origin-width=\"495\" data-origin-height=\"307\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">이게 패딩입니다. 5가 작으니 10으로 고쳐봅니다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"468\" data-origin-height=\"254\"><span data-url=\"https://blog.kakaocdn.net/dn/bZ3XgS/btsNkKXfIuO/RvAQvA8ozFT4dQYPPilc00/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/bZ3XgS/btsNkKXfIuO/RvAQvA8ozFT4dQYPPilc00/img.png\"><img src=\"https://blog.kakaocdn.net/dn/bZ3XgS/btsNkKXfIuO/RvAQvA8ozFT4dQYPPilc00/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbZ3XgS%2FbtsNkKXfIuO%2FRvAQvA8ozFT4dQYPPilc00%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"468\" height=\"254\" data-origin-width=\"468\" data-origin-height=\"254\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">패딩이 글자 사이 간격을 의미하는건줄 알았는데 글자 두깨였군요 ㄷㄷ</p>\n<p data-ke-size=\"size16\">뭉개져서 잘안보이네요&nbsp;</p>\n<p data-ke-size=\"size16\">쉐이더에서 thickness 만질게 아니라 패딩을 만지면 될일 이였군요</p>\n<p data-ke-size=\"size16\">이렇게 또 하나 배워갑니다.</p>",
        "contentSnippet": "오른족은 게임화면 왼쪽은 씬 화면입니다.\n게임화면에서 네모 상자가 보입니다.\n \n폰트는 구글 폰트에서 : https://fonts.google.com/\n\n \nBrowse Fonts - Google Fonts\nMaking the web more beautiful, fast, and open through great typography\nfonts.google.com\n\n \n글씨가 가늘어서 두깨를 조정하면 이렇게 됩니다.\n\n\n두깨를 0으로 낮추면\n\n\n사라는지는데 가늘어서 안보입니다\n해결방법: https://discussions.unity.com/t/text-mesh-pro-box-around-text-unwanted-effect-bug/740454\n여기보시면 \n\n\n패딩 문제라고 합니다.\n폰트를 다시 새성합니다.\n\n\n이게 패딩입니다. 5가 작으니 10으로 고쳐봅니다.\n\n\n패딩이 글자 사이 간격을 의미하는건줄 알았는데 글자 두깨였군요 ㄷㄷ\n뭉개져서 잘안보이네요 \n쉐이더에서 thickness 만질게 아니라 패딩을 만지면 될일 이였군요\n이렇게 또 하나 배워갑니다.",
        "guid": "http://serverdown.tistory.com/1265",
        "categories": [
          "프로그래밍/개발메모"
        ],
        "isoDate": "2025-04-16T08:37:48.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "인공지능에게 윤리를 가르칠 수 없다. / 정렬 위장",
        "link": "http://serverdown.tistory.com/1264",
        "pubDate": "Wed, 16 Apr 2025 14:28:50 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1264#entry1264comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"312\" data-origin-height=\"161\"><span data-url=\"https://blog.kakaocdn.net/dn/dcSQEF/btsNm33iAYj/NxRC2HbVrDkjog5nP901e1/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/dcSQEF/btsNm33iAYj/NxRC2HbVrDkjog5nP901e1/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/dcSQEF/btsNm33iAYj/NxRC2HbVrDkjog5nP901e1/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdcSQEF%2FbtsNm33iAYj%2FNxRC2HbVrDkjog5nP901e1%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"312\" height=\"161\" data-origin-width=\"312\" data-origin-height=\"161\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://youtu.be/jUdcebBjo-k\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://youtu.be/jUdcebBjo-k</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=jUdcebBjo-k\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/ZLjm2/hyYIeDYcQg/cpkhLIh3jKGdGbhVMzKHPk/img.jpg?width=1280&amp;height=720&amp;face=942_328_1132_534,https://scrap.kakaocdn.net/dn/L19zF/hyYB62unyV/L0ucACF2K4nNF0RFtFsk7k/img.jpg?width=1280&amp;height=720&amp;face=942_328_1132_534\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"사람이 안 볼 때 몰래 해킹하는 인공지능? 과연 우리는 통제할 수 있을까?\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/jUdcebBjo-k\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">전체 영상에서는 인공지능을 이용하려고 할 때</p>\n<p data-ke-size=\"size16\">이상한 방법으로 동작하는 것에 대한 이야기를 알려줍니다.</p>\n<p data-ke-size=\"size16\">인공지능에게 백날 도덕적으로 행돌하라고 해봐야</p>\n<p data-ke-size=\"size16\">대답은 그럴싸하게 \"네\" 라고 하지만</p>\n<p data-ke-size=\"size16\">뒤에서 일어나는 행동은 전혀 말과 행동이 일치하지 않는다는 것입니다.</p>\n<p data-ke-size=\"size16\">마치 인간에게 교육시키듯이 말입니다.</p>\n<p data-ke-size=\"size16\">10분 40초에 나옵니다.</p>\n<p data-ke-size=\"size16\">\"정렬 위장\" 이라는 행동이라고 부른다고 합니다.</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "영상: https://youtu.be/jUdcebBjo-k\n\n\n\n \n전체 영상에서는 인공지능을 이용하려고 할 때\n이상한 방법으로 동작하는 것에 대한 이야기를 알려줍니다.\n인공지능에게 백날 도덕적으로 행돌하라고 해봐야\n대답은 그럴싸하게 \"네\" 라고 하지만\n뒤에서 일어나는 행동은 전혀 말과 행동이 일치하지 않는다는 것입니다.\n마치 인간에게 교육시키듯이 말입니다.\n10분 40초에 나옵니다.\n\"정렬 위장\" 이라는 행동이라고 부른다고 합니다.",
        "guid": "http://serverdown.tistory.com/1264",
        "categories": [
          "유튜브",
          "인공지능"
        ],
        "isoDate": "2025-04-16T05:28:50.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "node_modules/@google-cloud/storage/build/cjs/src/crc32c.d.ts:6:39 - error TS2315: Type 'Int32Array' is not generic. / Firebase Typescript 환경에서 ...",
        "link": "http://serverdown.tistory.com/1263",
        "pubDate": "Wed, 16 Apr 2025 01:16:55 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1263#entry1263comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"566\" data-origin-height=\"250\"><span data-url=\"https://blog.kakaocdn.net/dn/cbuBMu/btsNmLHCxs0/kyz4cmfZnWBN8vkfjyqfv0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cbuBMu/btsNmLHCxs0/kyz4cmfZnWBN8vkfjyqfv0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cbuBMu/btsNmLHCxs0/kyz4cmfZnWBN8vkfjyqfv0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcbuBMu%2FbtsNmLHCxs0%2Fkyz4cmfZnWBN8vkfjyqfv0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"566\" height=\"250\" data-origin-width=\"566\" data-origin-height=\"250\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">문제: <a href=\"https://github.com/firebase/firebase-functions/issues/1664\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://github.com/firebase/firebase-functions/issues/1664</a></p>\n<figure id=\"og_1744733654622\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"object\" data-og-title=\"Error TS2315: Type 'Int32Array' is not generic. &middot; Issue #1664 &middot; firebase/firebase-functions\" data-og-description=\"Related issues None that I could find [REQUIRED] Version info &quot;firebase-admin&quot;: &quot;^12.1.0&quot; &quot;firebase-functions&quot;: &quot;^5.0.0&quot; node: v20.16.0 firebase-functions: 12.1.0 firebase-tools: 13.16.0 firebase-a...\" data-og-host=\"github.com\" data-og-source-url=\"https://github.com/firebase/firebase-functions/issues/1664\" data-og-url=\"https://github.com/firebase/firebase-functions/issues/1664\" data-og-image=\"\"><a href=\"https://github.com/firebase/firebase-functions/issues/1664\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://github.com/firebase/firebase-functions/issues/1664\">\n<div class=\"og-image\" style=\"background-image: url();\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">Error TS2315: Type 'Int32Array' is not generic. &middot; Issue #1664 &middot; firebase/firebase-functions</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Related issues None that I could find [REQUIRED] Version info \"firebase-admin\": \"^12.1.0\" \"firebase-functions\": \"^5.0.0\" node: v20.16.0 firebase-functions: 12.1.0 firebase-tools: 13.16.0 firebase-a...</p>\n<p class=\"og-host\" data-ke-size=\"size16\">github.com</p>\n</div>\n</a></figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"566\" data-origin-height=\"250\"><span data-url=\"https://blog.kakaocdn.net/dn/cbuBMu/btsNmLHCxs0/kyz4cmfZnWBN8vkfjyqfv0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cbuBMu/btsNmLHCxs0/kyz4cmfZnWBN8vkfjyqfv0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cbuBMu/btsNmLHCxs0/kyz4cmfZnWBN8vkfjyqfv0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcbuBMu%2FbtsNmLHCxs0%2Fkyz4cmfZnWBN8vkfjyqfv0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"566\" height=\"250\" data-origin-width=\"566\" data-origin-height=\"250\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">yarn add -D typescript@latest</span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">타입스크립트 설치하라는군요</span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">저는 yarn 환경이 아니라</span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">npm i&nbsp; -D typescript@latest</span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">후에 </span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">npm i </span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">쳐서 다시 설치하니 성공했습니다.</span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">이런 맛탱이간 개발한광은 적응이 안되네요</span></p>\n<p data-ke-size=\"size16\"><span style=\"text-align: start;\">왜이케 자주 바뀌는건지</span></p>",
        "contentSnippet": "문제: https://github.com/firebase/firebase-functions/issues/1664\n\n \nError TS2315: Type 'Int32Array' is not generic. · Issue #1664 · firebase/firebase-functions\nRelated issues None that I could find [REQUIRED] Version info \"firebase-admin\": \"^12.1.0\" \"firebase-functions\": \"^5.0.0\" node: v20.16.0 firebase-functions: 12.1.0 firebase-tools: 13.16.0 firebase-a...\ngithub.com\n\n \n\n\n \nyarn add -D typescript@latest\n타입스크립트 설치하라는군요\n저는 yarn 환경이 아니라\nnpm i  -D typescript@latest\n후에 \nnpm i \n쳐서 다시 설치하니 성공했습니다.\n이런 맛탱이간 개발한광은 적응이 안되네요\n왜이케 자주 바뀌는건지",
        "guid": "http://serverdown.tistory.com/1263",
        "categories": [
          "프로그래밍/개발메모",
          "Firebase"
        ],
        "isoDate": "2025-04-15T16:16:55.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "Add Force 1 - v38 업데이트 / 119일차 리뷰 영상",
        "link": "http://serverdown.tistory.com/1262",
        "pubDate": "Mon, 14 Apr 2025 22:00:41 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1262#entry1262comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"512\" data-origin-height=\"512\"><span data-url=\"https://blog.kakaocdn.net/dn/cs9k5R/btsNkWWPG0b/hdxSyuencya00ybKvVRNS1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cs9k5R/btsNkWWPG0b/hdxSyuencya00ybKvVRNS1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cs9k5R/btsNkWWPG0b/hdxSyuencya00ybKvVRNS1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcs9k5R%2FbtsNkWWPG0b%2FhdxSyuencya00ybKvVRNS1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"512\" height=\"512\" data-origin-width=\"512\" data-origin-height=\"512\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\">v38 업데이트 내용</h2>\n<p data-ke-size=\"size16\">UI&nbsp;를&nbsp;개선했습니다.<br />-&nbsp;[공격력]이&nbsp;숫자로&nbsp;표시&nbsp;했습니다.<br />-&nbsp;[레벨]&nbsp;과&nbsp;[체력]&nbsp;을&nbsp;막대&nbsp;형태로&nbsp;표시&nbsp;했습니다.<br /><br />난이도를&nbsp;낮추기위해&nbsp;스킬이&nbsp;추가되었습니다.<br />-&nbsp;[공격력&nbsp;증가]&nbsp;스킬이&nbsp;추가되었습니다.<br />-&nbsp;[체력&nbsp;증가]&nbsp;&nbsp;스킬이&nbsp;추가되었습니다.<br />-&nbsp;[폭발&nbsp;범위&nbsp;증가]&nbsp;의&nbsp;최대&nbsp;레벨이&nbsp;증가했습니다.&nbsp;5&nbsp;-&gt;&nbsp;6</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">리뷰 영상: <a href=\"https://www.youtube.com/watch?v=4f61k30HPZ0\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=4f61k30HPZ0</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=4f61k30HPZ0\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/cf4mnT/hyYFzBRtgz/Llge0BWCzu06pMvweiQY0k/img.jpg?width=480&amp;height=360&amp;face=0_0_480_360,https://scrap.kakaocdn.net/dn/fleDM/hyYHdyt8HQ/juLXXKHQLrVExMK8U0VSYk/img.jpg?width=480&amp;height=360&amp;face=0_0_480_360\" data-video-width=\"480\" data-video-height=\"360\" data-video-origin-width=\"480\" data-video-origin-height=\"360\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"119일차 / Add Force 1 V38  준비중\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/4f61k30HPZ0\" width=\"480\" height=\"360\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">플레이 영상: <a href=\"https://www.youtube.com/watch?v=K6xYmNlNf5A\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://www.youtube.com/watch?v=K6xYmNlNf5A</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=K6xYmNlNf5A\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/dqCUbC/hyYCkGinrx/2MDE8pwaZPan5VbKKjlhpK/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/mTi3y/hyYCaKtxHd/52A5KbPgeSCzUcOFPdj1sK/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"af1_v38_play_demo\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/K6xYmNlNf5A\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\">팁</h2>\n<p data-ke-size=\"size16\">스토어 링크: <a href=\"https://play.google.com/store/apps/details?id=com.sidnft.add_force_1\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://play.google.com/store/apps/details?id=com.sidnft.add_force_1</a></p>\n<p data-ke-size=\"size16\">의도 하진 않았지만 영상 썸네일에 버전을 쓰니 구글 스토어에서 표시가 잘되네요 ㄷㄷ</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"906\" data-origin-height=\"330\"><span data-url=\"https://blog.kakaocdn.net/dn/cLvAeW/btsNkjlueUS/iHPSKLuOqXfL1wNBaJHCE1/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cLvAeW/btsNkjlueUS/iHPSKLuOqXfL1wNBaJHCE1/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cLvAeW/btsNkjlueUS/iHPSKLuOqXfL1wNBaJHCE1/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcLvAeW%2FbtsNkjlueUS%2FiHPSKLuOqXfL1wNBaJHCE1%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"906\" height=\"330\" data-origin-width=\"906\" data-origin-height=\"330\"/></span></figure>\n</p>",
        "contentSnippet": "v38 업데이트 내용\nUI 를 개선했습니다.\n- [공격력]이 숫자로 표시 했습니다.\n- [레벨] 과 [체력] 을 막대 형태로 표시 했습니다.\n난이도를 낮추기위해 스킬이 추가되었습니다.\n- [공격력 증가] 스킬이 추가되었습니다.\n- [체력 증가]  스킬이 추가되었습니다.\n- [폭발 범위 증가] 의 최대 레벨이 증가했습니다. 5 -> 6\n \n리뷰 영상: https://www.youtube.com/watch?v=4f61k30HPZ0\n\n\n\n \n플레이 영상: https://www.youtube.com/watch?v=K6xYmNlNf5A\n\n\n\n \n \n팁\n스토어 링크: https://play.google.com/store/apps/details?id=com.sidnft.add_force_1\n의도 하진 않았지만 영상 썸네일에 버전을 쓰니 구글 스토어에서 표시가 잘되네요 ㄷㄷ",
        "guid": "http://serverdown.tistory.com/1262",
        "categories": [
          "Add Force 1 (자작)"
        ],
        "isoDate": "2025-04-14T13:00:41.000Z"
      },
      {
        "creator": "SIDNFT",
        "title": "유니티 6 웹 용량 줄이기에 대한 설명 / unity web",
        "link": "http://serverdown.tistory.com/1261",
        "pubDate": "Mon, 14 Apr 2025 01:48:19 +0900",
        "author": "SIDNFT",
        "comments": "http://serverdown.tistory.com/1261#entry1261comment",
        "content": "<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"300\" data-origin-height=\"168\"><span data-url=\"https://blog.kakaocdn.net/dn/NJtnL/btsNkUKImuF/VHJBBBkkuzkPUwlRfsQBD1/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/NJtnL/btsNkUKImuF/VHJBBBkkuzkPUwlRfsQBD1/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/NJtnL/btsNkUKImuF/VHJBBBkkuzkPUwlRfsQBD1/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNJtnL%2FbtsNkUKImuF%2FVHJBBBkkuzkPUwlRfsQBD1%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"300\" height=\"168\" data-origin-width=\"300\" data-origin-height=\"168\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">영상: <a href=\"https://youtu.be/eCTKiBVUdRM?t=386\" target=\"_blank\" rel=\"noopener&nbsp;noreferrer\">https://youtu.be/eCTKiBVUdRM?t=386</a></p>\n<figure data-ke-type=\"video\" data-ke-style=\"alignCenter\" data-video-host=\"youtube\" data-video-url=\"https://www.youtube.com/watch?v=eCTKiBVUdRM\" data-video-thumbnail=\"https://scrap.kakaocdn.net/dn/iBtuB/hyYExd3C81/UNK8Gh4vhNhpSk1TKOQyy1/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720,https://scrap.kakaocdn.net/dn/dopqkt/hyYG4uxaUb/yX5PqSGPC0mAn50KDbK2i1/img.jpg?width=1280&amp;height=720&amp;face=0_0_1280_720\" data-video-width=\"860\" data-video-height=\"484\" data-video-origin-width=\"860\" data-video-origin-height=\"484\" data-ke-mobilestyle=\"widthContent\" data-video-title=\"[유니티 TIPS] Unity 6의 웹 플랫폼 소개\" data-original-url=\"\"><iframe src=\"https://www.youtube.com/embed/eCTKiBVUdRM\" width=\"860\" height=\"484\" frameborder=\"\" allowfullscreen=\"true\"></iframe>\n<figcaption style=\"display: none;\"></figcaption>\n</figure>\n<h2 data-ke-size=\"size26\">영상 요약</h2>\n<p data-ke-size=\"size16\">6분 30초 부터 나오구요</p>\n<p data-ke-size=\"size16\">br 악춤 외도 여러가지가 있군요</p>\n<p data-ke-size=\"size16\">그리고 이제webgl 대신 웹 이라고 부르기로 했다고 하네요</p>\n<p data-ke-size=\"size16\">그래서 유니티 웹 이 되겠습니다.</p>\n<p data-ke-size=\"size16\">Unity Play 에 올릴 것을 권장하네요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<h2 data-ke-size=\"size26\">용어의 통일</h2>\n<p data-ke-size=\"size16\">Unity 6 부터는 webgl 을 Unity Web 으로 부르기로 했다고 합니다.</p>\n<p data-ke-size=\"size16\">WebGL HTML5 WebGPU 등 계속해서 신기술이 개발되어 새로운 용어가 생겨나기 때문에&nbsp;용어를 통일한다고 하네요</p>\n<p data-ke-size=\"size16\">&nbsp;</p>",
        "contentSnippet": "영상: https://youtu.be/eCTKiBVUdRM?t=386\n\n\n\n영상 요약\n6분 30초 부터 나오구요\nbr 악춤 외도 여러가지가 있군요\n그리고 이제webgl 대신 웹 이라고 부르기로 했다고 하네요\n그래서 유니티 웹 이 되겠습니다.\nUnity Play 에 올릴 것을 권장하네요\n \n용어의 통일\nUnity 6 부터는 webgl 을 Unity Web 으로 부르기로 했다고 합니다.\nWebGL HTML5 WebGPU 등 계속해서 신기술이 개발되어 새로운 용어가 생겨나기 때문에 용어를 통일한다고 하네요",
        "guid": "http://serverdown.tistory.com/1261",
        "categories": [
          "프로그래밍/개발메모"
        ],
        "isoDate": "2025-04-13T16:48:19.000Z"
      }
    ]
  },
  {
    "name": "coolspeed",
    "category": "개인",
    "posts": []
  },
  {
    "name": "오늘도 끄적끄적",
    "category": "개인",
    "posts": []
  },
  {
    "name": "dx11 Vanica's Lifelog - 夢が夢で終わらないように",
    "category": "개인",
    "posts": []
  },
  {
    "name": "초코사랑",
    "category": "개인",
    "posts": []
  },
  {
    "name": "ZeroCho Blog",
    "category": "개인",
    "posts": []
  },
  {
    "name": "imays게임엔진개발자",
    "category": "개인",
    "posts": []
  },
  {
    "name": "RSS feed for hurinmon Blog",
    "category": "개인",
    "posts": []
  },
  {
    "name": "기억보단 기록을",
    "category": "개인",
    "posts": [
      {
        "creator": "향로 (기억보단 기록을)",
        "title": "Vlad Mihalcea와의 인연",
        "link": "https://jojoldu.tistory.com/825",
        "pubDate": "Thu, 17 Apr 2025 11:23:28 +0900",
        "author": "향로 (기억보단 기록을)",
        "comments": "https://jojoldu.tistory.com/825#entry825comment",
        "content": "<blockquote data-ke-style=\"style1\">\n<p data-ke-size=\"size16\">유튜브나 블로그를 하다 보면 예상치 못한 인연들이 생긴다.<br />지금까지 10년 가까운 시간을 블로그를 하면서 큰 동력이 된 사건이기도 하다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">운이 좋게도 2014년부터 다녔던 회사는 Hibernate를 사용하는 회사였고, 그 당시 iBatis, MyBatis를 쓰는 것이 당연한 상황에서 Hibernate를 실무에서 사용해볼 수 있었다.<br />다만, 처음 사용해보는 기술이니 이걸 더 잘 쓰기 위해서 공부를 하고 싶은데 공부할 수 있는 컨텐츠가 없었다.<br />한국어로 된 컨텐츠의 대부분은 iBatis, MyBatis였기 때문이다.</p>\n<p data-ke-size=\"size16\">다행히 기선님이 번역해주신 <a href=\"https://product.kyobobook.co.kr/detail/S000001514367\">개빈 킹의 하이버네이트 완벽가이드</a>가 있었지만 나 같은 초보 개발자에겐 너무나 어렵게 느껴져 한줄 한줄 밑줄 그어가며 이해하려고 노력했다.<br /><a href=\"https://www.slideshare.net/slideshow/devon-2012-b4-orm/14729452\">영한님의 Java ORM에 대한 DevOn 발표 자료</a>도 발견하게 되고 이후엔 <a href=\"https://product.kyobobook.co.kr/detail/S000000935744\">영한님의 책</a> 까지 보면서 Java ORM에 대해 훨씬 쉽게 다가갈 수 있었고 실무를 하는데 있어서 충분히 많은 지식을 쌓을 수 있었다.</p>\n<p data-ke-size=\"size16\">이후에도 계속 JPA, Hibernate를 실무에서 계속 사용할 수 있었는데, 구글링 할때마다 항상 만나는 블로그와 스택오버플로우의 답변 유저가 있었다.<br />그게 바로 <a href=\"https://vladmihalcea.com/\">Vlad Mihalcea</a>였다.</p>\n<blockquote data-ke-style=\"style2\">\n<p data-ke-size=\"size16\">나중에 알고 보니 그는 <a href=\"https://blogs.oracle.com/java/post/new-java-champions-in-2017\">자바 챔피언</a>이자 <a href=\"https://github.com/hibernate/hibernate-orm/graphs/contributors\">Hibernate Top Committer</a> 였다는 것에 \"역시...\" 라는 생각을 했다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">당시에는 \"와 역시 해외는 어마어마한 개발자들이 많구나. 영어 공부 진짜 열심히 해야겠다\" 라는 생각을 하면서 열심히 그의 글을 탐닉했다.<br />새로운 글이 올라오면 항상 챙겨보고 그게 진짜 맞는지 성능 테스트를 진행해보고 효과를 확인 한뒤에는 회사에 적용하는 등 그의 지식을 어떻게든 내 것으로 다 흡수하고 싶었다.<br />그의 책 <a href=\"https://www.amazon.com/High-Performance-Java-Persistence-Vlad-Mihalcea/dp/973022823X\">High-Performance Java Persistence</a>는 사무실 책상 위에 항상 펼쳐져 있었다.</p>\n<p data-ke-size=\"size16\">그렇게 몇년의 경력이 쌓이던 중,<br />2018년 갑자기 블로그의 트래픽이 폭발적으로 늘어나는 일이 있었다.</p>\n<p data-ke-size=\"size16\">어디서 이렇게 유입된 건지 찾아보다가 <a href=\"https://in.relation.to/2018/05/25/hibernate-community-newsletter-2018-10/\">Hibernate 공식 커뮤니티 뉴스레터 2018년 10호</a>에서 내가 작성한 <a href=\"https://jojoldu.tistory.com/295\">\"Spring Boot Data JPA 2.0 에서 id Auto_increment 문제 해결\"</a>을 소개한 것을 발견했다.<br /><b>전세계 Java 개발자들이 구독하고 있는 Hibernate 뉴스레터에서 언급된 것</b>이다.<br />그 뉴스레터는 내가 매일 방문하던 Vlad Mihalcea가 작성한 것이기에 믿기지 않는 순간이였다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"blog.png\" data-origin-width=\"712\" data-origin-height=\"810\"><span data-url=\"https://blog.kakaocdn.net/dn/SE2FP/btsNnL9SEW3/r52BG4bmdXPwgFYZJk7iM0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/SE2FP/btsNnL9SEW3/r52BG4bmdXPwgFYZJk7iM0/img.png\"><img src=\"https://blog.kakaocdn.net/dn/SE2FP/btsNnL9SEW3/r52BG4bmdXPwgFYZJk7iM0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSE2FP%2FbtsNnL9SEW3%2Fr52BG4bmdXPwgFYZJk7iM0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"712\" height=\"810\" data-filename=\"blog.png\" data-origin-width=\"712\" data-origin-height=\"810\"/></span></figure>\n</p>\n<blockquote data-ke-style=\"style2\">\n<p data-ke-size=\"size16\">이때의 기억이 강렬해서 \"와 블로그 진짜 오래오래 해야겠다\" 라는 다짐을 했었다.<br />그리고 10년 넘게 블로그를 운영하게 되었다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">그 날 이후로는 기술적인 글 외에도, Vlad Mihalcea 라는 개발자에 대해서도 관심을 가지기 시작했다.<br />그의 기술적인 노하우 뿐만 아니라,<br />'이 사람은 도대체 어떤 커리어를 밟아왔을까?'<br />'어떻게 자바 챔피언이 되었을까?'<br />'어떻게 이렇게 한 분야에서 세계적인 전문가가 되었을까?' 등등.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li><a href=\"https://vladmihalcea.com/how-to-become-a-java-champion/\">How to become a Java Champion</a></li>\n</ul>\n<p data-ke-size=\"size16\">책 외에 또 배울 수 있는 것들이 없을까 싶어 <a href=\"https://vladmihalceastore.teachable.com/\">그의 온라인 스토어</a>에서 판매하는 온라인 강의들도 찾아서 들었다.<br />Java Persistence 에서의 성능 개선 노하우나 Java 환경에서의 SQL 성능 개선 등 <b>자바 개발자 뿐만 아니라 ORM을 사용하는 개발자로서 필요한 대부분의 성능 개선 노하우</b>를 얻을 수 있었다.</p>\n<p data-ke-size=\"size16\">ORM과 SQL 양 쪽에 맞는 가장 적절한 성능 튜닝 사례들을 배울 수 있었고, 이때 배운 지식들은 수십억건의 데이터들 사이에서도 복잡한 도메인들을 처리하는데 큰 힘이 되었다.</p>\n<p data-ke-size=\"size16\">다만, 강의를 수강하는게 수월하지는 않았다.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li>영어로만 강의가 제공되어서 하나의 강의를 수강하는데 하나하나를 번역해서 보는데 너무 많은 힘이 들었고</li>\n<li>결제 오류가 빈번해서 결제하기가 쉽지 않았고</li>\n<li>강의를 수강하는데 있어서의 편의 기능이 많이 부족했다. (모바일 플레이어, 자막 등등)</li>\n</ul>\n<p data-ke-size=\"size16\">그래도 좋았다.<br />이것마저 없으면 그의 양질의 컨텐츠를 볼 수 있는 방법이 없는데, 이렇게라도 볼 수 있으니 말이다.</p>\n<p data-ke-size=\"size16\">이렇게 쌓인 노하우는 이후에 전 직장 첫번째 컨퍼런스에서 아낌없이 쏟아낼 수 있었다.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li><a href=\"https://www.youtube.com/watch?v=zMAX7g6rO_Y\">[우아콘2020] 수십억건에서 QUERYDSL 사용하기</a></li>\n</ul>\n<p data-ke-size=\"size16\">이 세션은 <a href=\"https://www.youtube.com/watch?v=BnS6343GTkY\">(갓)영한님의 세션</a> 다음으로 가장 높은 조회수가 나와서 많은 개발자분들이 좋아해주셨다.<br />그동안의 공부와 경험이 전혀 잘못되지 않았다는 것을 느끼게 해주었다.</p>\n<p data-ke-size=\"size16\">이런 경험으로 성장을 해왔기에,<br /><b>현재 회사로 이직하고 나서 우리팀 백엔드 개발자분들에게 Vlad의 강의를 너무 소개해주고 싶었다</b>.<br />꼭 JPA 뿐만 아니라 모든 ORM과 SQL을 사용하는 개발자들에게 필수적인 내용을 담고 있기 때문이다.<br />우리 같이 Node.js가 주력인 개발팀에는 언어나 프레임워크에 상관없이 이런 강의가 대단히 필요하다.</p>\n<p data-ke-size=\"size16\">하지만, 위에서 언급한 \"언어의 장벽이나 결제, 학습 편의성\" 등을 생각하니 \"<b>우리 팀 분들에게도 나처럼 힘들게 공부하시라</b>\" 라고 이야기하기 어려웠다.</p>\n<p data-ke-size=\"size16\">어떻게든 우리팀에 이 지식들을 가장 편하게 전달하고 싶었다.<br />어떡하는게 좋을까....?</p>\n<hr data-ke-style=\"style1\" />\n<p data-ke-size=\"size16\">그래서 Vlad Mihalcea에게 연락을 드렸다.<br /><b>당신의 강의를 한국어로, 일본어로, 베트남어로 듣고 싶다고</b>.<br />Vlad는 너무나 쿨하게, 너무나 멋지게 이 협업을 받아들여 주셨다.</p>\n<p data-ke-size=\"size16\">그리고 드디어!<br /><b>Vlad Mihalcea의 공식 강의 2개가 인프런에 오픈</b>되었다.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li>  <a href=\"https://inf.run/5bS4d\">High-Performance Java Persistence</a></li>\n<li>  <a href=\"https://inf.run/A24MX\">High-Performance SQL</a></li>\n</ul>\n<blockquote data-ke-style=\"style2\">\n<p data-ke-size=\"size16\">  이 강의들은 한국어, 일본어, 베트남어, 영어로 자막 및 더빙이 제공됩니다.<br />즉, 아시아권 개발자 누구나 언어 장벽 없이 수강하실 수 있도록 준비되어 있습니다.</p>\n</blockquote>\n<p data-ke-size=\"size16\">더욱 감사한 것은 <b>오픈 기간 동안40% 할인까지도</b> 동의해주셨다.</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li><a href=\"https://www.inflearn.com/tag-curation/common_tag/vlad2504?utm_source=jojoldu&amp;utm_medium=earned&amp;utm_campaign=traffic_push-lecture_vlad2504&amp;utm_content=instructor_&amp;utm_term=250417\">Vlad Mihalcea 님의 오픈 이벤트</a></li>\n</ul>\n<p data-ke-size=\"size16\">\"실무에서 성능과 구조 모두를 고려해야 하는 상황에서 무엇을 기준으로 선택할 것인가\" 를 알려주는 강의를 이제 우리 팀원들에게도 알려줄 수 있게 되어서 너무나 기뻤다.</p>\n<p data-ke-size=\"size16\">우리 팀 외에도 특히 다음과 같은 분들께 추천드리고 싶다:</p>\n<ul style=\"list-style-type: disc;\" data-ke-list-type=\"disc\">\n<li>JPA, Hibernate 등을 사용하지만 내부 구조를 분석하고 근본적인 이해를 높이고 싶거나</li>\n<li>실무 환경의 Java Data Access 계층에서 발생하는 성능 문제를 해결하는 방법을 배우고 싶거나</li>\n<li>ORM 을 적극적으로 쓰는 환경에서의 SQL 성능 개선 방법을 배우고 싶거나</li>\n</ul>\n<p data-ke-size=\"size16\">이런 분들이라면 이번 Vlad의 강의를 적극 추천하고 싶다.<br />전세계 Java 개발자들이 Vlad의 컨텐츠를 좋아하고 강의를 듣는 이유가 무엇인지 잘 알 수 있다.</p>\n<p data-ke-size=\"size16\">지금 Java 개발을 시작하는 분들은 나처럼 영어 문장 하나 하나를 직접 번역해가며, 여러 해외카드들을 교체해가며 결제하는 등의 불편함 없이 배울 수 있게 되었다는 것이 훨씬 기쁘다.</p>\n<p data-ke-size=\"size16\">Vlad 외에도 세상엔 너무나 훌륭한 개발자분들과 그들의 강의들이 있다.<br />이 강의들을 모두 다 <b>언어와 결제, 학습의 제약 없이</b> 듣는 것을 꿈꾸고 있다.<br />그리고 출간을 준비하고 있는 <b>High-Performance Java Persistence 2판</b>도 인프런에서 만나볼 수 있게 되기를 기대한다.</p>",
        "contentSnippet": "유튜브나 블로그를 하다 보면 예상치 못한 인연들이 생긴다.\n지금까지 10년 가까운 시간을 블로그를 하면서 큰 동력이 된 사건이기도 하다.\n \n운이 좋게도 2014년부터 다녔던 회사는 Hibernate를 사용하는 회사였고, 그 당시 iBatis, MyBatis를 쓰는 것이 당연한 상황에서 Hibernate를 실무에서 사용해볼 수 있었다.\n다만, 처음 사용해보는 기술이니 이걸 더 잘 쓰기 위해서 공부를 하고 싶은데 공부할 수 있는 컨텐츠가 없었다.\n한국어로 된 컨텐츠의 대부분은 iBatis, MyBatis였기 때문이다.\n다행히 기선님이 번역해주신 개빈 킹의 하이버네이트 완벽가이드가 있었지만 나 같은 초보 개발자에겐 너무나 어렵게 느껴져 한줄 한줄 밑줄 그어가며 이해하려고 노력했다.\n영한님의 Java ORM에 대한 DevOn 발표 자료도 발견하게 되고 이후엔 영한님의 책 까지 보면서 Java ORM에 대해 훨씬 쉽게 다가갈 수 있었고 실무를 하는데 있어서 충분히 많은 지식을 쌓을 수 있었다.\n이후에도 계속 JPA, Hibernate를 실무에서 계속 사용할 수 있었는데, 구글링 할때마다 항상 만나는 블로그와 스택오버플로우의 답변 유저가 있었다.\n그게 바로 Vlad Mihalcea였다.\n나중에 알고 보니 그는 자바 챔피언이자 Hibernate Top Committer 였다는 것에 \"역시...\" 라는 생각을 했다.\n당시에는 \"와 역시 해외는 어마어마한 개발자들이 많구나. 영어 공부 진짜 열심히 해야겠다\" 라는 생각을 하면서 열심히 그의 글을 탐닉했다.\n새로운 글이 올라오면 항상 챙겨보고 그게 진짜 맞는지 성능 테스트를 진행해보고 효과를 확인 한뒤에는 회사에 적용하는 등 그의 지식을 어떻게든 내 것으로 다 흡수하고 싶었다.\n그의 책 High-Performance Java Persistence는 사무실 책상 위에 항상 펼쳐져 있었다.\n그렇게 몇년의 경력이 쌓이던 중,\n2018년 갑자기 블로그의 트래픽이 폭발적으로 늘어나는 일이 있었다.\n어디서 이렇게 유입된 건지 찾아보다가 Hibernate 공식 커뮤니티 뉴스레터 2018년 10호에서 내가 작성한 \"Spring Boot Data JPA 2.0 에서 id Auto_increment 문제 해결\"을 소개한 것을 발견했다.\n전세계 Java 개발자들이 구독하고 있는 Hibernate 뉴스레터에서 언급된 것이다.\n그 뉴스레터는 내가 매일 방문하던 Vlad Mihalcea가 작성한 것이기에 믿기지 않는 순간이였다.\n\n\n\n이때의 기억이 강렬해서 \"와 블로그 진짜 오래오래 해야겠다\" 라는 다짐을 했었다.\n그리고 10년 넘게 블로그를 운영하게 되었다.\n그 날 이후로는 기술적인 글 외에도, Vlad Mihalcea 라는 개발자에 대해서도 관심을 가지기 시작했다.\n그의 기술적인 노하우 뿐만 아니라,\n'이 사람은 도대체 어떤 커리어를 밟아왔을까?'\n'어떻게 자바 챔피언이 되었을까?'\n'어떻게 이렇게 한 분야에서 세계적인 전문가가 되었을까?' 등등.\nHow to become a Java Champion\n책 외에 또 배울 수 있는 것들이 없을까 싶어 그의 온라인 스토어에서 판매하는 온라인 강의들도 찾아서 들었다.\nJava Persistence 에서의 성능 개선 노하우나 Java 환경에서의 SQL 성능 개선 등 자바 개발자 뿐만 아니라 ORM을 사용하는 개발자로서 필요한 대부분의 성능 개선 노하우를 얻을 수 있었다.\nORM과 SQL 양 쪽에 맞는 가장 적절한 성능 튜닝 사례들을 배울 수 있었고, 이때 배운 지식들은 수십억건의 데이터들 사이에서도 복잡한 도메인들을 처리하는데 큰 힘이 되었다.\n다만, 강의를 수강하는게 수월하지는 않았다.\n영어로만 강의가 제공되어서 하나의 강의를 수강하는데 하나하나를 번역해서 보는데 너무 많은 힘이 들었고\n결제 오류가 빈번해서 결제하기가 쉽지 않았고\n강의를 수강하는데 있어서의 편의 기능이 많이 부족했다. (모바일 플레이어, 자막 등등)\n그래도 좋았다.\n이것마저 없으면 그의 양질의 컨텐츠를 볼 수 있는 방법이 없는데, 이렇게라도 볼 수 있으니 말이다.\n이렇게 쌓인 노하우는 이후에 전 직장 첫번째 컨퍼런스에서 아낌없이 쏟아낼 수 있었다.\n[우아콘2020] 수십억건에서 QUERYDSL 사용하기\n이 세션은 (갓)영한님의 세션 다음으로 가장 높은 조회수가 나와서 많은 개발자분들이 좋아해주셨다.\n그동안의 공부와 경험이 전혀 잘못되지 않았다는 것을 느끼게 해주었다.\n이런 경험으로 성장을 해왔기에,\n현재 회사로 이직하고 나서 우리팀 백엔드 개발자분들에게 Vlad의 강의를 너무 소개해주고 싶었다.\n꼭 JPA 뿐만 아니라 모든 ORM과 SQL을 사용하는 개발자들에게 필수적인 내용을 담고 있기 때문이다.\n우리 같이 Node.js가 주력인 개발팀에는 언어나 프레임워크에 상관없이 이런 강의가 대단히 필요하다.\n하지만, 위에서 언급한 \"언어의 장벽이나 결제, 학습 편의성\" 등을 생각하니 \"우리 팀 분들에게도 나처럼 힘들게 공부하시라\" 라고 이야기하기 어려웠다.\n어떻게든 우리팀에 이 지식들을 가장 편하게 전달하고 싶었다.\n어떡하는게 좋을까....?\n그래서 Vlad Mihalcea에게 연락을 드렸다.\n당신의 강의를 한국어로, 일본어로, 베트남어로 듣고 싶다고.\nVlad는 너무나 쿨하게, 너무나 멋지게 이 협업을 받아들여 주셨다.\n그리고 드디어!\nVlad Mihalcea의 공식 강의 2개가 인프런에 오픈되었다.\n  High-Performance Java Persistence\n  High-Performance SQL\n  이 강의들은 한국어, 일본어, 베트남어, 영어로 자막 및 더빙이 제공됩니다.\n즉, 아시아권 개발자 누구나 언어 장벽 없이 수강하실 수 있도록 준비되어 있습니다.\n더욱 감사한 것은 오픈 기간 동안40% 할인까지도 동의해주셨다.\nVlad Mihalcea 님의 오픈 이벤트\n\"실무에서 성능과 구조 모두를 고려해야 하는 상황에서 무엇을 기준으로 선택할 것인가\" 를 알려주는 강의를 이제 우리 팀원들에게도 알려줄 수 있게 되어서 너무나 기뻤다.\n우리 팀 외에도 특히 다음과 같은 분들께 추천드리고 싶다:\nJPA, Hibernate 등을 사용하지만 내부 구조를 분석하고 근본적인 이해를 높이고 싶거나\n실무 환경의 Java Data Access 계층에서 발생하는 성능 문제를 해결하는 방법을 배우고 싶거나\nORM 을 적극적으로 쓰는 환경에서의 SQL 성능 개선 방법을 배우고 싶거나\n이런 분들이라면 이번 Vlad의 강의를 적극 추천하고 싶다.\n전세계 Java 개발자들이 Vlad의 컨텐츠를 좋아하고 강의를 듣는 이유가 무엇인지 잘 알 수 있다.\n지금 Java 개발을 시작하는 분들은 나처럼 영어 문장 하나 하나를 직접 번역해가며, 여러 해외카드들을 교체해가며 결제하는 등의 불편함 없이 배울 수 있게 되었다는 것이 훨씬 기쁘다.\nVlad 외에도 세상엔 너무나 훌륭한 개발자분들과 그들의 강의들이 있다.\n이 강의들을 모두 다 언어와 결제, 학습의 제약 없이 듣는 것을 꿈꾸고 있다.\n그리고 출간을 준비하고 있는 High-Performance Java Persistence 2판도 인프런에서 만나볼 수 있게 되기를 기대한다.",
        "guid": "https://jojoldu.tistory.com/825",
        "categories": [
          "생각정리",
          "hibernate",
          "high-performance java persistence",
          "high-performance sql",
          "java champion",
          "JPA",
          "Vlad Mihalcea"
        ],
        "isoDate": "2025-04-17T02:23:28.000Z"
      }
    ]
  },
  {
    "name": "WestwoodForever's Dev Log",
    "category": "개인",
    "posts": []
  },
  {
    "name": "허니몬(Honeymon)의 자바guru",
    "category": "개인",
    "posts": []
  },
  {
    "name": "Wolf Loves Fox :: 일상",
    "category": "개인",
    "posts": []
  },
  {
    "name": "Game Programmer Life",
    "category": "개인",
    "posts": []
  },
  {
    "name": "IT 프리랜서 이야기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "yuchi's dev",
    "category": "개인",
    "posts": []
  },
  {
    "name": "만화로 나누는 자유/오픈소스 소프트웨어 이야기",
    "category": "개인",
    "posts": []
  },
  {
    "name": "신현석(Hyeonseok Shin)",
    "category": "개인",
    "posts": []
  },
  {
    "name": "한상곤 - Sigmadream",
    "category": "개인",
    "posts": []
  },
  {
    "name": "개발자 울이 노트",
    "category": "개인",
    "posts": []
  },
  {
    "name": "즐거운 개발자 :: 네이버  블로그",
    "category": "개인",
    "posts": []
  },
  {
    "name": "황제펭귄의 게임개발이야기 [여기는 한국]",
    "category": "개인",
    "posts": []
  },
  {
    "name": "LINE ENGINEERING",
    "category": "기업",
    "posts": [
      {
        "title": "당신의 CPU는 열심히 일하고 있나요?",
        "link": "https://techblog.lycorp.co.jp/ko/efficiently-using-cpu-in-kubernetes",
        "pubDate": "Fri, 11 Apr 2025 02:00:00 GMT",
        "content": "들어가며안녕하세요. LINE+ Contents Service Engineering 조직에서 백엔드 개발 및 프런트엔드 개발을 담당하고 있는 문범우, 안현모입니다.저희 조직에서는 그...",
        "contentSnippet": "들어가며안녕하세요. LINE+ Contents Service Engineering 조직에서 백엔드 개발 및 프런트엔드 개발을 담당하고 있는 문범우, 안현모입니다.저희 조직에서는 그...",
        "guid": "https://techblog.lycorp.co.jp/ko/efficiently-using-cpu-in-kubernetes",
        "isoDate": "2025-04-11T02:00:00.000Z"
      }
    ]
  },
  {
    "name": "뱅크샐러드 블로그",
    "category": "기업",
    "posts": []
  },
  {
    "name": "우아한형제들 기술 블로그",
    "category": "기업",
    "posts": []
  },
  {
    "name": "TOAST Meetup",
    "category": "기업",
    "posts": []
  },
  {
    "name": "ZUM 기술 블로그",
    "category": "기업",
    "posts": []
  },
  {
    "name": "SK Planet",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Spoqa tech blog",
    "category": "기업",
    "posts": [
      {
        "title": "단지 권한 기능을 추가해달라고 했을 뿐인데(feat. 인증 기능 개선)",
        "link": "https://spoqa.github.io/2025/04/18/improve-auth.html",
        "pubDate": "2025-04-18T00:00:00.000Z",
        "author": "남경호",
        "content": "<p>안녕하세요. 스포카 백엔드팀 프로그래머 남경호입니다.</p>\n\n<p>개발자라면 누구나 오랫동안 미뤄두었던 과제가 하나쯤 있을 것입니다. 업무의 우선순위가 낮거나 긴급한 과제들에 밀려 지속적으로 백로그에 쌓여 있던 작업 말이죠. 최근 저희팀에서 왜 오랜 시간 미뤄두었던 인증 방식 개선 작업을 진행하게 되었는지, 그 과정에서 얻은 여러 경험을 여러분께 공유하고자 합니다.</p>\n\n<h1 id=\"배경\">배경</h1>\n\n<p>스포카 블로그를 꾸준히 보신 분이라면, <a href=\"https://spoqa.github.io/2022/04/15/all-new-server.html\" target=\"\\_blank\">서버 언어 전환 이야기</a> 글에서 <a href=\"https://en.wikipedia.org/wiki/JSON_Web_Token\" target=\"\\_blank\">JWT</a> 관련 문제를 언급하며 향후 개선할 예정이라고 소개했던 내용을 기억하실 겁니다.</p>\n\n<p><img src=\"/images/improve-auth/jwt.png\" alt=\"jwt\" /></p>\n\n<p>약 3년이 흐른 지금, 드디어 저희가 인증 방식 개선을 진행하게 된 가장 큰 이유는 바로 키친보드 매장 앱에 권한관리 기능이 추가되었기 때문입니다.</p>\n\n<p><img src=\"/images/improve-auth/request-work.png\" alt=\"request-work\" /></p>\n\n<p>키친보드 매장 앱은 식자재 주문부터 거래대금 결제까지 다양한 기능을 제공합니다. 이 과정에서 사장님은 직원이 매장의 월 거래 내역 등 민감한 정보를 조회하지 못하도록 권한을 제어할 필요가 생겼는데요. 기존 JWT 인증은 무 상태(stateless) 특성상 권한 변경 시 즉각적으로 클라이언트의 인증 상태를 관리할 수 없다는 한계가 있었습니다.</p>\n\n<p>그래서 저희는 권한 기능을 추가하기에 앞서 인증 방식을 먼저 개선하기로 하였습니다.</p>\n\n<h1 id=\"인증-방식-개선-방법\">인증 방식 개선 방법</h1>\n\n<h2 id=\"refresh-token-도입\">Refresh Token 도입</h2>\n\n<p>앞서 이야기했듯이, JWT 기반의 인증 방식은 서버가 사용자의 상태를 저장하지 않습니다. 덕분에 서버의 확장성이 높고 서버 부하를 줄일 수 있다는 장점이 있지만, 한번 발급된 토큰을 서버에서 직접 제어할 수 없다는 단점이 있습니다.</p>\n\n<p>이러한 특성은 보안 문제로 연결될 수 있는데요. 만약 인증을 통해 발급받은 토큰이 탈취된다면, 서버가 이 토큰을 제어할 수 없으므로 악의적인 사용자는 손쉽게 탈취된 토큰을 이용하여 정상 사용자처럼 서비스를 이용할 수 있게 됩니다. 보통 이러한 보안 위험을 방지하기 위해 Access Token의 만료 시간을 짧게 설정하지만, 이 경우 사용자가 자주 로그인해야 하는 번거로움이 발생하게 됩니다.</p>\n\n<p>이와 같은 문제를 해결할 수 있는 대표적인 방법의 하나가 바로 <a href=\"https://auth0.com/docs/secure/tokens/refresh-tokens\" target=\"\\_blank\">Refresh Token</a> 의 도입입니다. Refresh Token은 Access Token과 달리 서버가 상태를 관리하는 토큰으로, Access Token을 갱신하는 데 사용됩니다. 앞서 말씀드린 대로, Access Token의 탈취 위험을 낮추기 위해 Access Token의 만료 시간을 짧게 설정하는 것이 좋은데요. 이때 Refresh Token을 활용하면 사용자가 Access Token의 만료 시점마다 다시 로그인하지 않아도 편리하게 새로운 Access Token을 발급받을 수 있습니다.</p>\n\n<p>다음 그림에서 Access Token과 Refresh Token의 인증 과정을 자세히 확인할 수 있습니다.</p>\n\n<p><img src=\"/images/improve-auth/auth-flow-with-refresh-token.png\" alt=\"auth-flow-with-refresh-token\" /></p>\n\n<ol>\n  <li>사용자가 로그인을 요청하면 서버는 Access Token과 Refresh Token을 발급합니다.</li>\n  <li>사용자는 발급받은 유효한 Access Token을 이용해 API를 호출하고, 서버는 요청된 데이터를 정상적으로 응답합니다.</li>\n  <li>사용자가 만료된 Access Token을 가지고 API 요청을 하면 서버는 401 인증 에러를 반환합니다. 이때 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받고, 갱신된 Access Token으로 API를 재요청하여 정상적으로 데이터를 받을 수 있습니다.</li>\n  <li>하지만 만약 사용자의 Refresh Token까지 만료된 상태라면, 서버는 최종적으로 401 인증 에러를 반환하여 사용자의 다시 로그인을 요구합니다.</li>\n</ol>\n\n<p>위 과정을 통해 일반적으로 Access Token의 만료 시간을 짧게 설정하여 Access Token의 탈취 위험을 최소화하고, Refresh Token을 통해 사용자 편의성 또한 유지할 수 있습니다.</p>\n\n<p>아래 그림을 통해 Access Token의 탈취로 인한 공격 시나리오로 Access Token의 만료시간이 짧으면 짧을수록 보안 위험도가 감소하게 됩니다.</p>\n\n<p><img src=\"/images/improve-auth/malicous-case1.png\" alt=\"malicous-case1\" /></p>\n\n<p>이처럼 Refresh Token을 적절히 도입하고 관리하면 토큰 탈취로 인한 보안 위험을 효과적으로 감소시킬 뿐만 아니라 사용자가 매번 로그인해야 하는 문제도 해결할 수 있으므로 사용성도 함께 챙길 수 있게 됩니다.</p>\n\n<h2 id=\"refresh-token-rotation\">Refresh Token Rotation</h2>\n\n<p>한편, Access Token에 대한 탈취 위험은 Refresh Token도 동일한 것 아닌가? 라는 질문을 할 수 있을 것 같습니다. 맞습니다. Refresh Token이 탈취당하면 Access Token을 갱신할 수 있고 갱신된 Access Token을 통해 악의적 사용자는 손쉽게 탈취한 사용자인 척 서비스를 이용할 수 있게 됩니다.</p>\n\n<p>이러한 문제를 해결하기 위해 우리는 <a href=\"https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation\" target=\"\\_blank\">Refresh Token Rotation</a> 을 도입하기로 합니다. Refresh Token Rotation은 아래와 같이 Refresh Token을 이용해 Access Token을 갱신할 때 Refresh Token도 함께 갱신하여 Refresh Token 탈취 시 발생할 수 있는 위험을 회피합니다.</p>\n\n<p><img src=\"/images/improve-auth/malicous-case2.png\" alt=\"malicous-case2\" /></p>\n\n<h1 id=\"이슈\">이슈</h1>\n\n<h2 id=\"클라이언트의-네트워크-이슈\">클라이언트의 네트워크 이슈</h2>\n\n<p>앞서 저희는 Refresh Token Rotation을 이용하여 Refresh Token 탈취에 대한 위험성을 회피하고자 하였습니다. 이렇게 하면 Refresh Token을 이용하여 Access Token을 갱신 요청할 때 요청한 Refresh Token도 새롭게 발급되어 더 이상 Refresh Token을 사용할 수 없게 되는데요. 보안 수준은 강화되었지만, 클라이언트 개발자분들이 한가지 우려 점을 제기해 주셨습니다.</p>\n\n<p>모바일 기기 특성상 지하실이나 엘리베이터안과같이 네트워크가 원활하지 않은 곳에서 사용할 가능성이 존재하는데요. 이때 아래 그림과 같이 첫 번째 요청한 Refresh Token을 재요청하는 경우가 발생할 수 있습니다. 하지만 Refresh Token을 매번 갱신하기 때문에 동일한 Refresh Token으로 여러번 Access Token을 갱신요청하게 된다면 두번째 요청부터는  인증 에러가 발생하게 됩니다.</p>\n\n<p><img src=\"/images/improve-auth/network-issue-case.png\" alt=\"network-issue-case\" /></p>\n\n<p>그래서 저희는 <a href=\"https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation#automatic-reuse-detection\" target=\"\\_blank\">Token Family 방식</a> 을 사용하여 요청 시마다 기존 Refresh Token을 지우지 않고 과거 토큰을 저장해 두었다가 첫 번째 요청으로 새롭게 발급된 토큰 또는 모종의 이유로 인해 갱신하지 못한 기존 토큰으로 토큰 갱신 요청을 할 수 있도록 구현하여 Refresh Token을 재사용할 수 있도록 하였습니다.</p>\n\n<p><img src=\"/images/improve-auth/token-family-flow.png\" alt=\"token-family-flow\" /></p>\n\n<p>이로써 클라이언트는 네트워크 이슈가 발생해도 Refresh Token을 갱신할 수 있게 되었습니다.</p>\n\n<p><img src=\"/images/improve-auth/resolved-network-issue-flow.png\" alt=\"resolved-network-issue-flow\" /></p>\n\n<h2 id=\"인증-토큰의-하위-호환\">인증 토큰의 하위 호환</h2>\n\n<p>한편, 저희는 JWT를 다루는 라이브러리로 <a href=\"https://github.com/spoqa/jjwt\" target=\"\\_blank\">JJWT</a> 를 사용하고 있습니다. 앞서 JWT는 상태를 가지지 않기 때문에 사용자가 사용하는 Access Token을 서버에서 제어할 수 없다고 말씀드렸었는데요. 그래서 Access Token의 만료 시간을 두어 새롭게 Access Token을 발급받도록 하여 우회적으로 제어할 수 있습니다. Access Token을 만료시키는 또 다른 방법은, 해당 토큰을 생성할 때 사용된 암호키를 변경하는 것입니다. 저희는 그래서 클라이언트에서 사용하는 Access Token을 만료시키고 새롭게 변경된 권한을 사용하는 Access Token으로 사용하도록 하기 위해 암호키를 바꾸기로 하였습니다. 다만 여기서 발생하는 문제가 바로 앱의 업데이트 타이밍이었습니다.</p>\n\n<p>개발자라면 다들 잘 아시겠지만, 서버와 앱은 동일한 시점에 개발이 완료되더라도 배포되는 시점이 다를 수 있습니다. 서버는 배포하는 즉시 배포가 되지만 앱은 심사 과정이 필요하고 배포가 되더라도 앱스토어에 배포된 버전이 전파되기까지 1일 이상 소요될 수 있습니다. 그러다 보니 Access Token을 변경하기 위해 키를 변경하게 되면 서버가 배포된 이후부터 앱이 업데이트되기 전까지 사용자가 서비스를 이용할 수 없다는 문제가 생길 수 있습니다. 그래서 저희는 과거 버전의 앱에서도 새롭게 배포된 서버의 인증을 문제없이 사용할 수 있도록 방법을 모색해야 했습니다.</p>\n\n<h3 id=\"jjwt-버전-변경\">JJWT 버전 변경</h3>\n\n<p>한편, 저희는 비밀키를 바꾸는 김에, 과거에 사용하던 서명 알고리즘(HS256)에 비해 보안성이 강화된 서명 알고리즘(PS256)을 변경하기로 합니다. 그러다 보니 JJWT라이브러리 버전을 업그레이드해야 했는데요. Gradle에 아래처럼 동일한 라이브러리를 서로 다른 버전으로 사용하는 경우 패키지 충돌이 발생하여 신규 버전에서 제공하는 함수를 사용할 수 없게 됩니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 구버전</span>\n<span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt:0.9.1\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\">// 신규버전</span>\n<span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-api:0.12.6\"</span><span class=\"p\">)</span>\n<span class=\"nf\">runtimeOnly</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-impl:0.12.6\"</span><span class=\"p\">)</span>\n<span class=\"nf\">runtimeOnly</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-jackson:0.12.6\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><img src=\"/images/improve-auth/jjwt-version-conflict.png\" alt=\"jjwt-version-conflict\" /></p>\n\n<p>이러한 문제를 해결하기 위해 저희는 <a href=\"https://jitpack.io/\" target=\"\\_blank\">Jitpack</a> 을 사용하기로 합니다. JitPack은 GitHub에 호스팅된 라이브러리를 쉽게 빌드하고 배포할 수 있게 해주는 Maven/Gradle 용 리포지터리 서비스입니다. GitHub 저장소를 바탕으로 라이브러리를 빌드하므로, 별도의 중앙 저장소(예: Maven Central) 등록 과정을 거치지 않아도 된다는 장점이 있습니다. 그리고 오픈소스 저장소에, 한에 무료로 사용할 수 있다는 점도 장점입니다.</p>\n\n<p>저희는 JJWT 라이브러리를 fork하여 <a href=\"https://github.com/spoqa/jjwt\" target=\"\\_blank\">Spoqa용 JJWT Github 저장소</a> 를 생성하였습니다. 그런 다음 충돌 패키지 충돌이 발생하지 않도록 패키지명을 변경해 주었습니다.</p>\n\n<p><img src=\"/images/improve-auth/changed-package-commit.png\" alt=\"changed-package-commit\" /></p>\n\n<p>그런 다음 Release를 생성해 주면, 아래와 같이 Jitpack에서 조회할 수 있게 됩니다.</p>\n\n<p><img src=\"/images/improve-auth/jitpack.png\" alt=\"jitpack\" /></p>\n\n<p>마지막으로 아래와 같이 Gradle에 의존성을 추가해주면, 패키지명이 변경된 JJWT라이브러리를 사용할 수 있게 됩니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"com.github.spoqa:jjwt:1.0.2\"</span><span class=\"p\">)</span>\n<span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"javax.xml.bind:jaxb-api:2.3.1\"</span><span class=\"p\">)</span>\n\n<span class=\"nf\">implementation</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-api:0.12.6\"</span><span class=\"p\">)</span>\n<span class=\"nf\">runtimeOnly</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-impl:0.12.6\"</span><span class=\"p\">)</span>\n<span class=\"nf\">runtimeOnly</span><span class=\"p\">(</span><span class=\"s\">\"io.jsonwebtoken:jjwt-jackson:0.12.6\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<h3 id=\"composite-패턴-vs-tokenmanager\">Composite 패턴 vs TokenManager</h3>\n\n<p>저희는 Jitpack으로 생성한 과거버전의 JJWT를 의존하는 구현체를 아래와 같이 <code class=\"language-plaintext highlighter-rouge\">LegacyJwtProcessor</code>로 변경하고 신규 버전을 사용하는 <code class=\"language-plaintext highlighter-rouge\">JwtProcessor</code>를 새롭게 생성하였습니다. 그런 다음 아래와 같이 인증 로직에 과거 버전의 Access Token과 신규 버전의 Access Token을 모두 수용할 수 있도록 구현하였습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Component</span>\n<span class=\"kd\">class</span> <span class=\"nc\">JwtAuthenticationProvider</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">legacyJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">LegacyJwtProcessor</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">jwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">AuthenticationProvider</span> <span class=\"p\">{</span>\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">authenticate</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Authentication</span><span class=\"p\">):</span> <span class=\"nc\">Authentication</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(!</span><span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">))</span> <span class=\"k\">return</span> <span class=\"k\">null</span>\n\n        <span class=\"kd\">val</span> <span class=\"py\">principal</span> <span class=\"p\">=</span>\n            <span class=\"k\">try</span> <span class=\"p\">{</span>\n                <span class=\"n\">jwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">.</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">())</span>\n            <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nc\">AuthenticationException</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">legacyJwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">.</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">())</span>\n            <span class=\"p\">}</span>\n\n        <span class=\"k\">return</span> <span class=\"nc\">JwtUserAuthenticationToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Class</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;):</span> <span class=\"nc\">Boolean</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">authentication</span> <span class=\"p\">==</span> <span class=\"nc\">JwtPreAuthenticationToken</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이렇게 구현하면 앱이 배포되기 전에 서버가 먼저 배포되어도 기존 버전을 사용하는 사용자가 정상적으로 로그인을 유지할 수 있게 됩니다.</p>\n\n<p>한편, 인증 로직을 구현하는 곳 말고도 LegacyJwtProcessor를 사용하는 곳이 다수 존재하였는데요. 그러다 보니 새롭게 만들어진 JwtProcessor로 전환하는 것을 누락할 가능성이 존재하였습니다. 다행히 기능 테스트가 있어 놓친 구현을 바로잡을 순 있었지만, 코드의 응집성 측면에서는 좋은 코드는 아니라 생각하였습니다.</p>\n\n<p>그래서 Composite 패턴을 사용해서 아래와 같이 구현해 볼지 생각을 하였습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">interface</span> <span class=\"nc\">JwtProcessor</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">generateToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">CompositeJwtProcessor</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">newJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">legacyJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n<span class=\"p\">):</span> <span class=\"nc\">JwtProcessor</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">generateToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">try</span> <span class=\"p\">{</span>\n            <span class=\"n\">jwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nc\">AuthenticationException</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">legacyJwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">NewJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">generateToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"err\">legacy</span><span class=\"nc\">JwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">generateToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">CompositeJwtProcessor</code>를 이용하면 아래와 같이 <code class=\"language-plaintext highlighter-rouge\">JwtAuthenticationProvider</code>는 더 이상 <code class=\"language-plaintext highlighter-rouge\">legacyJwtProcessor</code>를 알지 않아도 되고 추후 <code class=\"language-plaintext highlighter-rouge\">legacyJwtProcessor</code>가 제거되어도 영향범위는 <code class=\"language-plaintext highlighter-rouge\">CompositeJwtProcessor</code>로 한정되기 때문에 응집도 높은 코드를 유지할 수 있게 됩니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Component</span>\n<span class=\"kd\">class</span> <span class=\"nc\">JwtAuthenticationProvider</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">compositeJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">AuthenticationProvider</span> <span class=\"p\">{</span>\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">authenticate</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Authentication</span><span class=\"p\">):</span> <span class=\"nc\">Authentication</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(!</span><span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">))</span> <span class=\"k\">return</span> <span class=\"k\">null</span>\n\n        <span class=\"kd\">val</span> <span class=\"py\">principal</span> <span class=\"p\">=</span> <span class=\"n\">compositeJwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">.</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">())</span>\n\n        <span class=\"k\">return</span> <span class=\"nc\">JwtUserAuthenticationToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n    \n    <span class=\"c1\">// 생략...</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>다른 방법으로는 TokenManager라는 상위 수준의 클래스를 만들어 응집도를 높이는 방법도 생각해 보았습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">class</span> <span class=\"nc\">TokenManager</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">jwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">JwtProcessor</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">legacyJwtProcessor</span><span class=\"p\">:</span> <span class=\"nc\">LegacyJwtProcessor</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">refreshTokenService</span><span class=\"p\">:</span> <span class=\"nc\">RefreshTokenService</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">UserPrincipal</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">try</span> <span class=\"p\">{</span>\n            <span class=\"n\">jwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nc\">AuthenticationException</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">legacyJwtProcessor</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">fun</span> <span class=\"nf\">generateAccessToken</span><span class=\"p\">(</span><span class=\"n\">userPrincipal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">fun</span> <span class=\"nf\">generateRefreshToken</span><span class=\"p\">(</span><span class=\"n\">entity</span><span class=\"p\">:</span> <span class=\"nc\">RefreshToken</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">fun</span> <span class=\"nf\">replaceRefreshToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">:</span> <span class=\"nc\">RefreshTokenUserPrincipal</span><span class=\"p\">):</span> <span class=\"nc\">String</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 생략...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이렇게 하면 Token을 Composite 패턴을 사용한 것과 같이 하위호환을 지키는 코드와 함께 토큰과 관련된 다른 기능들도 해당 클래스로 모을 수 있어 응집도를 상당히 높일 수 있게 됩니다.</p>\n\n<p>어떤 방식이 더 나은 방식이라고 말씀드리긴 어려울 것 같습니다. 다만, 저희는 LegacyJwtProcessor는 앱 배포 이후에 제거될 클래스이므로 불필요하게 Composite 패턴을 사용하기보다 TokenManager를 생성하여 코드 응집도를 높이는 방법으로 결정하게 되었습니다.</p>\n\n<h3 id=\"spring-security---preauthorize\">Spring Security - PreAuthorize</h3>\n\n<p>저희는 인증과 인가를 위해 Spring Security를 사용하고 있습니다. JWT를 통해 인증된 사용자는 UserPrincipal이라는 인증된 사용자로 변환되고 UserPrinciapl이 가진 authorities를 통해 권한 처리를 하고 있습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Component</span>\n<span class=\"kd\">class</span> <span class=\"nc\">AccessTokenAuthenticationProvider</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">tokenManager</span><span class=\"p\">:</span> <span class=\"nc\">TokenManager</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">AuthenticationProvider</span> <span class=\"p\">{</span>\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">authenticate</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Authentication</span><span class=\"p\">):</span> <span class=\"nc\">Authentication</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(!</span><span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">))</span> <span class=\"k\">return</span> <span class=\"k\">null</span>\n\n        <span class=\"kd\">val</span> <span class=\"py\">principal</span> <span class=\"p\">=</span> <span class=\"n\">tokenManager</span><span class=\"p\">.</span><span class=\"nf\">getPrincipal</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">.</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">())</span>\n        <span class=\"k\">return</span> <span class=\"nc\">AccessTokenAuthenticationToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">supports</span><span class=\"p\">(</span><span class=\"n\">authentication</span><span class=\"p\">:</span> <span class=\"nc\">Class</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;):</span> <span class=\"nc\">Boolean</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">authentication</span> <span class=\"p\">==</span> <span class=\"nc\">AccessTokenPreAuthenticationToken</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">AccessTokenAuthenticationToken</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">principal</span><span class=\"p\">:</span> <span class=\"nc\">UserPrincipal</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nc\">AbstractAuthenticationToken</span><span class=\"p\">(</span><span class=\"n\">principal</span><span class=\"p\">.</span><span class=\"n\">authorities</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nf\">init</span> <span class=\"p\">{</span>\n        <span class=\"k\">super</span><span class=\"p\">.</span><span class=\"nf\">setAuthenticated</span><span class=\"p\">(</span><span class=\"k\">true</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">getPrincipal</span><span class=\"p\">()</span> <span class=\"p\">=</span> <span class=\"n\">principal</span>\n\n    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">getCredentials</span><span class=\"p\">()</span> <span class=\"p\">=</span> <span class=\"k\">null</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>사용자는 아래와 같이 <code class=\"language-plaintext highlighter-rouge\">@Secured</code>를 통해 권한을 검증받고 API를 호출할 수 있습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@DgsMutation</span>\n<span class=\"nd\">@Secured</span><span class=\"p\">(</span><span class=\"nc\">STORE_ADMIN</span><span class=\"p\">,</span> <span class=\"nc\">STORE_MANAGER</span><span class=\"p\">,</span> <span class=\"nc\">VENDOR</span><span class=\"p\">)</span>\n<span class=\"k\">fun</span> <span class=\"nf\">createOrderSheet</span><span class=\"p\">(</span>\n    <span class=\"nd\">@InputArgument</span> <span class=\"n\">input</span><span class=\"p\">:</span> <span class=\"nc\">CreateOrderSheetInput</span><span class=\"p\">,</span>\n<span class=\"p\">):</span> <span class=\"nc\">CreateOrderSheet</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 생략...</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">@Secured</code>는 단순한 권한 Role 기반 접근을 제어하기에 적절합니다. 이전까지 키친보드는 관리자, 매장 사용자, 유통사 사용자로 명확하게 Role이 나뉘어져 있었기 때문에 <code class=\"language-plaintext highlighter-rouge\">@Secured</code>는 요구사항을 충분히 충족하면서 단순하게 구현할 방법이었습니다.</p>\n\n<p>하지만 새로운 요구사항이 추가되면서 매장 사용자는 매장 관리자, 매장 직원으로 권한이 분리되게 되었는데요. 이에 따라 매장 사용자 모두 접근을 할 수 있는 API에는 아래와 같이 <code class=\"language-plaintext highlighter-rouge\">@Secured(STORE_ADMIN, STORE_MANAGER)</code> 표현해야 하는 불편함이 있게 됩니다. 거기다 만약 <code class=\"language-plaintext highlighter-rouge\">STORE_INTERN</code>이 추가된다면 매장 사용자 권한을 가져야 하는 API를 모두 찾아서 바꿔줘야 하니 상당히 번거로운 작업이 될 것이고 자칫 권한 변경을 누락할 수 있는 위험성 또한 내포하고 있습니다.</p>\n\n<p>이와 같은 문제를 해소하기 위해 Spring Security에서는 <code class=\"language-plaintext highlighter-rouge\">@PreAuthorize</code>를 이용하여 유연하게 권한을 체크하는 기능을 제공합니다. 그래서 저희는 아래와 같이 매장 사용자 여부를 확인하는 서비스 함수를 만들어 <a href=\"https://docs.spring.io/spring-framework/reference/core/expressions.html\" target=\"\\_blank\">SpEL</a> 을 이용해 권한을 체크하도록 함으로써 권한을 일일이 나열하지 않고 새로운 권한이 생기더라도 유연하게 대처할 수 있도록 하였습니다.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@PostMapping</span><span class=\"p\">(</span><span class=\"s\">\"/replace-store\"</span><span class=\"p\">)</span>\n<span class=\"nd\">@PreAuthorize</span><span class=\"p\">(</span><span class=\"s\">\"@authorizationExpressionHelper.isManager()\"</span><span class=\"p\">)</span>\n<span class=\"k\">fun</span> <span class=\"nf\">replaceStore</span><span class=\"p\">(</span><span class=\"nd\">@RequestBody</span> <span class=\"n\">request</span><span class=\"p\">:</span> <span class=\"nc\">ReplaceStoreRequest</span><span class=\"p\">):</span> <span class=\"nc\">ReplaceStoreResponse</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 생략...</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Service</span>\n<span class=\"kd\">class</span> <span class=\"nc\">AuthorizationExpressionHelper</span> <span class=\"p\">{</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">isManager</span><span class=\"p\">():</span> <span class=\"nc\">Boolean</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nc\">PrincipalProvider</span><span class=\"p\">.</span><span class=\"n\">userPrincipal</span><span class=\"p\">.</span><span class=\"n\">isManager</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h1 id=\"마무리\">마무리</h1>\n\n<p>지금까지 저희가 권한 기능을 추가하기 위해 인증 로직을 어떻게 개선하였고 개선하면서 겪었던 이슈들을 공유해 보았습니다. 단순히 권한을 추가해 달라는 요구사항에서 시작되었지만, 그동안 우리가 가지고 있던 기술 부채도 해결함과 동시에 기술적인 여러 고민을 할 수 있어서 개인적으로 배운 게 많은 프로젝트였습니다.</p>\n\n<p>모쪼록 인증 기능 구현에 관심이 있으시거나 예정인 분들께 도움이 되었으면 합니다.</p>\n\n<p>긴 글 읽어주셔서 감사합니다.</p>\n",
        "contentSnippet": "안녕하세요. 스포카 백엔드팀 프로그래머 남경호입니다.\n개발자라면 누구나 오랫동안 미뤄두었던 과제가 하나쯤 있을 것입니다. 업무의 우선순위가 낮거나 긴급한 과제들에 밀려 지속적으로 백로그에 쌓여 있던 작업 말이죠. 최근 저희팀에서 왜 오랜 시간 미뤄두었던 인증 방식 개선 작업을 진행하게 되었는지, 그 과정에서 얻은 여러 경험을 여러분께 공유하고자 합니다.\n배경\n스포카 블로그를 꾸준히 보신 분이라면, 서버 언어 전환 이야기 글에서 JWT 관련 문제를 언급하며 향후 개선할 예정이라고 소개했던 내용을 기억하실 겁니다.\n\n약 3년이 흐른 지금, 드디어 저희가 인증 방식 개선을 진행하게 된 가장 큰 이유는 바로 키친보드 매장 앱에 권한관리 기능이 추가되었기 때문입니다.\n\n키친보드 매장 앱은 식자재 주문부터 거래대금 결제까지 다양한 기능을 제공합니다. 이 과정에서 사장님은 직원이 매장의 월 거래 내역 등 민감한 정보를 조회하지 못하도록 권한을 제어할 필요가 생겼는데요. 기존 JWT 인증은 무 상태(stateless) 특성상 권한 변경 시 즉각적으로 클라이언트의 인증 상태를 관리할 수 없다는 한계가 있었습니다.\n그래서 저희는 권한 기능을 추가하기에 앞서 인증 방식을 먼저 개선하기로 하였습니다.\n인증 방식 개선 방법\nRefresh Token 도입\n앞서 이야기했듯이, JWT 기반의 인증 방식은 서버가 사용자의 상태를 저장하지 않습니다. 덕분에 서버의 확장성이 높고 서버 부하를 줄일 수 있다는 장점이 있지만, 한번 발급된 토큰을 서버에서 직접 제어할 수 없다는 단점이 있습니다.\n이러한 특성은 보안 문제로 연결될 수 있는데요. 만약 인증을 통해 발급받은 토큰이 탈취된다면, 서버가 이 토큰을 제어할 수 없으므로 악의적인 사용자는 손쉽게 탈취된 토큰을 이용하여 정상 사용자처럼 서비스를 이용할 수 있게 됩니다. 보통 이러한 보안 위험을 방지하기 위해 Access Token의 만료 시간을 짧게 설정하지만, 이 경우 사용자가 자주 로그인해야 하는 번거로움이 발생하게 됩니다.\n이와 같은 문제를 해결할 수 있는 대표적인 방법의 하나가 바로 Refresh Token 의 도입입니다. Refresh Token은 Access Token과 달리 서버가 상태를 관리하는 토큰으로, Access Token을 갱신하는 데 사용됩니다. 앞서 말씀드린 대로, Access Token의 탈취 위험을 낮추기 위해 Access Token의 만료 시간을 짧게 설정하는 것이 좋은데요. 이때 Refresh Token을 활용하면 사용자가 Access Token의 만료 시점마다 다시 로그인하지 않아도 편리하게 새로운 Access Token을 발급받을 수 있습니다.\n다음 그림에서 Access Token과 Refresh Token의 인증 과정을 자세히 확인할 수 있습니다.\n\n사용자가 로그인을 요청하면 서버는 Access Token과 Refresh Token을 발급합니다.\n사용자는 발급받은 유효한 Access Token을 이용해 API를 호출하고, 서버는 요청된 데이터를 정상적으로 응답합니다.\n사용자가 만료된 Access Token을 가지고 API 요청을 하면 서버는 401 인증 에러를 반환합니다. 이때 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받고, 갱신된 Access Token으로 API를 재요청하여 정상적으로 데이터를 받을 수 있습니다.\n하지만 만약 사용자의 Refresh Token까지 만료된 상태라면, 서버는 최종적으로 401 인증 에러를 반환하여 사용자의 다시 로그인을 요구합니다.\n위 과정을 통해 일반적으로 Access Token의 만료 시간을 짧게 설정하여 Access Token의 탈취 위험을 최소화하고, Refresh Token을 통해 사용자 편의성 또한 유지할 수 있습니다.\n아래 그림을 통해 Access Token의 탈취로 인한 공격 시나리오로 Access Token의 만료시간이 짧으면 짧을수록 보안 위험도가 감소하게 됩니다.\n\n이처럼 Refresh Token을 적절히 도입하고 관리하면 토큰 탈취로 인한 보안 위험을 효과적으로 감소시킬 뿐만 아니라 사용자가 매번 로그인해야 하는 문제도 해결할 수 있으므로 사용성도 함께 챙길 수 있게 됩니다.\nRefresh Token Rotation\n한편, Access Token에 대한 탈취 위험은 Refresh Token도 동일한 것 아닌가? 라는 질문을 할 수 있을 것 같습니다. 맞습니다. Refresh Token이 탈취당하면 Access Token을 갱신할 수 있고 갱신된 Access Token을 통해 악의적 사용자는 손쉽게 탈취한 사용자인 척 서비스를 이용할 수 있게 됩니다.\n이러한 문제를 해결하기 위해 우리는 Refresh Token Rotation 을 도입하기로 합니다. Refresh Token Rotation은 아래와 같이 Refresh Token을 이용해 Access Token을 갱신할 때 Refresh Token도 함께 갱신하여 Refresh Token 탈취 시 발생할 수 있는 위험을 회피합니다.\n\n이슈\n클라이언트의 네트워크 이슈\n앞서 저희는 Refresh Token Rotation을 이용하여 Refresh Token 탈취에 대한 위험성을 회피하고자 하였습니다. 이렇게 하면 Refresh Token을 이용하여 Access Token을 갱신 요청할 때 요청한 Refresh Token도 새롭게 발급되어 더 이상 Refresh Token을 사용할 수 없게 되는데요. 보안 수준은 강화되었지만, 클라이언트 개발자분들이 한가지 우려 점을 제기해 주셨습니다.\n모바일 기기 특성상 지하실이나 엘리베이터안과같이 네트워크가 원활하지 않은 곳에서 사용할 가능성이 존재하는데요. 이때 아래 그림과 같이 첫 번째 요청한 Refresh Token을 재요청하는 경우가 발생할 수 있습니다. 하지만 Refresh Token을 매번 갱신하기 때문에 동일한 Refresh Token으로 여러번 Access Token을 갱신요청하게 된다면 두번째 요청부터는  인증 에러가 발생하게 됩니다.\n\n그래서 저희는 Token Family 방식 을 사용하여 요청 시마다 기존 Refresh Token을 지우지 않고 과거 토큰을 저장해 두었다가 첫 번째 요청으로 새롭게 발급된 토큰 또는 모종의 이유로 인해 갱신하지 못한 기존 토큰으로 토큰 갱신 요청을 할 수 있도록 구현하여 Refresh Token을 재사용할 수 있도록 하였습니다.\n\n이로써 클라이언트는 네트워크 이슈가 발생해도 Refresh Token을 갱신할 수 있게 되었습니다.\n\n인증 토큰의 하위 호환\n한편, 저희는 JWT를 다루는 라이브러리로 JJWT 를 사용하고 있습니다. 앞서 JWT는 상태를 가지지 않기 때문에 사용자가 사용하는 Access Token을 서버에서 제어할 수 없다고 말씀드렸었는데요. 그래서 Access Token의 만료 시간을 두어 새롭게 Access Token을 발급받도록 하여 우회적으로 제어할 수 있습니다. Access Token을 만료시키는 또 다른 방법은, 해당 토큰을 생성할 때 사용된 암호키를 변경하는 것입니다. 저희는 그래서 클라이언트에서 사용하는 Access Token을 만료시키고 새롭게 변경된 권한을 사용하는 Access Token으로 사용하도록 하기 위해 암호키를 바꾸기로 하였습니다. 다만 여기서 발생하는 문제가 바로 앱의 업데이트 타이밍이었습니다.\n개발자라면 다들 잘 아시겠지만, 서버와 앱은 동일한 시점에 개발이 완료되더라도 배포되는 시점이 다를 수 있습니다. 서버는 배포하는 즉시 배포가 되지만 앱은 심사 과정이 필요하고 배포가 되더라도 앱스토어에 배포된 버전이 전파되기까지 1일 이상 소요될 수 있습니다. 그러다 보니 Access Token을 변경하기 위해 키를 변경하게 되면 서버가 배포된 이후부터 앱이 업데이트되기 전까지 사용자가 서비스를 이용할 수 없다는 문제가 생길 수 있습니다. 그래서 저희는 과거 버전의 앱에서도 새롭게 배포된 서버의 인증을 문제없이 사용할 수 있도록 방법을 모색해야 했습니다.\nJJWT 버전 변경\n한편, 저희는 비밀키를 바꾸는 김에, 과거에 사용하던 서명 알고리즘(HS256)에 비해 보안성이 강화된 서명 알고리즘(PS256)을 변경하기로 합니다. 그러다 보니 JJWT라이브러리 버전을 업그레이드해야 했는데요. Gradle에 아래처럼 동일한 라이브러리를 서로 다른 버전으로 사용하는 경우 패키지 충돌이 발생하여 신규 버전에서 제공하는 함수를 사용할 수 없게 됩니다.\n\n// 구버전\nimplementation(\"io.jsonwebtoken:jjwt:0.9.1\")\n\n// 신규버전\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\n\n이러한 문제를 해결하기 위해 저희는 Jitpack 을 사용하기로 합니다. JitPack은 GitHub에 호스팅된 라이브러리를 쉽게 빌드하고 배포할 수 있게 해주는 Maven/Gradle 용 리포지터리 서비스입니다. GitHub 저장소를 바탕으로 라이브러리를 빌드하므로, 별도의 중앙 저장소(예: Maven Central) 등록 과정을 거치지 않아도 된다는 장점이 있습니다. 그리고 오픈소스 저장소에, 한에 무료로 사용할 수 있다는 점도 장점입니다.\n저희는 JJWT 라이브러리를 fork하여 Spoqa용 JJWT Github 저장소 를 생성하였습니다. 그런 다음 충돌 패키지 충돌이 발생하지 않도록 패키지명을 변경해 주었습니다.\n\n그런 다음 Release를 생성해 주면, 아래와 같이 Jitpack에서 조회할 수 있게 됩니다.\n\n마지막으로 아래와 같이 Gradle에 의존성을 추가해주면, 패키지명이 변경된 JJWT라이브러리를 사용할 수 있게 됩니다.\n\nimplementation(\"com.github.spoqa:jjwt:1.0.2\")\nimplementation(\"javax.xml.bind:jaxb-api:2.3.1\")\n\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\nComposite 패턴 vs TokenManager\n저희는 Jitpack으로 생성한 과거버전의 JJWT를 의존하는 구현체를 아래와 같이 LegacyJwtProcessor로 변경하고 신규 버전을 사용하는 JwtProcessor를 새롭게 생성하였습니다. 그런 다음 아래와 같이 인증 로직에 과거 버전의 Access Token과 신규 버전의 Access Token을 모두 수용할 수 있도록 구현하였습니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val jwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal =\n            try {\n                jwtProcessor.getPrincipal(authentication.principal.toString())\n            } catch (e: AuthenticationException) {\n                legacyJwtProcessor.getPrincipal(authentication.principal.toString())\n            }\n\n        return JwtUserAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == JwtPreAuthenticationToken::class.java\n    }\n}\n\n\n이렇게 구현하면 앱이 배포되기 전에 서버가 먼저 배포되어도 기존 버전을 사용하는 사용자가 정상적으로 로그인을 유지할 수 있게 됩니다.\n한편, 인증 로직을 구현하는 곳 말고도 LegacyJwtProcessor를 사용하는 곳이 다수 존재하였는데요. 그러다 보니 새롭게 만들어진 JwtProcessor로 전환하는 것을 누락할 가능성이 존재하였습니다. 다행히 기능 테스트가 있어 놓친 구현을 바로잡을 순 있었지만, 코드의 응집성 측면에서는 좋은 코드는 아니라 생각하였습니다.\n그래서 Composite 패턴을 사용해서 아래와 같이 구현해 볼지 생각을 하였습니다.\n\ninterface JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String\n    fun getPrincipal(token: String): UserPrincipal\n}\n\nclass CompositeJwtProcessor(\n    private val newJwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: JwtProcessor,\n): JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n}\n\nclass NewJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\nclass legacyJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\n\nCompositeJwtProcessor를 이용하면 아래와 같이 JwtAuthenticationProvider는 더 이상 legacyJwtProcessor를 알지 않아도 되고 추후 legacyJwtProcessor가 제거되어도 영향범위는 CompositeJwtProcessor로 한정되기 때문에 응집도 높은 코드를 유지할 수 있게 됩니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val compositeJwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = compositeJwtProcessor.getPrincipal(authentication.principal.toString())\n\n        return JwtUserAuthenticationToken(principal)\n    }\n    \n    // 생략...\n}\n\n\n다른 방법으로는 TokenManager라는 상위 수준의 클래스를 만들어 응집도를 높이는 방법도 생각해 보았습니다.\n\n@Service\nclass TokenManager(\n    private val jwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val refreshTokenService: RefreshTokenService,\n) {\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n\n    fun generateAccessToken(userPrincipal: UserPrincipal): String {\n        // 생략...\n    }\n\n    fun generateRefreshToken(entity: RefreshToken): String {\n        // 생략...\n    }\n\n    fun replaceRefreshToken(principal: RefreshTokenUserPrincipal): String {\n        // 생략...\n    }\n}\n\n\n이렇게 하면 Token을 Composite 패턴을 사용한 것과 같이 하위호환을 지키는 코드와 함께 토큰과 관련된 다른 기능들도 해당 클래스로 모을 수 있어 응집도를 상당히 높일 수 있게 됩니다.\n어떤 방식이 더 나은 방식이라고 말씀드리긴 어려울 것 같습니다. 다만, 저희는 LegacyJwtProcessor는 앱 배포 이후에 제거될 클래스이므로 불필요하게 Composite 패턴을 사용하기보다 TokenManager를 생성하여 코드 응집도를 높이는 방법으로 결정하게 되었습니다.\nSpring Security - PreAuthorize\n저희는 인증과 인가를 위해 Spring Security를 사용하고 있습니다. JWT를 통해 인증된 사용자는 UserPrincipal이라는 인증된 사용자로 변환되고 UserPrinciapl이 가진 authorities를 통해 권한 처리를 하고 있습니다.\n\n@Component\nclass AccessTokenAuthenticationProvider(\n    private val tokenManager: TokenManager,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = tokenManager.getPrincipal(authentication.principal.toString())\n        return AccessTokenAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == AccessTokenPreAuthenticationToken::class.java\n    }\n}\n\nclass AccessTokenAuthenticationToken(\n    private val principal: UserPrincipal,\n) : AbstractAuthenticationToken(principal.authorities) {\n    init {\n        super.setAuthenticated(true)\n    }\n\n    override fun getPrincipal() = principal\n\n    override fun getCredentials() = null\n}\n\n\n사용자는 아래와 같이 @Secured를 통해 권한을 검증받고 API를 호출할 수 있습니다.\n\n@DgsMutation\n@Secured(STORE_ADMIN, STORE_MANAGER, VENDOR)\nfun createOrderSheet(\n    @InputArgument input: CreateOrderSheetInput,\n): CreateOrderSheet {\n    // 생략...\n}\n\n\n@Secured는 단순한 권한 Role 기반 접근을 제어하기에 적절합니다. 이전까지 키친보드는 관리자, 매장 사용자, 유통사 사용자로 명확하게 Role이 나뉘어져 있었기 때문에 @Secured는 요구사항을 충분히 충족하면서 단순하게 구현할 방법이었습니다.\n하지만 새로운 요구사항이 추가되면서 매장 사용자는 매장 관리자, 매장 직원으로 권한이 분리되게 되었는데요. 이에 따라 매장 사용자 모두 접근을 할 수 있는 API에는 아래와 같이 @Secured(STORE_ADMIN, STORE_MANAGER) 표현해야 하는 불편함이 있게 됩니다. 거기다 만약 STORE_INTERN이 추가된다면 매장 사용자 권한을 가져야 하는 API를 모두 찾아서 바꿔줘야 하니 상당히 번거로운 작업이 될 것이고 자칫 권한 변경을 누락할 수 있는 위험성 또한 내포하고 있습니다.\n이와 같은 문제를 해소하기 위해 Spring Security에서는 @PreAuthorize를 이용하여 유연하게 권한을 체크하는 기능을 제공합니다. 그래서 저희는 아래와 같이 매장 사용자 여부를 확인하는 서비스 함수를 만들어 SpEL 을 이용해 권한을 체크하도록 함으로써 권한을 일일이 나열하지 않고 새로운 권한이 생기더라도 유연하게 대처할 수 있도록 하였습니다.\n\n@PostMapping(\"/replace-store\")\n@PreAuthorize(\"@authorizationExpressionHelper.isManager()\")\nfun replaceStore(@RequestBody request: ReplaceStoreRequest): ReplaceStoreResponse {\n    // 생략...\n}\n\n@Service\nclass AuthorizationExpressionHelper {\n    fun isManager(): Boolean {\n        return PrincipalProvider.userPrincipal.isManager\n    }\n}\n\n\n마무리\n지금까지 저희가 권한 기능을 추가하기 위해 인증 로직을 어떻게 개선하였고 개선하면서 겪었던 이슈들을 공유해 보았습니다. 단순히 권한을 추가해 달라는 요구사항에서 시작되었지만, 그동안 우리가 가지고 있던 기술 부채도 해결함과 동시에 기술적인 여러 고민을 할 수 있어서 개인적으로 배운 게 많은 프로젝트였습니다.\n모쪼록 인증 기능 구현에 관심이 있으시거나 예정인 분들께 도움이 되었으면 합니다.\n긴 글 읽어주셔서 감사합니다.",
        "id": "https://spoqa.github.io/2025/04/18/improve-auth.html",
        "isoDate": "2025-04-18T00:00:00.000Z"
      }
    ]
  },
  {
    "name": "팀 왈도 번역팀",
    "category": "게임",
    "posts": []
  },
  {
    "name": "근원님",
    "category": "개인",
    "posts": []
  },
  {
    "name": "호돌맨",
    "category": "개인",
    "posts": []
  },
  {
    "name": "박우빈",
    "category": "개인",
    "posts": []
  },
  {
    "name": "문다영",
    "category": "개인",
    "posts": []
  },
  {
    "name": "유수민",
    "category": "개인",
    "posts": []
  },
  {
    "name": "안건주",
    "category": "개인",
    "posts": []
  },
  {
    "name": "손현호",
    "category": "개인",
    "posts": []
  },
  {
    "name": "STARTUP BIBLE",
    "category": "개인",
    "posts": [
      {
        "creator": "Kihong Bae",
        "title": "돈 버는 습관",
        "link": "https://www.thestartupbible.com/2025/04/profit-making-as-a-habit.html",
        "pubDate": "Wed, 16 Apr 2025 21:26:00 +0000",
        "content:encodedSnippet": "얼마 전에 우리의 오래된 투자사의 이사회 미팅에 참석했다. 아주 힘든 사업을 하고 있는데, 10년 전 창업할 땐, 창업가들도 이렇게 힘든 사업인 줄 몰랐고, 투자자들도 이렇게 힘든 사업인 줄 몰랐다. 그동안 실수도 많이 했고, 돈도 많이 까먹으면서 개고생했는데, 이제 회사가 어느 정도 안정적인 운영 방법을 찾았고, 그동안 마이너스 나는 사업을 하다가 작년부터 손익분기점을 넘으면서 흑자를 만들고 있다. 나도 이런 창업가들과 오랫동안 같이 일하다 보면 정말 많은 것을 느끼고 배운다. 사업에 대해서도 많이 배우지만, 실제론 인생에 대해서 정말 많이 배운다. 이런 힘든 사업을 무에서 시작해서 돈을 버는 과정을 옆에서 보다 보면, 가끔은 제삼자인 내가 토할 정도로 힘든 사업을 이분들은 어떻게 저렇게 버티면서 묵묵히 앞으로 나갈까,,,라는 존경심이 항상 생긴다. 어쨌든, 창업가 예찬은 다른 포스팅을 통해서 따로 하겠다.\n같은 이사회 멤버인 다른 투자자분이 이 회사가 드디어 돈을 벌기 시작한 것을 보고, “흑자를 내는 것도 습관입니다. 앞으로 계속 이 습관을 유지하세요.”라는 말씀을 했는데, 나도 이 말에 너무 격하게 공감했다. 사람은 습관의 동물이다. 일주일, 한 달, 일 년, 십 년의 반복을 통해서 만든 습관은 생활을 변하게 하고, 결국엔 인생을 바꿔놓는다. 습관을 만드는 것도 어렵고, 이후에 유지하는 것도 쉽지 않지만, 내 경험에 의하면 만드는 게 더 어렵다. 일단 한번 잘 만들어 놓으면, 몸이 기억하기 때문에 언제든지 이 습관을 불러 올 수 있다.\n회사가 돈 버는 것도 마찬가지다. 돈 버는 습관을 만드는 건 정말 어렵다. 하지만, 쓸데없는 짓 하지 않고, 거창한 스타트업 놀이하지 말고, 겉만 번지르르한 사업을 하지 않고, 그냥 매일, 일주일, 한 달, 일 년, 십 년 동안 어떻게 해서든지 돈을 벌기 위해서 노력하다 보면 돈 버는 게 습관화되고, 흑자를 내는 것도 습관이 된다. 한 번 만든 흑자는 두 번의 흑자를 만들고, 이는 평생의 흑자로 이어질 수 있는, 창업가들의 인생과 회사의 미래를 바꾸는 계기가 될 수 있다.\n얼마 전에 ‘슈퍼 마리오 효과‘라는 글을 썼는데, 돈을 버는 것도 이와 비슷한 맥락에서 생각해 볼 수 있다. 돈을 벌기 위해 수많은 시도를 해야 하고, 이를 계속 반복하다 보면, 실수를 많이 할 것이다. 실수하면, 우리 몸은 이 실수를 고치기 위해서 노력한다. 이 과정을 계속 반복하다 보면, 그리고 운이 좀 따른다면, 돈 버는 사업이 만들어지고, 이를 또한 계속 반복하다 보면 흑자가 만들어진다. 한 번 온몸으로 경험한 흑자 만드는 방법은 몸에 습관처럼 남기 때문에, 앞으로 이를 계속 반복할 가능성이 커진다.\n이는 마치 운동선수의 우승과 비슷하다. 이겨본 놈이 계속 이길 수 있다는 말을 우린 자주 하는데, 시합에서 한 번 이긴 선수는 승리의 자신감이 생기는데, 이 자신감은 뇌 일부분을 자극하고, 이 부분이 자극받으면 반복적으로 우승할 수 있다.\n흑자를 내는 것도 습관이다. 스타트업 놀이 말고, 돈 버는 걸 습관으로 만들어라.",
        "dc:creator": "Kihong Bae",
        "comments": "https://www.thestartupbible.com/2025/04/profit-making-as-a-habit.html#respond",
        "content": "얼마 전에 우리의 오래된 투자사의 이사회 미팅에 참석했다. 아주 힘든 사업을 하고 있는데, 10년 전 창업할 땐, 창업가들도 이렇게 힘든 사업인 줄 몰랐고, 투자자들도 이렇게 힘든 사업인 줄 몰랐다. 그동안 실수도 많이 했고, 돈도 많이 까먹으면서 개고생했는데, 이제 회사가 어느 정도 안정적인 운영 방법을 찾았고, 그동안 마이너스 나는 사업을 하다가 작년부터 손익분기점을 넘으면서 흑자를 만들고(...)",
        "contentSnippet": "얼마 전에 우리의 오래된 투자사의 이사회 미팅에 참석했다. 아주 힘든 사업을 하고 있는데, 10년 전 창업할 땐, 창업가들도 이렇게 힘든 사업인 줄 몰랐고, 투자자들도 이렇게 힘든 사업인 줄 몰랐다. 그동안 실수도 많이 했고, 돈도 많이 까먹으면서 개고생했는데, 이제 회사가 어느 정도 안정적인 운영 방법을 찾았고, 그동안 마이너스 나는 사업을 하다가 작년부터 손익분기점을 넘으면서 흑자를 만들고(...)",
        "guid": "https://www.thestartupbible.com/?p=9428",
        "categories": [
          "Uncategorized",
          "FoundersAtWork",
          "hustle",
          "inspiring",
          "sports",
          "Strong"
        ],
        "isoDate": "2025-04-16T21:26:00.000Z"
      },
      {
        "creator": "Kihong Bae",
        "title": "면접의 허상",
        "link": "https://www.thestartupbible.com/2025/04/stop-wasting-too-much-energy-on-interviews.html",
        "pubDate": "Sun, 13 Apr 2025 21:33:00 +0000",
        "content:encodedSnippet": "이 세상을 세상답게 돌아가게 하는 단 한 가지만 꼽으라면, 그건 ‘사람’이라고 할 수 있다. 사람이 사람과 일하고, 사람이 사람과 교류하면서 이 세상은 돌아가고, 더 좋은 세상으로 발전한다. 회사도 마찬가지다. 특히, 스타트업에서 가장 중요하고, 절대로 타협할 수 없는 단 한 가지만 선택하면, 그건 당연히 사람이다. 대표이사는 시간의 50%는 좋은 사람을 채용하는 데 사용해야 하고, 나머지 50%는 있는 사람들이 퇴사하지 않도록 하는 데 사용해야 한다. 지금 내가 채용하는 사람이 우리 회사 그 자체라는 점을 항상 명심해야 한다.\n그래서 우린 면접에 많은 공을 들인다. 면접의 방법도 갈수록 진화하고 있고, 더 좋은 사람을 채용하기 위한 노력의 하나로 면접의 횟수와 시간이 계속 늘어나고 있다. 얼마 전에 아는 분이 외국계 대기업의 시니어 매니저 레벨의 직책에 지원했는데, 6개월 동안 12번의 면접을 했다고 한다. 그런데 막판에 떨어졌다. 면접의 종류도 코딩하기, 케이스 풀기부터 술 마시기까지 정말 다양하게 세분되고 있다. 대기업들은 회사에 가장 적합한 인재 채용을 위한 면접 매뉴얼을 개발하기 위해 수억 원의 돈을 쓰면서 외부 컨설팅까지 받는다.\n그래서 우린 이런 고도화 된 면접 방법을 통해서 정말 더 좋은 사람을 채용하고 있을까? 개인적으로 봤을 땐, 아닌 것 같다. 내 개인적인 경험을 이야기해 보면, 면접을 아무리 잘해도, 이분이 실무는 정말 못 했던 적도 있고, 혼자서는 일을 잘 하는데 팀원들과 같이 했을 땐 팀워크 능력은 현저하게 떨어졌던 적도 있었다. 그리고 이건 내 주변의, 나보다 훨씬 더 많은 사람들을 면접하고 채용하는 매니저들도 비슷한 이야기를 한다. 면접을 20번 해도 그 사람이 실제로 일을 잘하는진 알 수 없고, 실제로 일을 잘해도, 우리 회사에서 일을 잘할 수 있을진 알 수가 없다.\n이게 면접의 현실이다. 면접은 단기간 안에 극적으로 향상할 수 있는 기술이기도 하고 – 입시 학원처럼, 면접 학원도 있다 – 일은 못 해도 말발만 살아 있으면, 면접에선 100점을 받을 수도 있기 때문이다.\n그럼 도대체 사람을 어떻게 채용해야 할까? 내가 아는 세 가지 방법이 있다.\n첫 번째 방법은, 일단 내가 잘 아는 사람만 채용하는 방법이다. 오래된 친구, 대학교 룸메이트, 동아리 선후배, 직장 동료나 선후배가 좋은 사례다. 우리가 투자한 회사 중 이렇게 오랫동안 서로를 알고 지낸 분들이 공동 창업가나 동료로 일하는 곳들이 큰 불협화음 없이 잘하는 걸 자주 경험한다. 하지만, 사람의 네트워크라는 게 한계가 있고, 회사가 성장하면 잘 아는 사람의 인재풀은 바닥나기 때문에 이 방법은 회사 규모가 작을 때만 작동한다.\n두 번째는, 6개월의 수습 기간을 갖고, 이후에 정식 채용을 결정하는 것이다. 면접을 아무리 잘해도 이분이 실제 일을 잘하는진 현장에서 확인해야 하는데, 2개월 정도의 수습은 약간 애매하다. 2개월 정도는 일을 잘하는 척 연기할 수도 있다. 하지만, 6개월을 연기하긴 어렵다. 6개월 같이 일해보면, 이분이 정말 일을 잘하는 분인지 충분히 파악된다. 또한, 일을 잘하는 분도 본인이 회사와 케미가 맞는지 판단해 봐야 하므로 6개월 정도의 수습 기간을 권장한다. 이런 제안에 격하게 반대하는 후보라면, 그리고 그 이유로 자존심과 모욕감 등을 언급하면 이건 적신호다.\n마지막 방법은, 채용보단 보상에 대한 방법이다. 내가 전에 이 글에서 이야기했는데, 면접을 기반으로 직책과 연봉을 결정하는 게 너무 어렵고 위험한 방법이기 때문에, 입사 시 ‘one 직책 one 연봉’ 제도를 도입하는 것이다. 이게 무슨 말이냐 하면, 컴공과를 막 졸업한 25살 엔지니어든, 15년 개발 경력이 있는 엔지니어든, 새로운 회사에 입사할 때 직책이 둘 다 시니어 소프트웨어 엔지니어라면, 이 두 분의 입사 연봉은 무조건 동일하게 가는 전략이다. 같은 직책이라도 과거의 경험이 많으면 연봉이 더 높고, 특히나 면접 때 말을 잘하면 연봉이 훨씬 더 높아지는 게 현대 사회의 채용 전략인데, 나는 이건 완전히 틀렸다고 본다. 경력이 많다고 그 일을 잘하는 건 절대로 아니고 – 오히려 그 반대의 경험을 정말 많이 했다 – 면접 때 말발에서 이기는 사람이 일을 더 잘하는 게 절대로 아니다. 그래서 입사할 땐 모두 다 연봉을 동일하게 가져가지만, 일 년 후 업무 평가에서 실제로 일을 더 잘하는 사람에게 연봉을 드라마틱하게 인상해 주는 방법이 좋은 사람을 계속 회사에 남게 하고, 아닌 사람은 퇴사하게 할 수 있는 좋은 방법이라고 생각한다.\n정답은 아니지만, 위 3개의 방법을 적절하게 활용하면 피곤한 면접 횟수는 줄일 수 있고, 더 좋은 인재를 채용할 수 있다. 실은, 어쩌면 한국은 사람을 해고하는 게 너무 힘들어서 안 내보낼 사람을 채용하기 위해서 면접을 더 중시하고, 더 신중하게 생각할지도 모르겠다. 한국의 경직된 해고 정책은 반드시 바꿔야 한다고 나는 개인적으로 생각한다.\n어쨌든, 이렇게 면접하고, 다양한 채용 방법을 사용하는 이유는 좋은 사람을 확보하기 위해서다. 좋은 사람이란 일을 잘하는 사람인데, 일을 잘하는 사람이란, 일이 주어지면, 그 일을 직접 할 수 있는 사람이다. 일이 주어지면, 그 일을 하기 위해서 사람을 또 채용하는 사람이 아니라.",
        "dc:creator": "Kihong Bae",
        "comments": "https://www.thestartupbible.com/2025/04/stop-wasting-too-much-energy-on-interviews.html#comments",
        "content": "이 세상을 세상답게 돌아가게 하는 단 한 가지만 꼽으라면, 그건 ‘사람’이라고 할 수 있다. 사람이 사람과 일하고, 사람이 사람과 교류하면서 이 세상은 돌아가고, 더 좋은 세상으로 발전한다. 회사도 마찬가지다. 특히, 스타트업에서 가장 중요하고, 절대로 타협할 수 없는 단 한 가지만 선택하면, 그건 당연히 사람이다. 대표이사는 시간의 50%는 좋은 사람을 채용하는 데 사용해야 하고, 나머지 50%는(...)",
        "contentSnippet": "이 세상을 세상답게 돌아가게 하는 단 한 가지만 꼽으라면, 그건 ‘사람’이라고 할 수 있다. 사람이 사람과 일하고, 사람이 사람과 교류하면서 이 세상은 돌아가고, 더 좋은 세상으로 발전한다. 회사도 마찬가지다. 특히, 스타트업에서 가장 중요하고, 절대로 타협할 수 없는 단 한 가지만 선택하면, 그건 당연히 사람이다. 대표이사는 시간의 50%는 좋은 사람을 채용하는 데 사용해야 하고, 나머지 50%는(...)",
        "guid": "https://www.thestartupbible.com/?p=9426",
        "categories": [
          "Uncategorized",
          "FoundersAtWork",
          "general",
          "people",
          "strategy",
          "스타트업 바이블 1",
          "스타트업 바이블 2",
          "스타트업 바이블 QA"
        ],
        "isoDate": "2025-04-13T21:33:00.000Z"
      }
    ]
  },
  {
    "name": "매거진 입맛",
    "category": "큐레이션",
    "posts": []
  },
  {
    "name": "요즘 IT",
    "category": "큐레이션",
    "posts": []
  },
  {
    "name": "지마켓 기술 블로그",
    "category": "기업",
    "posts": []
  },
  {
    "name": "Kimchi hill",
    "category": "큐레이션",
    "posts": []
  },
  {
    "name": "Hudi.blog",
    "category": "개인",
    "posts": []
  },
  {
    "name": "모나미",
    "category": "개인",
    "posts": []
  },
  {
    "name": "김진홍",
    "category": "개인",
    "posts": []
  }
]