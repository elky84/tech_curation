[
  {
    "id": 1,
    "imageUrl": "",
    "title": "체외충격파 시술에 대해",
    "description": "수영은 매우 안전한 운동지만, 그래도 오래 하다보면 자잘한 부상이 생기기 마련이다. 주로 어깨, 발꿈치, 가슴(흉통), 무릎, 발목을 주로 다치는데, 이 중에서 어깨나 무릎, 발목의 부상의 경우에는 체외충격파 시술이 상당히 좋은 듯 하다.\n \n수영을 하면서 가장 심각한 부상은 회전근개를 다쳤을 때였다. 배영과 접영을 열심히 하다가 어느 순간 통증이 있었는데 무식하게 기록을 더 줄여보겠다고 열심히 했었다. 결국 한쪽 어깨가 컵을 떨어뜨릴 정도로 악화된 상태로 병원에 갔다. 그 외에 한의원이나 여러가지도 있었는데, 솔직히 인대가 다친 것에는 한의원이 전혀 도움이 되지 않았다. 가장 좋은 치료는 재활의학과에서 놔주는 신경차단술 주사 치료와 체외충격파였다. 특히 체외충격파는 부위에 따라 5~10회 정도 받는데, 1주일에 1~2회씩 받았다. 시술 받을 때는 아프기만 하고 별다른 효과가 없어 보였는데, 3개월쯤 지나면 갑자기 좋아지는 것이 느껴졌고, 6개월쯤 지났을 때는 거의 완치에 가까울 정도로 통증이 사라졌다. 의사가 초음파로 치료 전후를 보여줬는데, 치료 후에는 염증이나 부종이 완전히 사라졌음을 알 수 있었다. 관절의 가동범위도 통증이 사라져서 그런지 매우 좋아졌다.\n \n체외충격파 시술의 강도\n체외충격파 시술을 받을 때는 강도를 무조건 강하게 하기보다는 약하게 하는 것도 괜찮다. 괜히 강하게 하는게 좋다고 생각해서 고통을 참으면서 시술받으면 나중에 오히려 몸살이 난다. 따라서 너무 아픈 것 같다면 치료사에게 강도를 낮춰달라고 하는게 좋다.\n \n체외충격파는 무조건 집중형\n체외충격파는 집중형과 방사형이 있는데, 대부분은 집중형을 사용하지만 발뒷꿈치에는 방사형을 많이 사용하는 것 같다. 하지만 솔직히 방사형은 효과가 별로였다. 나중에 효과를 못보니까 의사도 집중형으로 바꿔서 치료하자고 하였다. 물론 시술시 고통은 집중형이 훨씬 더 강하다. 방사형은 고통이라기보단 뭐로 긁는듯한 느낌이라 통증의 종류가 좀 다르다.\n체외충격파 집중형 vs 방사형\n\n\n검색해보면 근육통쪽에는 방사형이 더 좋다고 하는데, 근육통 때문에 체외충격파를 할 정도는 겪어본 적이 없어서 어떤 경우에 주로 사용하는지는 모르겠다.\n \n결론\n인대나 관절쪽이 다쳤을때 체외충격파 시술은 고통은 있지만 매우 효과적이며, 최소 5~10회정도를 추천한다. 개인적 경험이지만 정형외과보다는 재활의학과쪽이 좀 더 세밀하게 진료를 봐준다. 그리고 효과는 3개월 이후부터 서서히 발생하며, 6개월 정도 지나면 완치에 가깝게 통증이 사라지는 것 같다. 달리 말하면 꾹 참고 시술을 1개월만 받으면(보통 주2회니까 1개월이면 8회 시술), 3개월 이후부터는 운동을 해도 아프지 않을 것이다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://sunyzero.tistory.com/314",
    "pubDate": "Sat, 31 May 2025 18:54:59 +0900",
    "creator": "sunyzero",
    "categories": [
      "취미 관련/수영",
      "수영 부상",
      "체외충격파"
    ]
  },
  {
    "id": 2,
    "imageUrl": "",
    "title": "토스, 시각장애인 대상 맞춤형 금융교육 실시",
    "description": "자산 관리’부터 ‘보험 증권 분석’까지 체험 기반 금융교육 실시",
    "reviews": [],
    "syllabus": [],
    "link": "https://toss.im/tossfeed/article/financialedu",
    "pubDate": "Thu, 29 May 2025 02:36:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 3,
    "imageUrl": "",
    "title": "다시 2부 - Composable Architecture - 라우터 소개",
    "description": "원래는 Action 시스템을 활용해서 Router를 쓰려고 설계했지만, 필자가 기존에 사용하던 방식 중 하나로 돌아가 거기서부터 다시 설계되었다.\n이 라우터는 크게 두 가지 상황에 활용 가능하다.\nActivity 간 화면 이동\nCompose Navigation 간 화면 이동\n만약 싱글 액티비티(Single Activity) 구조를 쓴다면 Compose Navigation 부분만 적용하면 되니 더 쉽게 사용 가능하다.\n여기서는 어떻게 활용되었을까?\nActivity는 Dagger의 IntoMap을 활용해서 Key/Value 매핑으로 ActivityRoute를 상속받아 구현한 객체를 정의해서 사용한다.\nCompose Navigation은 NavigationRoute를 상속받아 구현한다.\n이 글에서는\n새로운 Router의 설계 철학 및 동작 방식을 자세히 알아본다.\nActivity 및 Compose Navigation에서 Router를 활용하는 구체적인 코드 예시를 살펴본다.\nRoute\nNavigationRoute는 드로이드 나이츠(Droid Knights) 프로젝트에도 적용되었으며, 다음 링크를 통해 라우팅 방식을 확인해볼 수 있다.\ndroidknights 2025 - Router\n이 글에서는 TComposableArchitecture - GitHub - link에서 적용된 방법을 중심으로 설명한다.\n사용법\n사용법은 간단하다. Navigator를 주입받아 활용하며, 이동할 Activity 또는 Navigation을 Navigator에서 제공하는 navigate만 호출하면 된다.\n\n@HiltViewModel\ninternal class SearchViewModel @Inject constructor(\n    flowActionStream: FlowActionStream,\n    private val navigator: Navigator,\n) : ActionViewModel<SearchAction>(flowActionStream, SearchAction::class) {\n\n    override suspend fun handleAction(action: SearchAction) {\n        when (action) {\n            is SearchAction.ShowDetail -> { // Activity 이동 시\n                navigator.navigate(\n                    activityRoute = DetailActivityRouter::class,\n                    argumentMap = mapOf(\n                        DetailActivityRouter.PUT_DATA to DetailData(text = action.message),\n                    ),\n                )\n            }\n\n            is SearchAction.SwitchNavigation -> { // Compose Navigation 이동 시\n                navigator.navigate(\n                    navigationRoute = action.navItem.route,\n                    saveState = true,\n                )\n            }\n        }\n    }\n}\n\n\n여기서의 설계는?\n먼저 Compose Navigation에 대한 시퀀스를 살펴보자.\nView - Action - ViewModel - Router - RouterViewModel - RouterView로 이어지는 흐름을 알 수 있다.\n이를 쉽게 이해하기 위해 Repository 패턴에 비유하면, 두 개의 View에서 데이터 통신하는 방법을 설명한 그림으로 생각하면 된다. Router 부분이 Repository로 볼 수 있다.\nView - Action - ViewModel - Repository - RouterViewModel - RouterView\n이를 도식화하면\n\n이번에는 Activity를 이동한다면? 한단계가 더 추가됨을 알 수 있다.\nActivityJourney라는 개념을 활용해서 이동할 Activity가 포함되어 있는지 추가로 검증하고, Activity를 이동한다.\nView - Action - ViewModel - Router - (ActivityJourney) - RouterViewModel - RouterView\n\n이 코드를 이해하는 데 있어서 중요한 점은 두 개의 View가 어떻게 데이터를 통신하는가이다.\n가장 쉬운 방법은 싱글턴으로 처리된 Repository를 활용하는 것이거나, Activity 사이에 위치한 하나의 Repository를 활용하는 방법일 것이다. 보통은 Repository를 싱글턴으로 활용하니, 여기서도 동일하다고 이해하면 된다.\nRouter 코드\n먼저 우리가 활용할 Navigator는 인터페이스로 정의되어 있다. 구현체는 모두 숨겨져 있다.\n이때 구현체를 완전히 분리하고 싶다면, 인터페이스 모듈과 구현체 모듈을 두 개 만들어 활용하는 방식을 고려할 수 있다. 이 방식은 droidknights 2025 - Router에 포함되어 있으니 참고하길 바란다.\n\ninterface Navigator {\n\n    suspend fun <T : ActivityRoute> navigate(\n        activityRoute: KClass<T>,\n        argumentMap: Map<String, Parcelable> = emptyMap(),\n    )\n\n    suspend fun navigate(\n        navigationRoute: NavigationRoute,\n        saveState: Boolean = false,\n    )\n\n    suspend fun navigateBack()\n}\n\n\n위 코드에 대한 구현체는 다음과 같다.\nInternalNavigatorImpl은 Router 모듈 내부에서만 활용하기 위한 것으로, val channel: Channel<InternalRoute> 한 줄이 포함되어 있다.\n\n@ActivityRetainedScoped\ninternal class InternalNavigatorImpl @Inject constructor() : Navigator, InternalNavigator {\n\n    override val channel = Channel<InternalRoute>(Channel.BUFFERED)\n\n    // 아래에서 설명\n    override suspend fun <T : ActivityRoute> navigate(activityRoute: KClass<T>, argumentMap: Map<String, Parcelable>) {\n        channel.send(\n            InternalRoute.Activity(\n                activityRoute = activityRoute,\n                argumentMap = argumentMap,\n            )\n        )\n    }\n\n    override suspend fun navigate(navigationRoute: NavigationRoute, saveState: Boolean) {\n        channel.send(\n            InternalRoute.Navigation(\n                navigationRoute = navigationRoute,\n                saveState = saveState,\n            )\n        )\n    }\n\n    override suspend fun navigateBack() {\n        channel.send(InternalRoute.NavigateBack)\n    }\n}\n\n\n위 Router는 DI(Dependency Injection)를 통해 싱글턴으로 구성되어 있다.\n\n@Module\n@InstallIn(ActivityRetainedComponent::class)\ninternal abstract class RouterModel {\n\n    @Binds\n    @ActivityRetainedScoped\n    abstract fun provideNavigator(\n        navigator: InternalNavigatorImpl\n    ): Navigator\n\n    @Binds\n    @ActivityRetainedScoped\n    abstract fun provideInternalNavigator(\n        navigator: InternalNavigatorImpl\n    ): InternalNavigator\n}\n\n\nViewModel에서는 이를 활용해서, SideEffect로 View에서 collect할 수 있도록 구성되었으니, 기존 코드와 크게 다른 부분은 없다고 생각한다.\n\n@HiltViewModel\ninternal class InternalRouteViewModel @Inject internal constructor(\n    navigator: InternalNavigator,\n    private val journeyMapper: InternalActivityRouteMapper,\n) : ViewModel() {\n\n    val sideEffect by lazy(LazyThreadSafetyMode.NONE) {\n        navigator.channel.receiveAsFlow()\n            .map { router ->\n                when (router) {\n                    is InternalRoute.Activity<*> -> {\n                        journeyMapper.getJourneyOrNull(router.activityRoute)?.let {\n                            InternalRouteSideEffect.NavigateActivity(\n                                activityRoute = it,\n                                argumentMap = router.argumentMap,\n                            )\n                        }\n                    }\n\n                    is InternalRoute.Navigation -> {\n                        InternalRouteSideEffect.Navigate(\n                            navigationRoute = router.navigationRoute,\n                            saveState = router.saveState,\n                        )\n                    }\n\n                    is InternalRoute.NavigateBack -> {\n                        InternalRouteSideEffect.NavigateBack\n                    }\n                }\n            }\n            .filterNotNull()\n    }\n}\n\n\nView에서는\nView에서 SideEffect를 받아 처리하는 코드이다. 주로 화면 이동과 뒤로가기 이벤트를 처리할 수 있다.\nNavigateBack은 Activity와 Navigation 둘 다를 혼용 처리하기 위해 마지막 Entry가 있는지 한 번 더 체크하고 처리하도록 작성되었다.\n첫 화면에서는 보통 <나 X 버튼을 사용하지는 않지만, 적용은 해두었다.\n이 코드에서는 Navigation 처리에 대한 내용이므로 Activity 관련 코드는 제거되었다.\n\n@Composable\nprivate fun InternalLaunchedRouter(\n    navHostController: NavHostController? = null,\n    internalRouterViewModel: InternalRouteViewModel = viewModel(),\n) {\n    val activity = LocalActivity.current\n    val lifecycleOwner = LocalLifecycleOwner.current\n    LaunchedEffect(internalRouterViewModel, lifecycleOwner) {\n        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n            internalRouterViewModel.sideEffect.collectLatest { sideEffect ->\n                when (sideEffect) {\n                    is InternalRouteSideEffect.NavigateBack -> {\n                        if (navHostController?.previousBackStackEntry != null) {\n                            navHostController.popBackStack()\n                        } else {\n                            activity?.finish()\n                        }\n                    }\n\n                    is InternalRouteSideEffect.Navigate -> {\n                        navHostController?.let { navigation ->\n                            navigation.navigate(sideEffect.navigationRoute) {\n                                navigation.graph.findStartDestination().route?.let {\n                                    popUpTo(it) {\n                                        saveState = sideEffect.saveState\n                                    }\n                                }\n                                restoreState = sideEffect.saveState\n                            }\n                        }\n                    }\n\n                    is InternalRouteSideEffect.NavigateActivity -> {\n                        activity?.startActivity(\n                            sideEffect.activityRoute.getActivity(activity).apply {\n                                sideEffect.argumentMap.entries.forEach { (key, value) ->\n                                    putExtra(key, value)\n                                }\n                            }\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n이 코드가 처음 소개된 Flow 다이어그램에 해당한다.\n\n정의는?\nNavigationRoute를 상속받아 Route를 구현하고, 이를 Navigation 화면에 적용해야 한다.\n\n@Serializable\nobject SettingsRoute : NavigationRoute\n\n\n그리고 연결할 지점에는 NavGraphBuilder를 통해 네비게이션에서 활용할 composable을 정의하면 된다.\n\nfun NavGraphBuilder.settingsNavGraph() {\n    composable<SettingsRoute> {\n        InternalSettingsScreen()\n    }\n}\n\n\n네비게이션을 활용하는 방법은 기존과 동일하므로, 여기서는 설명은 생략하고 일부 코드를 올려둔다.\n\nScaffold(\n    bottomBar = {\n        NavigationBar {\n            navigationUiState.navigation.forEach { navItem ->\n                NavigationBarItem(\n                    selected = navigationUiState.selectNav == navItem,\n                    onClick = {\n                        onClick(navItem)\n                    },\n                    // 생략\n                )\n            }\n        }\n    },\n    modifier = modifier\n) { innerPadding ->\n    Box(\n        modifier = Modifier\n            .padding(innerPadding)\n            .padding(horizontal = 10.dp)\n    ) {\n        NavHost( // 네비게이션\n            navController = navController,\n            startDestination = NavigationUiState.Default.selectNav.route,\n        ) {\n            searchNavGraph()\n            settingsNavGraph()\n        }\n    }\n}\n\n\nActivity\nActivity 라우팅은 Compose Navigation보다 조금 더 복잡할 수 있다.\n우선 다시 Router 코드로 돌아가서 중요한 부분만 살펴보자. 여기서는 DI인 Dagger를 활용했으니 Dagger를 활용한 방법으로 접근한다.\n먼저 RouterKey라는 MapKey를 정의했다. 이를 활용해서 클래스 정보를 Key/Value로 매핑할 수 있도록 한다.\n\n@MapKey\nannotation class RouteKey(\n    val value: KClass<out ActivityRoute>,\n)\n\n\n그리고 SomeActivityRouter를 정의하고, 이를 상속받아 구현한다. 여기서 getActivity()를 구현해서 Intent 정보를 함께 전달하게 된다.\n\ninternal class MainActivityRouteImpl @Inject constructor() : MainActivityRouter {\n\n    override fun getActivity(context: Context): Intent =\n        Intent(context, MainActivity::class.java)\n}\n\n\nDI를 활용해 이 RouterImpl이 MainActivityRouter임을 알려주기 위해 @IntoMap과 @RouteKey를 활용해서 처리한다.\n\n@Module\n@InstallIn(SingletonComponent::class)\ninternal abstract class MainModule {\n\n    @Binds\n    @IntoMap\n    @RouteKey(MainActivityRouter::class)\n    abstract fun bindMainActivityRoute(\n        mainActivityRoute: MainActivityRouteImpl,\n    ): ActivityRoute\n}\n\n\n위 코드는 KSP(Kotlin Symbol Processing)를 활용하면 더 쉽게 자동화할 수 있다. 어차피 수동으로 만들더라도 같은 패턴만 나오도록 만들면 되기 때문이다. 특히 Activity를 찾는 것이 중요하며, Intent 객체를 처음부터 만드는 것도 아니기에 이러한 접근이 가능하다.\nKSP 관련 글\nAndroid KSP(Kotlin Symbol Processing) 활용을 위한 준비단계! - link\nAndroid KSP(Kotlin Symbol Processing) 활용할 수 있는 샘플 코드 작업 - link\n코드를 실행하면 런타임에 아래의 map: Map<Class<out ActivityRoute>, @JvmSuppressWildcards ActivityRoute> 부분에서 ActivityRoute로 정의한 정보를 찾아 Map 형태로 전달하고 이를 활용할 수 있다.\n아쉽게도 KClass를 바로 활용하려고 했지만, 런타임에서 오류가 발생해서 Java Class를 활용하게 되었다.\n\n@Module\n@InstallIn(SingletonComponent::class)\ninternal object JourneyRouterModule {\n\n    @Provides\n    @Singleton\n    fun providerInternalActivityRouteMapper(\n        map: Map<Class<out ActivityRoute>, @JvmSuppressWildcards ActivityRoute>,\n    ): InternalActivityRouteMapper =\n        InternalActivityRouteMapper(map)\n}\n\n\n마지막으로 접근해야 할 정보는 getJourneyOrNull에서 찾아서 startActivity할 수 있다.\n\n@Singleton\ninternal class InternalActivityRouteMapper @Inject constructor(\n    @get:VisibleForTesting val mapper: Map<Class<out ActivityRoute>, ActivityRoute>,\n) {\n\n    /**\n     * Find and return ActivityRoute from the data stored in Mapper.\n     */\n    internal fun getJourneyOrNull(journeyKClass: KClass<*>): ActivityRoute? =\n        synchronized(mapper) {\n            mapper[journeyKClass.java]\n        }\n}\n\n\nActivity라서\nCompose Navigation에서는 @Serializable object SettingsRoute : NavigationRoute와 같이 @Serializable 데이터 클래스만 정의하면 동작에 문제가 없고, 필요한 데이터도 간단하게 넘겨줄 수 있다.\n하지만 Activity는 필요한 데이터를 넘기기 위해 별도의 arguments를 사용해야 한다는 차이점이 있다.\n그래서 Navigator 인터페이스에 아래와 같이 arguments를 받을 수 있도록 추가해두었다.\n\ninterface Navigator {\n\n    suspend fun <T : ActivityRoute> navigate(\n        activityRoute: KClass<T>,\n        argumentMap: Map<String, Parcelable> = emptyMap(),\n    )\n\n    suspend fun navigate(\n        navigationRoute: NavigationRoute,\n        saveState: Boolean = false,\n    )\n}\n\n\n데이터 전달을 위함이니 Parcelable로 제한해두었다.\nNavigator를 활용하면 getJourneyOrNull 부분을 ViewModel에서 처리하고있음을 아래와 같이 확인할 수 있다.\n\n@HiltViewModel\ninternal class InternalRouteViewModel @Inject internal constructor(\n    navigator: InternalNavigator,\n    private val journeyMapper: InternalActivityRouteMapper,\n) : ViewModel() {\n\n    val sideEffect by lazy(LazyThreadSafetyMode.NONE) {\n        navigator.channel.receiveAsFlow()\n            .map { router ->\n                when (router) {\n                    is InternalRoute.Activity<*> -> {\n                        journeyMapper.getJourneyOrNull(router.activityRoute)?.let {\n                            InternalRouteSideEffect.NavigateActivity(\n                                activityRoute = it,\n                                argumentMap = router.argumentMap,\n                            )\n                        }\n                    }\n                }\n            }\n            .filterNotNull()\n    }\n}\n\n\n이 코드 부분을 도식화한 부분이 아래와 같다.\n\n정리하면\nView에서 화면 이동 이벤트가 발생한다.\nViewModel에서 Navigator를 통해 Activity/Compose Navigation으로 이벤트를 이동 요청한다.\n    \nActivity 이동: DI를 통해 주입받은 ActivityRoute 정보를 자동으로 매핑하여 InternalActivityRouteMapper에 사전 보관된 정보와 매칭하여 startActivity를 호출한다.\nNavigation 이동: Compose Navigation을 통해 Map에 포함되어있을 경우 이동한다.\n남은 작업은 다음과 같다.\nActivityResult 처리\nNavigationResult 처리\n사용법\n앞서 소개한 Action과 다르게 Router는 Activity를 기반하여 동작한다. A/B Activity가 있다고 하더라도, InternalActivityRouteMapper는 싱글턴이지만 실제 동작은 서로 무관하게 동작한다.\n그래서 각 Activity마다 아래와 같은 코드를 선택적으로 주입해 주어야 한다. 싱글 액티비티 구조라면 당연히 하나면 충분하지만, 서브 네비게이션에 대한 구조를 적용하지 않아서 현재는 모든 경우에 대응되지는 않는다.\n\nval navHostController = rememberNavController()\nLaunchedRouter(navHostController)\n\n// or\nLaunchedRouter() // navHostController default null\n\n\nNext\nAction을 새로 짜면서 Router도 몇 번의 수정이 있었다.\n기존 Action 방식에서의 문제점은 다음과 같았다.\nA/B/C 화면 어디서든 동일한 이벤트인 뒤로가기(back) 이벤트를 받는다면, 모든 화면에서 action을 처리해버리고 원치 않는 종료가 일어날 수 있다는 점이었다. 사이드 이펙트를 통해 막을 수는 있었지만 근본적인 문제 해결도 아니고, 오히려 복잡성을 높이는 코드였기에 수정되면서 원래 사용하던 방식으로 되돌아갔다는 점이다.\n더 나아가 네비게이션에서만 Router를 활용하고 싶다면 드로이드 나이츠 코드를 참고해보면 좋을 것 같다.\ndroidknights 2025 - Router\n작성 글 이어보기\n1부 - 컴포즈에 사용할 Composable Architecture 설명(리엑트?)\n2부 - Composable Architecture는 만들었는데 문제가 있었네? 개선해보자.\n3부 - Composable Architecture에서는 Alert/Toast는 어떻게 사용할 수 있는가?\n다시 - Composable Architecture 설계 변경",
    "reviews": [],
    "syllabus": [],
    "link": "https://thdev.tech/architecture/2025/06/02/Android-Architecture-new-02/",
    "pubDate": "Mon, 02 Jun 2025 00:00:00 +0000",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 4,
    "imageUrl": "",
    "title": "내가 만든 적 없는 금융상품? 자산 보호 알림 설정하세요",
    "description": "내 명의 금융상품 매일 점검하고, 앱 접속 안 해도 알림 받는 법",
    "reviews": [],
    "syllabus": [],
    "link": "https://toss.im/tossfeed/article/toss-guide-safety2",
    "pubDate": "Thu, 29 May 2025 03:23:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 5,
    "imageUrl": "",
    "title": "AI 인플루언서 부상과 인간 크리에이터의 미래",
    "description": "인플루언서 산업의 80%가 AI에 대체될 수 있다는 충격적인 전망! 최신 산업 데이터와 전문가 인터뷰를 바탕으로 AI 시대 인플루언서 생존 전략과 새로운 기회를 분석합니다. 위기를 기회로 바꾸는 방법!\n\n\n \n 요즘 SNS를 둘러보다 보면 'Aitana Lopez'나 'Lil Miquela' 같은 완벽한 외모의 인플루언서들을 자주 보게 됩니다. 자세히 들여다보면 이들이 실제 사람이 아닌 AI로 만들어진 가상 인물이라는 사실에 놀라게 되죠. 더 충격적인 건, 이 가상의 인물들이 실제 브랜드 캠페인에서 수천만 원을 벌어들이고 있다는 점입니다.\nAitana Lopez\n\n\n \n 최근 야후 파이낸스 보도에 따르면, AI 기술이 인플루언서 산업의 무려 80%를 대체할 수 있다고 합니다. 이런 전망이 현실이 될까요? 인플루언서 마케팅 업계에서는 어떤 변화가 일어나고 있으며, 이런 변화 속에서 콘텐츠 크리에이터들은 어떻게 생존해야 할까요?\n인플루언서 마케팅 전문가들의 인사이트와 최신 업계 데이터를 바탕으로 AI 시대의 인플루언서 생존 전략을 심층적으로 분석해보았습니다.\n \nAI 인플루언서란? 실제 위협의 실체 파헤치기  \nAI 인플루언서는 인공지능으로 만들어진 가상의 인물로, 실제 사람처럼 보이지만 코드와 알고리즘으로 만들어진 존재입니다. 최근 몇 년간 기술의 발전으로 이들의 외모와 행동이 놀라울 정도로 사실적이 되었고, 브랜드들은 이런 가상 인물들을 마케팅에 적극 활용하기 시작했습니다.\nAI 인플루언서가 급부상하는 이유에는 여러 요인이 있습니다. 영국의 디지털 마케팅 업체 Sortlist가 2024년 초 발표한 보고서에 따르면:\n비용 효율성: AI 인플루언서는 인간 인플루언서보다 평균 25% 저렴하게 운영 가능합니다.\n완벽한 통제: 논란 없고, 스캔들 없고, 휴가도 필요 없습니다.\n24/7 가동: 인간의 한계 없이 끊임없이 콘텐츠를 생산할 수 있습니다.\n맞춤형 외모와 성격: 브랜드 이미지에 완벽하게 맞출 수 있습니다.\n\"브랜드 입장에서 AI 인플루언서는 리스크 없는 마케팅 채널입니다. 인간 인플루언서가 논란에 휘말리거나 계약 조건을 어기는 문제가 발생하지 않죠. 또한 여러 시장에 동시에 맞춤형 콘텐츠를 제공할 수 있다는 점도 큰 장점입니다.\" - 마크 존슨, 디지털 마케팅 전략가 (2024 인플루언서 마케팅 트렌드 컨퍼런스)\n \n하지만 인간 인플루언서들에게 이는 심각한 위협이 되고 있습니다. 한 설문조사에 따르면, 인플루언서의 68%가 AI 모델의 등장으로 수입이 감소했다고 응답했습니다. 특히 중소 규모의 인플루언서들이 더 큰 타격을 받고 있는 것으로 나타났죠.\n \n충격적인 통계로 본 인플루언서 산업의 현실  \nThe Influencer Marketing Hub의 2025년 보고서는 인플루언서 산업의 급격한 변화를 보여줍니다:\n구분\n2023년\n2024년\n2025년(예상)\n\n\n\n\n인플루언서 마케팅 시장 규모\n167억 달러\n182억 달러\n196억 달러\n\n\nAI 인플루언서 점유율\n3%\n12%\n23%\n\n\n인간 인플루언서 수입 감소율\n-\n8%\n15-20%\n\n\n대체 위험이 높은 인플루언서 비율\n15%\n45%\n80%\n\n\n\n출처: The Influencer Marketing Hub, 2025 인플루언서 마케팅 트렌드 보고서, 2024\n \n흥미로운 점은 인플루언서 마케팅 시장 자체는 계속 성장하고 있지만, 그 안에서 AI의 점유율이 급격히 높아지고 있다는 것입니다.\n인플루언서 유형별로 살펴보면 위험도가 다릅니다. 마케팅 전문가 소니아 킴은 \"특히 '제품 진열형' 인플루언서들이 가장 큰 위험에 처해 있다\"고 지적합니다. \"단순히 예쁜 사진으로 제품만 보여주는 인플루언서는 AI가 쉽게 대체할 수 있기 때문이죠.\"\n \n실제로 2024년 3월, 한 유명 패션 브랜드의 마케팅 디렉터는 뉴욕 타임즈와의 인터뷰에서 이렇게 밝혔습니다: \"우리는 이제 캠페인당 AI 모델 두 명과 인간 인플루언서 한 명만 사용합니다. 2년 전에는 다섯 명의 인간 인플루언서를 고용했었죠.\"\n \nAI 시대에 살아남을 인플루언서는 누구인가?  \n모든 인플루언서가 위험에 처한 것은 아닙니다. 업계 전문가들에 따르면, 다음 유형의 인플루언서들은 오히려 AI 시대에 더 성장할 가능성이 높습니다:\n전문 지식 보유자: 의학, 법률, 특수 기술 등 깊은 전문성을 가진 인플루언서\n진정성 있는 스토리텔러: 개인적 경험과 감정을 진솔하게 공유하는 인플루언서\n커뮤니티 빌더: 팔로워와 깊은 관계를 형성하고 상호작용하는 인플루언서\n실시간 콘텐츠 제작자: 라이브 스트리밍, 즉각적인 소통이 중심인 인플루언서\n멀티 채널 전략가: 다양한 플랫폼을 활용해 통합적 브랜드를 구축한 인플루언서\n업계 관계자들은 \"AI는 아직 진정한 인간 경험이나 전문성을 완벽하게 복제할 수 없다\"고 입을 모읍니다. 실제로 Authenticity in Influence의 2024년 소비자 조사에 따르면, 응답자의 72%가 \"인플루언서의 진정성과 전문성\"을 따라가는 주요 이유로 꼽았습니다.\n \n\"AI는 아직 진정한 인간 경험을 복제할 수 없어요. 당신만의 이야기, 실패, 성공, 그리고 그 과정에서 얻은 지혜가 가장 큰 경쟁력입니다.\" - 사라 윌슨, 디지털 마케팅 전략가 (2024 인플루언서 마케팅 콘퍼런스)\n \n2024년 미국 인플루언서 마케팅 협회가 발표한 자료에 따르면, 전문 분야 인플루언서의 계약 건수는 오히려 15% 증가했지만, 일반 라이프스타일 인플루언서의 계약은 22% 감소했습니다. 이는 AI 시대에 전문성의 가치가 더욱 중요해지고 있음을 보여주는 증거입니다.\n \n인플루언서 생존을 위한 5단계 전략  \n인플루언서 마케팅 전문가들이 제시하는 AI 시대 생존 전략을 정리했습니다:\n1. 전문성 강화하기\n일반적인 라이프스타일 콘텐츠보다는 특정 분야에 깊이를 더하세요. Forbes의 2024년 보고서에 따르면, 틈새 시장에 집중한 인플루언서의 수익은 전년 대비 23% 증가했습니다. 예를 들어, 일반 뷰티 인플루언서보다 '민감성 피부를 위한 스킨케어 전문가'와 같이 세분화된 영역에서 더 높은 수익을 창출할 수 있습니다.\n2. 진정성 있는 콘텐츠 제작\n완벽함보다는 진실함에 집중하세요. 2024년 소비자 신뢰도 조사에 따르면, 팔로워의 67%가 \"완벽해 보이는 콘텐츠보다 진정성 있는 콘텐츠\"를 선호한다고 응답했습니다. 실패 경험이나 도전 과정을 솔직하게 공유하는 인플루언서에게 더 높은 신뢰도와 충성도를 보였죠.\n3. 커뮤니티 빌딩에 투자\n팔로워 수보다 소통의 질에 집중하세요. Community Pulse의 2024년 조사에 따르면, 높은 참여율을 보이는 인플루언서의 브랜드 계약 유지율이 평균 3배 높았습니다. 댓글에 꾸준히 답변하고, 라이브 세션을 통해 직접 소통하는 등 커뮤니티 형성에 투자하는 것이 중요합니다.\n4. 멀티 플랫폼 전략 구축\n한 플랫폼에만 의존하지 마세요. Omnichannel Influence 보고서(2024)에 따르면, 3개 이상의 플랫폼에서 활동하는 인플루언서의 수입이 단일 플랫폼 인플루언서보다 평균 40% 높았습니다. 인스타그램, 유튜브, 뉴스레터, 팟캐스트 등 다양한 채널을 통합적으로 운영하는 것이 리스크를 분산시키는 방법입니다.\n5. 수익 모델 다각화\n브랜드 협찬에만 의존하지 말고 다양한 수익원을 개발하세요. Creator Economy Report 2024에 따르면, 성공적인 인플루언서의 60%가 3개 이상의 수익 모델을 가지고 있습니다. 온라인 코스, 멤버십, 디지털 제품, 컨설팅 서비스 등 다양한 방식으로 수익을 창출하는 것이 안정성을 높이는 방법입니다.\n성공적인 인플루언서 제니퍼 루이스는 \"처음에는 AI 인플루언서 뉴스에 불안했지만, 이제는 내 콘텐츠의 가치와 차별점을 더 명확히 하게 되었다\"며 \"AI가 대체할 수 없는 내 고유의 전문성과 경험을 강조하는 방향으로 전략을 수정했다\"고 말합니다.\n \n\n필자가 직접 Veo3 를 이용하여 만든 가상 인플루언서\n\n \n \n브랜드와 인플루언서 관계의 새로운 모델  \nAI 시대에 브랜드와 인플루언서 사이에 새로운 협업 모델이 등장하고 있습니다:\nAI + 인간 하이브리드 모델: 브랜드가 AI 인플루언서의 효율성과 인간 인플루언서의 진정성을 결합\n가치 기반 파트너십: 단기적 노출보다 장기적인 브랜드 스토리텔링에 초점\n데이터 주도 협업: 단순 팔로워 수가 아닌 실질적 전환율과 참여도 중심 계약\n공동 창작 모델: 인플루언서가 단순 홍보자가 아닌 브랜드의 창작 파트너로 참여\n최근 럭셔리 브랜드들의 마케팅 전략을 보면 이런 변화가 뚜렷합니다. 디올의 경우, 인플루언서들을 제품 개발 과정에 직접 참여시키고, 그 스토리를 팔로워들과 공유하는 형태로 협업 모델을 변화시켰습니다. 이런 심층적인 협업은 AI가 쉽게 대체할 수 없는 영역이죠.\n \nInfluencer Partnership Survey 2024에 따르면, 브랜드 담당자의 58%가 \"단순 노출형 인플루언서 마케팅에서 벗어나 더 깊은 협업 모델을 추구하고 있다\"고 응답했습니다.\n\n\n결론: 위기가 아닌 변화의 시대  \nAI가 인플루언서 산업의 80%를 대체할 거라는 전망은 충격적이지만, 이는 결국 산업의 진화 과정으로 볼 수 있습니다. 역사적으로 TV가 라디오를 대체할 거라는 예측이 있었지만, 라디오는 여전히 존재합니다. 다만 그 역할과 형태가 바뀌었을 뿐이죠.\n \n마찬가지로 인플루언서 산업도 변화할 것입니다. 단순 제품 홍보자들은 AI에게 자리를 내줄 수 있지만, 진정한 커넥션과 전문성을 가진 인플루언서들은 오히려 더 가치 있는 존재가 될 것입니다.\n \n디지털 트랜스포메이션 전문가 데이비드 첸은 \"AI는 인플루언서 산업을 파괴하는 것이 아니라 재정의하고 있다\"며 \"이 변화를 받아들이고 적응하는 인플루언서들은 더 강력한 포지션을 차지하게 될 것\"이라고 전망합니다.\n \n여러분은 어떻게 생각하시나요? 인플루언서로 활동하고 계시다면, 어떤 전략으로 AI 시대에 대응하고 계신가요? 댓글로 여러분의 생각과 경험을 나눠주세요!\n자주 묻는 질문 ❓\nQ: AI 인플루언서는 법적으로 인플루언서로 인정받나요?\nA: 현재 대부분의 국가에서는 AI 인플루언서에 대한 명확한 법적 규정이 없습니다. 다만 미국 FTC는 2024년부터 AI 생성 콘텐츠임을 명시하도록 권고하고 있습니다.\nQ: 소규모 인플루언서도 AI에 영향을 받나요?\nA: 네, 오히려 마이크로 인플루언서(1-10만 팔로워)가 더 큰 위험에 처할 수 있습니다. 브랜드가 비용 절감을 위해 중소 규모 인플루언서를 AI로 대체하는 경향이 있습니다.\nQ: AI 인플루언서와 협업하는 방법이 있을까요?\nA: 있습니다. 일부 인플루언서들은 자신의 AI 버전을 만들어 추가 수익원으로 활용하고 있습니다. 자신의 이미지와 콘텐츠 스타일을 라이센싱하는 형태입니다.\nQ: 어떤 니치(틈새) 분야가 AI 대체 위험이 낮은가요?\nA: 전문 자격이 필요한 분야(의학, 법률, 금융 조언 등), 실시간 상호작용이 중요한 게임 스트리밍, 그리고 특수 기술 시연(요리사, 아티스트 등)이 상대적으로 안전합니다.\nQ: 콘텐츠 크리에이터로서 AI 도구를 어떻게 활용할 수 있을까요?\nA: AI를 경쟁자가 아닌 도구로 활용하세요. 편집, 번역, 아이디어 발상, 데이터 분석 등에 AI를 활용하면 생산성을 높이고 더 창의적인 콘텐츠에 집중할 수 있습니다.\n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"AI 인플루언서는 법적으로 인플루언서로 인정받나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 대부분의 국가에서는 AI 인플루언서에 대한 명확한 법적 규정이 없습니다. 다만 미국 FTC는 2024년부터 AI 생성 콘텐츠임을 명시하도록 권고하고 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"소규모 인플루언서도 AI에 영향을 받나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 오히려 마이크로 인플루언서(1-10만 팔로워)가 더 큰 위험에 처할 수 있습니다. 브랜드가 비용 절감을 위해 중소 규모 인플루언서를 AI로 대체하는 경향이 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"AI 인플루언서와 협업하는 방법이 있을까요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"있습니다. 일부 인플루언서들은 자신의 AI 버전을 만들어 추가 수익원으로 활용하고 있습니다. 자신의 이미지와 콘텐츠 스타일을 라이센싱하는 형태입니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"어떤 니치(틈새) 분야가 AI 대체 위험이 낮은가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"전문 자격이 필요한 분야(의학, 법률, 금융 조언 등), 실시간 상호작용이 중요한 게임 스트리밍, 그리고 특수 기술 시연(요리사, 아티스트 등)이 상대적으로 안전합니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"콘텐츠 크리에이터로서 AI 도구를 어떻게 활용할 수 있을까요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"AI를 경쟁자가 아닌 도구로 활용하세요. 편집, 번역, 아이디어 발상, 데이터 분석 등에 AI를 활용하면 생산성을 높이고 더 창의적인 콘텐츠에 집중할 수 있습니다.\"\n      }\n    }\n  ]\n}",
    "reviews": [],
    "syllabus": [],
    "link": "http://muzbox.tistory.com/483601",
    "pubDate": "Fri, 30 May 2025 08:17:31 +0900",
    "creator": "어떤오후의 프리웨어 이야기",
    "categories": [
      "AI, 미래기술/AI 인사이트",
      "ai 인플루언서",
      "가상 인플루언서",
      "디지털 콘텐츠 크리에이터",
      "브랜드 콜라보레이션",
      "소셜미디어 마케팅",
      "인플루언서 마케팅",
      "인플루언서 산업 미래",
      "인플루언서 생존 전략",
      "인플루언서 수익 모델",
      "콘텐츠 크리에이터 커리어"
    ]
  },
  {
    "id": 6,
    "imageUrl": "",
    "title": "Introducing Live Watches in CLion’s Debugger",
    "description": "The latest CLion 2025.2 EAP build, 252.18003.25, includes one of the most requested features for embedded development: live watches. It allows you to monitor global variables in real time without stopping the debugger or the program’s execution. This feature is particularly useful for embedded developers working with time-sensitive protocols, such as Bluetooth, or with physical […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/clion/2025/05/introducing-live-watches/",
    "pubDate": "Thu, 29 May 2025 14:30:51 +0000",
    "creator": "Oleg Zinovyev",
    "categories": [
      "eap",
      "news",
      "debugger",
      "embedded",
      "live-watches"
    ]
  },
  {
    "id": 7,
    "imageUrl": "",
    "title": "AI스트레스, 다들 없으세요?",
    "description": "저는 국내 대형 카드사에 재직 중입니다. 금융회사가 다 그렇듯 상당히 보수적이고 변화에 늦은 편이죠. 그런데 작년 말 갑자기 회사 안에 AI 본부가 생겼습니다. AI가 화두긴 화두인가 봅니다. 세상이 변하고 있으니 빨리 쫓아가야죠.  그런데 제가 불려 들어갔습니다. 그냥도 아니고 팀장입니다. (제가요? 왜요? 라고 요즘 MZ들 하는 말 저도 해 보고 싶었습니다만…) 네, 작년 말 이후로 갑자기 […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://ppss.kr/archives/268818",
    "pubDate": "Mon, 02 Jun 2025 03:06:01 +0000",
    "creator": "길진세",
    "categories": [
      "IT",
      "사회"
    ]
  },
  {
    "id": 8,
    "imageUrl": "",
    "title": "실수에서 더 나은 시작으로",
    "description": "미생이란 컨텐츠는 스토브리그와 더불어서 회사생활을 어떤 시각으로 바라봐야하는가에 대해 좋은 힌트를 많이 줬다.\n웹툰과 드라마 모두 다 봤지만, 특히나 드라마에서는 연출이 더 극적이라 그런지 감정과 생각이 잘 전달되었다.\n드라마 13화는 주인공 장그래가 속한 영업 3팀이 문제가 생긴 사업을 좋은 사업으로 전환 하는 에피소드이다.\n같은 팀 박종식 과장이 요르단 중고차 사업을 맡은 후 현지에 친인척 이름으로 페이퍼컴퍼니를 설립하고 중고차 수입을 밀어주는 형식으로 비리를 저지른다.\n비리가 발견되고 나서 회사는 박종식 과장을 해임하고, 회사의 오점인 요르단 중고차 사업을 지운다.\n하지만 영업 3팀의 입장에서는 박종식 과장이 비리를 저지르긴 했지만 요르단 사업 그 자체만 봤을때는 너무나 좋은 사업이라고 판단했다.\n이 사업을 다시 시작하고 싶은데, 이미 비리로 인해 여러 사람이 해임되고 회사에서 쉬쉬하는 상황에서 어떻게 다시 이 사업을 해야한다고 임원들을 설득할 수 있을까?\n오상식 차장은 요르단 중고차 사업을 다시 시작해야한다고 설득해야하는 프레젠테이션 자리에서 임원진들에게 그간 비리로 인해 그만두었던 사업들에 대해 이야기한다.\n\"문제가 생기자 회사는 각 사건을 신속하고 정확하게 해결했습니다.\n깔끔하게 정리한 것입니다.\n그리고 그 사건을 지워버렸습니다.\"\n...\n\"문제가 생긴 사업에 대해서 두 번 다시 입 밖에 꺼내지 않는 것은 우리가 선택하고 회사가 결정한 일입니다.\n그렇다면 우리가 지워버린 그 사업들은 어디에서 어떻게 되었는지 아십니까?\n지금부터 보실 내용은 우리가 생각하기도 싫어 지워버렸던 그 사업을 가져간 타 업체들의 실적입니다\"\n...\n\"죄를 처벌했으니, 그 일은 잊혀져야 맞는 것입니까?\n저희는 ‘죄’만 들어내기로 했습니다.\"\n출처:  [#미생] 13화 13분만에 몰아보기\n10년이 지났지만 생각이 날 정도로 이 에피소드는 내 회사 생활에 큰 영향을 줬다.\n\"실수, 실패라고 불렀던 그 지점을 새로운 시작점으로 전환\" 하게 만드는 이야기에 보는 내내 두근거렸다.\n언젠간 나도 저렇게 실패를 새로운 시작으로 전환하는 일을 해봐야지 같은 생각을 하면서 말이다.\n2024년 2월, 인프런이 글로벌하게 트위터에서 언급된 적이 있다.\n전 세계 개발자들이 구독하는 유명 유튜버 codewithAntonio님이 우리 플랫폼에 대해 언급한 것이였다.\n“I just found out that instructor on @inflearn, a company with $4M+ in funding is using my open-source code and selling them as courses.”\n— 원문 트윗 보기\n\n\n인프런에 올라온 한 강의가 Antonio님의 유료 강의와 똑같다는 것이었다.\n완전히 처음 겪는 일에 잠시 멍해졌다.\n주말임에도 급하게 해당 강의를 확인했다.\n그 와중에 CS 문의들이 쏟아지기 시작했다.\nAntonio님의 팬인 수강생분들이 하나둘씩 “내가 너무 좋아하는 Antonio 강의인데, 이 강의랑 구조가 하나도 빠짐없이 똑같다”는 제보를 보내셨다.\n쏟아지는 CS에 대해 답변드리고, Antonio님께 사과 메세지를 전달드리고, 내부적으로는 실제로 그런 일이 맞는지 검토하는 등 정신 없는 주말을 보냈다.\n강의 내용을 검토한 결과, 의심의 여지 없이 복제 강의였다.\n지식 공유자분께서 업로드한 강의였기에 혹시나 Antonio님과 사전에 논의된 적이 있었는지 확인을 요청드렸다.\n모든 내용을 확인해보니 결국 두 분의 소통 과정에 문제가 있었고, Antonio님 입장에서는 전혀 생각하지 못했던 협업이였다.\n플랫폼을 운영하는 입장에서 가만히 있을 순 없었다.\n곧바로 강의를 삭제하고 강의를 결제한 수강생분들께는 사과의 말씀과 함께 전액 환불을 했다.\n내부적으로 모든 내용이 정리가 되고나서는 대표님께서 직접 공식 사과문을 게시했다.\n이제 막 글로벌 전환을 하고 있었기에 이번 사건이 너무 크게 다가왔다.\n글로벌 개발자분들께는 \"인프런? 거기 강의 훔쳐서 만드는 곳이잖아\" 라는 인상을 드린 것은 아닐까 하는 걱정과 앞으로 어떻게 이런 문제를 사전에 잡아낼 수 있을지에 대한 고민이 함께 생겼다.\n전세계에서 만들어지는 모든 컨텐츠를 우리가 다 확인할 순 없는데 어떻게 검수할 것인가.\n수많은 트위터 댓글과 인용에 남긴 부정적 의견들을 어떻게 전환할 수 있을까 등등.\n여러가지 생각과 고민을 하던 중 믿기 힘든 문의가 올라왔다.\n“강의 철회 안내 메일을 받았습니다.\n그런데 저는 이 강의가 너무 좋았어요.\n이번 진행중인 프로젝트를 완료 하고나서 열공하려고 했거든요 ㅜㅜ\n끝까지 보고 싶습니다.”\n강의를 환불받은 수강생분들의 문의였다.\n미생 13화 요르단 사업 PT가 다시금 떠올랐다.\n이대로 Antonio님과 죄송한 관계로 끝난다면 해외의 많은 개발자들분들은 인프런을 여전히 카피캣 강의 서비스로 기억할 것이다.\n복사된 강의를 봤던 한국의 수강생분들은 저 좋은 콘텐츠를 더이상 한국어로는 보지 못한다.\n그래서 '죄'는 들어내고 콘텐츠만 봤다.\nAntonio님은 다양한 주제의 서비스 구현 강의들이 있었다.\n듀오링고, 구글 Docs, 트위치, 넷플릭스, 스포티파이, 글로벌 이커머스 등 새로운 서비스를 구현 해야 한다면 이 중에 하나쯤은 있을 것 같은 주제의 강의들을 거의다 가지고 계셨다.\n실수는 있었지만, 그것을 더 나은 시작으로 바꾸기로 했다.\n글로벌 플랫폼으로 전환하고 나서 곧바로 Antonio님께 연락을 드렸다.\n인프런을, 우리를 어떻게 생각할지 걱정도 앞섰지만, 그럼에도 이 콘텐츠를 꼭 한국의 개발자분들께 더 많이 알리고 싶었다.\nHello Antonio,\nI’m the CTO at Inflearn...\n(중략)\nThis collaboration is our way of making amends for the previous incident and ensuring your invaluable content gets the recognition it deserves...\nAntonio님은 놀라울 정도로 성숙하게, 따뜻하게 답해주셨다.\n“Hi Donguk,\nThank you for reaching out!\nI understand that managing content across a large platform can be challenging, and I truly appreciate the steps you're taking to improve your internal processes. No hard feelings on my end, and I’m glad to see the positive changes you're implementing.  ”\n그리고 Antonio님과 같이 협업을 시작하게 되었다!\nAntonio님은 항상 강의의 유료 자료 전체를 구매하는 방식으로만 판매하셨다.\n평생 구독 같은 느낌이다.\n다만, 이런 All or Nothing 의 판매가 국내에서는 이해하기 힘든 모델일 것이라고 봤다.\n딱 하나만 들으면 되는데 모든 콘텐츠를 구매하는 것은 부담스러울 수 있을 것 같다는 의견을 나눴다.\n그래서 이번에 우리와의 협업에서는 단건 구매가 가능하도록 각각의 강의를 아주 저렴하게 판매하기로 했다.\n그리고 그렇게 많은 논의 끝에 나온 첫 주제는 대표작 YouTube Clone 프로젝트 이다.\nNext.js 15 & React 19 기반 최신 스택을 기반으로 비디오 플레이어, 컨텐츠 피드, 구독, 좋아요 등을 다 만들어보는 강좌이다.\n그의 뜻에 따라 기존 가격도 낮게 설정하고, 얼리버드 할인 역시 큰 폭으로 진행하게 되었다.\n가격을 떠나 요즘 풀스택 구현을 원하시는 분들에게 필요한 대부분의 내용이 포함되어 있었다.\n  Next.js 15 & React 19 기반 최신 스택\n ️ DrizzleORM 기반 PostgreSQL\n  TailwindCSS와 ShadcnUI를 활용한 세련된 UI 구성\n  AI 기반 제목, 소개, 썸네일 자동 생성\n  조회수, 좋아요, 트래픽을 확인할 수 있는 크리에이터 스튜디오\n등 단순히 “유튜브처럼 생긴 무언가”를 만드는 수준을 넘어서 지금 우리가 매일 쓰는 유튜브의 핵심 기능들을 하나하나 직접 구현하면서 배워나가는 구조다.\n이 모든 것을 한 프로젝트 안에서 경험할 수 있는, 그야말로 현업형 풀스택 클론 코딩 강의였다.\n우리는 실수를 했다.\n하지만 그 실수를 투명하게 바로잡고,\n진짜 제작자분과 제대로 된 기회를 만들 수 있었다.\n앞으로도 우리는 계속 실수할 수 있다.\n다만, 그 실수는 실수에서 끝나지 않고, 항상 더 나은 시작으로 만들 수 있을 것 같다는 자신이 생겼다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://jojoldu.tistory.com/830",
    "pubDate": "Fri, 30 May 2025 00:06:22 +0900",
    "creator": "향로 (기억보단 기록을)",
    "categories": [
      "생각정리",
      "Antonio",
      "미생",
      "안토니오",
      "인프런",
      "클론코딩"
    ]
  },
  {
    "id": 9,
    "imageUrl": "",
    "title": "주택 임대차 계약 신고제, 임차인의 권리 보호가 더 간편해져요",
    "description": "모르고 놓친다면 이제부터 과태료를 내야해요",
    "reviews": [],
    "syllabus": [],
    "link": "https://toss.im/tossfeed/article/36981",
    "pubDate": "Thu, 29 May 2025 23:00:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 10,
    "imageUrl": "",
    "title": "Extension Manager updates in Visual Studio",
    "description": "The latest updates in Visual Studio 2022 introduced features specifically designed to improve how you manage extensions. These updates offer tools that help you automate processes, provide detailed controls for configuration, and enhance the user interface to streamline your development workflows. Seamless auto updates Visual Studio now automatically triggers updates whenever you open the Extension […]\nThe post Extension Manager updates in Visual Studio appeared first on Visual Studio Blog.",
    "reviews": [],
    "syllabus": [],
    "link": "https://devblogs.microsoft.com/visualstudio/extension-manager-updates-in-visual-studio/",
    "pubDate": "Mon, 02 Jun 2025 18:13:24 +0000",
    "creator": "Javier De la Garza",
    "categories": [
      "Extensibility",
      "Visual Studio",
      "Extensions",
      "Updates",
      "visualstudio.extensibility"
    ]
  },
  {
    "id": 11,
    "imageUrl": "",
    "title": "Improve the commands in your extensions",
    "description": "As Visual Studio extension authors, our goal is to create tools that empower developers across diverse environments. A key part of this mission involves ensuring that your extension commands remain accessible and consistent across all Visual Studio locales. In your VSSDK extensions, by adding the CanonicalName property to your commands in the .vsct file, you […]\nThe post Improve the commands in your extensions appeared first on Visual Studio Blog.",
    "reviews": [],
    "syllabus": [],
    "link": "https://devblogs.microsoft.com/visualstudio/improve-the-commands-in-your-extensions/",
    "pubDate": "Wed, 28 May 2025 15:53:58 +0000",
    "creator": "Mads Kristensen",
    "categories": [
      "Extensibility",
      "Reliability",
      "Visual Studio",
      "Extensions"
    ]
  },
  {
    "id": 12,
    "imageUrl": "",
    "title": "복잡한 회원 인증 프로세스, 기본 원칙만 알면 쉽습니다",
    "description": "팀장님: \"회원 인증 체계를 리뉴얼해 봅시다\"기획자: \"인... 인증이요?\" ('인증 시스템 레거시도 많아 보이고 복잡해 보이는데... 좀 무섭네...')'인증'이란 단어는 듣기만...",
    "reviews": [],
    "syllabus": [],
    "link": "https://techblog.lycorp.co.jp/ko/introduction-to-membership-authentication-system-renewal-case-study",
    "pubDate": "Fri, 30 May 2025 02:00:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 13,
    "imageUrl": "",
    "title": "Run Qodana Directly on Your Local or CI Machine Without Docker Containers",
    "description": "Until now, Qodana linters have run exclusively in Docker containers. While this approach provided consistency and isolation, it also required significant effort for environment configuration, particularly for complex project setups or highly secured systems. Users have had to rely on the bootstrap mechanism to set up custom environments inside the Docker container, often duplicating the […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/qodana/2025/05/run-qodana-in-your-ci/",
    "pubDate": "Tue, 27 May 2025 10:17:14 +0000",
    "creator": "Kerry Beetge",
    "categories": []
  },
  {
    "id": 14,
    "imageUrl": "",
    "title": "How Java Open-Source Projects Use IntelliJ IDEA: Real-World Examples – Part 1",
    "description": "At JetBrains, we build tools to help developers stay focused and productive, and we’re especially proud when those tools help power the open-source projects that developers around the world rely on every day. Shaping the direction of Java development, such projects contribute substantially to the vibrant Java ecosystem. This two-part series highlights some of the […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/blog/2025/05/27/how-java-open-source-projects-use-intellij-idea-real-world-examples-part-1/",
    "pubDate": "Tue, 27 May 2025 10:50:00 +0000",
    "creator": "Lena Morozova",
    "categories": [
      "community",
      "idea",
      "community-support",
      "intellij-idea",
      "open-source-program",
      "oss-projects"
    ]
  },
  {
    "id": 15,
    "imageUrl": "",
    "title": "악역영애 4컷 만화 - 4화, 선생님의 부탁인데스와",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://bbs.ruliweb.com/news/board/11/read/2312",
    "pubDate": "Wed, 28 May 2025 15:17:46 +0900",
    "creator": "｜RULIWEB｜",
    "categories": [
      "웹툰"
    ]
  }
]