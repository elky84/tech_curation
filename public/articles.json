[
  {
    "id": 1,
    "imageUrl": "",
    "title": "김종민 결혼식의 사진 논란, 인순이의 SNS 게시물 삭제 이유는?",
    "description": "김종민 결혼식의 사진 논란, 인순이의 SNS 게시물 삭제 이유는?\n김종민의 결혼식이 끝난 후에, 예상치 못한 사진 논란이 발생했습니다. 가수 인순이가 자신의 SNS에 결혼식 사진을 올리면서, 비연예인 신부의 얼굴이 그대로 노출된 것이 이번 사건의 발단이었습니다. 결혼식에서의 사진 공개는 신중하게 처리되어야 하는 부분이지만, 이번 경우에는 인순이의 의도치 않은 실수로 인해 문제가 발생했습니다.\n사건의 시작과 배경\n2025년 4월 20일, 서울 중구 신라호텔 영빈관에서는 김종민과 그의 연인이 결혼식을 올렸습니다. 이 결혼식은 많은 유명 인사들이 참석한 가운데 화려하게 진행되었습니다. 김종민은 이미 결혼을 앞둔 기자회견에서 결혼과 관련된 여러 계획을 밝히며 팬들에게 기대감을 주었습니다. 이번 결혼식은 그의 팬들과 대중들에게도 큰 관심을 받았습니다.\n인순이의 SNS 게시물\n결혼식 당일, 가수 인순이는 자신의 SNS에 결혼식 사진을 올리며 바쁜 하루를 보냈다고 전했습니다. 그녀의 게시물에는 김종민과 신부가 함께 있는 사진이 포함되어 있었는데, 문제는 신부의 얼굴이 모자이크 처리 없이 그대로 노출된 것이었습니다. 이는 즉시 온라인 커뮤니티와 SNS 상에서 논란이 되었고, 많은 누리꾼들이 비연예인 신부의 프라이버시를 지켜야 한다고 주장했습니다.\n누리꾼들의 반응\n이 사건은 특히 비연예인 신부의 사생활 보호에 대한 문제를 제기했습니다. 일부 누리꾼들은 \"김종민의 신부 얼굴 공개하지 않기로 했는데\"라며 인순이의 행동을 비판했습니다. 이와 같은 반응은 신부의 비공개 결혼식이라는 점을 강조하며, 인순이가 해당 사진을 삭제해야 한다는 의견이 많았습니다.\n인순이의 대응\n논란이 커지자, 인순이는 재빨리 자신의 SNS에서 해당 사진을 삭제했습니다. 그녀는 이와 관련하여 공식적인 입장을 밝히지는 않았지만, 신부의 사생활을 보호하기 위한 조치로 보입니다. 인순이의 즉각적인 대응은 더 이상의 논란을 막기 위한 것으로 해석됩니다.\n다른 유명 인사들의 대응\n같은 결혼식에 참석했던 가수 신지는 SNS에 올린 결혼식 사진에서 신부의 얼굴을 가렸습니다. 이는 신부의 사생활을 보호하기 위한 배려로 보이며, 그녀의 게시물에는 인순이의 게시물에 대한 언급도 있었습니다. \"인순이 누나 인스타에서 신부님 얼굴 보게 됐어요\"라는 댓글이 달리기도 했습니다.\n결혼식의 의미\n연예인들의 결혼식은 항상 대중의 관심을 받지만, 이번 사건은 그 관심이 불필요한 논란으로 이어질 수 있음을 보여줍니다. 신부와 신랑의 프라이버시는 존중받아야 하며, 그들의 사생활을 공개하지 않겠다는 약속은 지켜져야 합니다. 이번 사건은 유명 인사들의 SNS 활용에 대한 경각심을 일깨우는 계기가 되었습니다.\n결론과 교훈\n이번 사건을 통해 유명 인사들은 자신의 SNS에 올리는 게시물에 대해 더욱 신중해야 함을 배웠습니다. 비연예인의 사생활 보호는 당연히 존중받아야 하며, 그에 대한 배려가 필요합니다. 결혼식과 같은 개인적인 행사에서 촬영된 사진은 신중히 다루어져야 하며, 공개 여부에 대한 철저한 검토가 필요합니다.\n해당 사건은 대중과 유명 인사들 사이에서 사생활 보호의 중요성을 다시 한 번 상기시켰습니다. 인순이의 실수는 누구에게나 일어날 수 있는 일임을 보여주지만, 이를 통해 배우고 개선해 나가는 것이 중요합니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://app-developer.tistory.com/entry/%EA%B9%80%EC%A2%85%EB%AF%BC-%EA%B2%B0%ED%98%BC%EC%8B%9D%EC%9D%98-%EC%82%AC%EC%A7%84-%EB%85%BC%EB%9E%80-%EC%9D%B8%EC%88%9C%EC%9D%B4%EC%9D%98-SNS-%EA%B2%8C%EC%8B%9C%EB%AC%BC-%EC%82%AD%EC%A0%9C-%EC%9D%B4%EC%9C%A0%EB%8A%94",
    "pubDate": "Mon, 21 Apr 2025 16:03:55 +0900",
    "creator": "브리핑허브",
    "categories": [
      "sns 사진 논란",
      "결혼식 사진 유출",
      "김종민 결혼식",
      "비연예인 사생활",
      "신부 얼굴 공개",
      "신부 얼굴 노출",
      "연예계 사생활 보호",
      "연예인 결혼 논란",
      "인순이 sns",
      "인순이 논란"
    ]
  },
  {
    "id": 2,
    "imageUrl": "",
    "title": "Visual Studio의 새로운 디버깅 및 프로파일링 기능(v17.13)",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://jacking75.github.io/VS_20250420/",
    "pubDate": "Sun, 20 Apr 2025 00:00:00 +0900",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 3,
    "imageUrl": "",
    "title": "Brick Away / 블록분해 v1 게임 제작 시작",
    "description": "갑자기 만들고 싶어졌습니다.\n기존에 Tap Away 가 그래픽이 밝아서 제 눈이 아파서 불편사항을 고쳐보려고\n만들기 시작했습니다.\n여기까지 만드는데 4시간 정도 걸린거 같군요\n시간 잘 가네\n \n영상: https://www.youtube.com/watch?v=KgW9pFfxSJA\n\n\n\n별로 만들어진게 없습니다. \n \n플레이:  https://play.unity.com/en/games/f191f2a0-4be5-4d67-8ec9-6f98c1cc2996/brick-away-v1\n\n \nBrick Away V1 on Unity Play\ntouch brick\nplay.unity.com",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1269",
    "pubDate": "Thu, 17 Apr 2025 15:45:56 +0900",
    "creator": "SIDNFT",
    "categories": [
      "블록 분해 게임 (자작)"
    ]
  },
  {
    "id": 4,
    "imageUrl": "",
    "title": "nhn 에서 제공하는 유니티 도움 패키지",
    "description": "게임 만들라고 만든거 같군요 Game 이라고 적혀있네요\n편리하게 쓰라고 좋은기능 많이 만들어둔거 같습니다.\n셰이더도 있구요\n \n영상: https://www.youtube.com/watch?v=qstN7DcLTBk\n\n\n\n \n소스: https://github.com/nhn/gpm.unity\n\n \nGitHub - nhn/gpm.unity: A brand of NHN providing free services required for game development.\nA brand of NHN providing free services required for game development. - nhn/gpm.unity\ngithub.com\n\n \n사이즈 같은거 자동으로 ㄱ산해줘서 좋아요",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1275",
    "pubDate": "Fri, 18 Apr 2025 20:07:08 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/유니티 에셋 리뷰",
      "유니티"
    ]
  },
  {
    "id": 5,
    "imageUrl": "",
    "title": "단지 권한 기능을 추가해달라고 했을 뿐인데(feat. 인증 기능 개선)",
    "description": "안녕하세요. 스포카 백엔드팀 프로그래머 남경호입니다.\n개발자라면 누구나 오랫동안 미뤄두었던 과제가 하나쯤 있을 것입니다. 업무의 우선순위가 낮거나 긴급한 과제들에 밀려 지속적으로 백로그에 쌓여 있던 작업 말이죠. 최근 저희팀에서 왜 오랜 시간 미뤄두었던 인증 방식 개선 작업을 진행하게 되었는지, 그 과정에서 얻은 여러 경험을 여러분께 공유하고자 합니다.\n배경\n스포카 블로그를 꾸준히 보신 분이라면, 서버 언어 전환 이야기 글에서 JWT 관련 문제를 언급하며 향후 개선할 예정이라고 소개했던 내용을 기억하실 겁니다.\n\n약 3년이 흐른 지금, 드디어 저희가 인증 방식 개선을 진행하게 된 가장 큰 이유는 바로 키친보드 매장 앱에 권한관리 기능이 추가되었기 때문입니다.\n\n키친보드 매장 앱은 식자재 주문부터 거래대금 결제까지 다양한 기능을 제공합니다. 이 과정에서 사장님은 직원이 매장의 월 거래 내역 등 민감한 정보를 조회하지 못하도록 권한을 제어할 필요가 생겼는데요. 기존 JWT 인증은 무 상태(stateless) 특성상 권한 변경 시 즉각적으로 클라이언트의 인증 상태를 관리할 수 없다는 한계가 있었습니다.\n그래서 저희는 권한 기능을 추가하기에 앞서 인증 방식을 먼저 개선하기로 하였습니다.\n인증 방식 개선 방법\nRefresh Token 도입\n앞서 이야기했듯이, JWT 기반의 인증 방식은 서버가 사용자의 상태를 저장하지 않습니다. 덕분에 서버의 확장성이 높고 서버 부하를 줄일 수 있다는 장점이 있지만, 한번 발급된 토큰을 서버에서 직접 제어할 수 없다는 단점이 있습니다.\n이러한 특성은 보안 문제로 연결될 수 있는데요. 만약 인증을 통해 발급받은 토큰이 탈취된다면, 서버가 이 토큰을 제어할 수 없으므로 악의적인 사용자는 손쉽게 탈취된 토큰을 이용하여 정상 사용자처럼 서비스를 이용할 수 있게 됩니다. 보통 이러한 보안 위험을 방지하기 위해 Access Token의 만료 시간을 짧게 설정하지만, 이 경우 사용자가 자주 로그인해야 하는 번거로움이 발생하게 됩니다.\n이와 같은 문제를 해결할 수 있는 대표적인 방법의 하나가 바로 Refresh Token 의 도입입니다. Refresh Token은 Access Token과 달리 서버가 상태를 관리하는 토큰으로, Access Token을 갱신하는 데 사용됩니다. 앞서 말씀드린 대로, Access Token의 탈취 위험을 낮추기 위해 Access Token의 만료 시간을 짧게 설정하는 것이 좋은데요. 이때 Refresh Token을 활용하면 사용자가 Access Token의 만료 시점마다 다시 로그인하지 않아도 편리하게 새로운 Access Token을 발급받을 수 있습니다.\n다음 그림에서 Access Token과 Refresh Token의 인증 과정을 자세히 확인할 수 있습니다.\n\n사용자가 로그인을 요청하면 서버는 Access Token과 Refresh Token을 발급합니다.\n사용자는 발급받은 유효한 Access Token을 이용해 API를 호출하고, 서버는 요청된 데이터를 정상적으로 응답합니다.\n사용자가 만료된 Access Token을 가지고 API 요청을 하면 서버는 401 인증 에러를 반환합니다. 이때 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받고, 갱신된 Access Token으로 API를 재요청하여 정상적으로 데이터를 받을 수 있습니다.\n하지만 만약 사용자의 Refresh Token까지 만료된 상태라면, 서버는 최종적으로 401 인증 에러를 반환하여 사용자의 다시 로그인을 요구합니다.\n위 과정을 통해 일반적으로 Access Token의 만료 시간을 짧게 설정하여 Access Token의 탈취 위험을 최소화하고, Refresh Token을 통해 사용자 편의성 또한 유지할 수 있습니다.\n아래 그림을 통해 Access Token의 탈취로 인한 공격 시나리오로 Access Token의 만료시간이 짧으면 짧을수록 보안 위험도가 감소하게 됩니다.\n\n이처럼 Refresh Token을 적절히 도입하고 관리하면 토큰 탈취로 인한 보안 위험을 효과적으로 감소시킬 뿐만 아니라 사용자가 매번 로그인해야 하는 문제도 해결할 수 있으므로 사용성도 함께 챙길 수 있게 됩니다.\nRefresh Token Rotation\n한편, Access Token에 대한 탈취 위험은 Refresh Token도 동일한 것 아닌가? 라는 질문을 할 수 있을 것 같습니다. 맞습니다. Refresh Token이 탈취당하면 Access Token을 갱신할 수 있고 갱신된 Access Token을 통해 악의적 사용자는 손쉽게 탈취한 사용자인 척 서비스를 이용할 수 있게 됩니다.\n이러한 문제를 해결하기 위해 우리는 Refresh Token Rotation 을 도입하기로 합니다. Refresh Token Rotation은 아래와 같이 Refresh Token을 이용해 Access Token을 갱신할 때 Refresh Token도 함께 갱신하여 Refresh Token 탈취 시 발생할 수 있는 위험을 회피합니다.\n\n이슈\n클라이언트의 네트워크 이슈\n앞서 저희는 Refresh Token Rotation을 이용하여 Refresh Token 탈취에 대한 위험성을 회피하고자 하였습니다. 이렇게 하면 Refresh Token을 이용하여 Access Token을 갱신 요청할 때 요청한 Refresh Token도 새롭게 발급되어 더 이상 Refresh Token을 사용할 수 없게 되는데요. 보안 수준은 강화되었지만, 클라이언트 개발자분들이 한가지 우려 점을 제기해 주셨습니다.\n모바일 기기 특성상 지하실이나 엘리베이터안과같이 네트워크가 원활하지 않은 곳에서 사용할 가능성이 존재하는데요. 이때 아래 그림과 같이 첫 번째 요청한 Refresh Token을 재요청하는 경우가 발생할 수 있습니다. 하지만 Refresh Token을 매번 갱신하기 때문에 동일한 Refresh Token으로 여러번 Access Token을 갱신요청하게 된다면 두번째 요청부터는  인증 에러가 발생하게 됩니다.\n\n그래서 저희는 Token Family 방식 을 사용하여 요청 시마다 기존 Refresh Token을 지우지 않고 과거 토큰을 저장해 두었다가 첫 번째 요청으로 새롭게 발급된 토큰 또는 모종의 이유로 인해 갱신하지 못한 기존 토큰으로 토큰 갱신 요청을 할 수 있도록 구현하여 Refresh Token을 재사용할 수 있도록 하였습니다.\n\n이로써 클라이언트는 네트워크 이슈가 발생해도 Refresh Token을 갱신할 수 있게 되었습니다.\n\n인증 토큰의 하위 호환\n한편, 저희는 JWT를 다루는 라이브러리로 JJWT 를 사용하고 있습니다. 앞서 JWT는 상태를 가지지 않기 때문에 사용자가 사용하는 Access Token을 서버에서 제어할 수 없다고 말씀드렸었는데요. 그래서 Access Token의 만료 시간을 두어 새롭게 Access Token을 발급받도록 하여 우회적으로 제어할 수 있습니다. Access Token을 만료시키는 또 다른 방법은, 해당 토큰을 생성할 때 사용된 암호키를 변경하는 것입니다. 저희는 그래서 클라이언트에서 사용하는 Access Token을 만료시키고 새롭게 변경된 권한을 사용하는 Access Token으로 사용하도록 하기 위해 암호키를 바꾸기로 하였습니다. 다만 여기서 발생하는 문제가 바로 앱의 업데이트 타이밍이었습니다.\n개발자라면 다들 잘 아시겠지만, 서버와 앱은 동일한 시점에 개발이 완료되더라도 배포되는 시점이 다를 수 있습니다. 서버는 배포하는 즉시 배포가 되지만 앱은 심사 과정이 필요하고 배포가 되더라도 앱스토어에 배포된 버전이 전파되기까지 1일 이상 소요될 수 있습니다. 그러다 보니 Access Token을 변경하기 위해 키를 변경하게 되면 서버가 배포된 이후부터 앱이 업데이트되기 전까지 사용자가 서비스를 이용할 수 없다는 문제가 생길 수 있습니다. 그래서 저희는 과거 버전의 앱에서도 새롭게 배포된 서버의 인증을 문제없이 사용할 수 있도록 방법을 모색해야 했습니다.\nJJWT 버전 변경\n한편, 저희는 비밀키를 바꾸는 김에, 과거에 사용하던 서명 알고리즘(HS256)에 비해 보안성이 강화된 서명 알고리즘(PS256)을 변경하기로 합니다. 그러다 보니 JJWT라이브러리 버전을 업그레이드해야 했는데요. Gradle에 아래처럼 동일한 라이브러리를 서로 다른 버전으로 사용하는 경우 패키지 충돌이 발생하여 신규 버전에서 제공하는 함수를 사용할 수 없게 됩니다.\n\n// 구버전\nimplementation(\"io.jsonwebtoken:jjwt:0.9.1\")\n\n// 신규버전\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\n\n이러한 문제를 해결하기 위해 저희는 Jitpack 을 사용하기로 합니다. JitPack은 GitHub에 호스팅된 라이브러리를 쉽게 빌드하고 배포할 수 있게 해주는 Maven/Gradle 용 리포지터리 서비스입니다. GitHub 저장소를 바탕으로 라이브러리를 빌드하므로, 별도의 중앙 저장소(예: Maven Central) 등록 과정을 거치지 않아도 된다는 장점이 있습니다. 그리고 오픈소스 저장소에, 한에 무료로 사용할 수 있다는 점도 장점입니다.\n저희는 JJWT 라이브러리를 fork하여 Spoqa용 JJWT Github 저장소 를 생성하였습니다. 그런 다음 충돌 패키지 충돌이 발생하지 않도록 패키지명을 변경해 주었습니다.\n\n그런 다음 Release를 생성해 주면, 아래와 같이 Jitpack에서 조회할 수 있게 됩니다.\n\n마지막으로 아래와 같이 Gradle에 의존성을 추가해주면, 패키지명이 변경된 JJWT라이브러리를 사용할 수 있게 됩니다.\n\nimplementation(\"com.github.spoqa:jjwt:1.0.2\")\nimplementation(\"javax.xml.bind:jaxb-api:2.3.1\")\n\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\nComposite 패턴 vs TokenManager\n저희는 Jitpack으로 생성한 과거버전의 JJWT를 의존하는 구현체를 아래와 같이 LegacyJwtProcessor로 변경하고 신규 버전을 사용하는 JwtProcessor를 새롭게 생성하였습니다. 그런 다음 아래와 같이 인증 로직에 과거 버전의 Access Token과 신규 버전의 Access Token을 모두 수용할 수 있도록 구현하였습니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val jwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal =\n            try {\n                jwtProcessor.getPrincipal(authentication.principal.toString())\n            } catch (e: AuthenticationException) {\n                legacyJwtProcessor.getPrincipal(authentication.principal.toString())\n            }\n\n        return JwtUserAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == JwtPreAuthenticationToken::class.java\n    }\n}\n\n\n이렇게 구현하면 앱이 배포되기 전에 서버가 먼저 배포되어도 기존 버전을 사용하는 사용자가 정상적으로 로그인을 유지할 수 있게 됩니다.\n한편, 인증 로직을 구현하는 곳 말고도 LegacyJwtProcessor를 사용하는 곳이 다수 존재하였는데요. 그러다 보니 새롭게 만들어진 JwtProcessor로 전환하는 것을 누락할 가능성이 존재하였습니다. 다행히 기능 테스트가 있어 놓친 구현을 바로잡을 순 있었지만, 코드의 응집성 측면에서는 좋은 코드는 아니라 생각하였습니다.\n그래서 Composite 패턴을 사용해서 아래와 같이 구현해 볼지 생각을 하였습니다.\n\ninterface JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String\n    fun getPrincipal(token: String): UserPrincipal\n}\n\nclass CompositeJwtProcessor(\n    private val newJwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: JwtProcessor,\n): JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n}\n\nclass NewJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\nclass legacyJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\n\nCompositeJwtProcessor를 이용하면 아래와 같이 JwtAuthenticationProvider는 더 이상 legacyJwtProcessor를 알지 않아도 되고 추후 legacyJwtProcessor가 제거되어도 영향범위는 CompositeJwtProcessor로 한정되기 때문에 응집도 높은 코드를 유지할 수 있게 됩니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val compositeJwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = compositeJwtProcessor.getPrincipal(authentication.principal.toString())\n\n        return JwtUserAuthenticationToken(principal)\n    }\n    \n    // 생략...\n}\n\n\n다른 방법으로는 TokenManager라는 상위 수준의 클래스를 만들어 응집도를 높이는 방법도 생각해 보았습니다.\n\n@Service\nclass TokenManager(\n    private val jwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val refreshTokenService: RefreshTokenService,\n) {\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n\n    fun generateAccessToken(userPrincipal: UserPrincipal): String {\n        // 생략...\n    }\n\n    fun generateRefreshToken(entity: RefreshToken): String {\n        // 생략...\n    }\n\n    fun replaceRefreshToken(principal: RefreshTokenUserPrincipal): String {\n        // 생략...\n    }\n}\n\n\n이렇게 하면 Token을 Composite 패턴을 사용한 것과 같이 하위호환을 지키는 코드와 함께 토큰과 관련된 다른 기능들도 해당 클래스로 모을 수 있어 응집도를 상당히 높일 수 있게 됩니다.\n어떤 방식이 더 나은 방식이라고 말씀드리긴 어려울 것 같습니다. 다만, 저희는 LegacyJwtProcessor는 앱 배포 이후에 제거될 클래스이므로 불필요하게 Composite 패턴을 사용하기보다 TokenManager를 생성하여 코드 응집도를 높이는 방법으로 결정하게 되었습니다.\nSpring Security - PreAuthorize\n저희는 인증과 인가를 위해 Spring Security를 사용하고 있습니다. JWT를 통해 인증된 사용자는 UserPrincipal이라는 인증된 사용자로 변환되고 UserPrinciapl이 가진 authorities를 통해 권한 처리를 하고 있습니다.\n\n@Component\nclass AccessTokenAuthenticationProvider(\n    private val tokenManager: TokenManager,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = tokenManager.getPrincipal(authentication.principal.toString())\n        return AccessTokenAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == AccessTokenPreAuthenticationToken::class.java\n    }\n}\n\nclass AccessTokenAuthenticationToken(\n    private val principal: UserPrincipal,\n) : AbstractAuthenticationToken(principal.authorities) {\n    init {\n        super.setAuthenticated(true)\n    }\n\n    override fun getPrincipal() = principal\n\n    override fun getCredentials() = null\n}\n\n\n사용자는 아래와 같이 @Secured를 통해 권한을 검증받고 API를 호출할 수 있습니다.\n\n@DgsMutation\n@Secured(STORE_ADMIN, STORE_MANAGER, VENDOR)\nfun createOrderSheet(\n    @InputArgument input: CreateOrderSheetInput,\n): CreateOrderSheet {\n    // 생략...\n}\n\n\n@Secured는 단순한 권한 Role 기반 접근을 제어하기에 적절합니다. 이전까지 키친보드는 관리자, 매장 사용자, 유통사 사용자로 명확하게 Role이 나뉘어져 있었기 때문에 @Secured는 요구사항을 충분히 충족하면서 단순하게 구현할 방법이었습니다.\n하지만 새로운 요구사항이 추가되면서 매장 사용자는 매장 관리자, 매장 직원으로 권한이 분리되게 되었는데요. 이에 따라 매장 사용자 모두 접근을 할 수 있는 API에는 아래와 같이 @Secured(STORE_ADMIN, STORE_MANAGER) 표현해야 하는 불편함이 있게 됩니다. 거기다 만약 STORE_INTERN이 추가된다면 매장 사용자 권한을 가져야 하는 API를 모두 찾아서 바꿔줘야 하니 상당히 번거로운 작업이 될 것이고 자칫 권한 변경을 누락할 수 있는 위험성 또한 내포하고 있습니다.\n이와 같은 문제를 해소하기 위해 Spring Security에서는 @PreAuthorize를 이용하여 유연하게 권한을 체크하는 기능을 제공합니다. 그래서 저희는 아래와 같이 매장 사용자 여부를 확인하는 서비스 함수를 만들어 SpEL 을 이용해 권한을 체크하도록 함으로써 권한을 일일이 나열하지 않고 새로운 권한이 생기더라도 유연하게 대처할 수 있도록 하였습니다.\n\n@PostMapping(\"/replace-store\")\n@PreAuthorize(\"@authorizationExpressionHelper.isManager()\")\nfun replaceStore(@RequestBody request: ReplaceStoreRequest): ReplaceStoreResponse {\n    // 생략...\n}\n\n@Service\nclass AuthorizationExpressionHelper {\n    fun isManager(): Boolean {\n        return PrincipalProvider.userPrincipal.isManager\n    }\n}\n\n\n마무리\n지금까지 저희가 권한 기능을 추가하기 위해 인증 로직을 어떻게 개선하였고 개선하면서 겪었던 이슈들을 공유해 보았습니다. 단순히 권한을 추가해 달라는 요구사항에서 시작되었지만, 그동안 우리가 가지고 있던 기술 부채도 해결함과 동시에 기술적인 여러 고민을 할 수 있어서 개인적으로 배운 게 많은 프로젝트였습니다.\n모쪼록 인증 기능 구현에 관심이 있으시거나 예정인 분들께 도움이 되었으면 합니다.\n긴 글 읽어주셔서 감사합니다.",
    "reviews": [],
    "syllabus": [],
    "link": "https://spoqa.github.io/2025/04/18/improve-auth.html",
    "pubDate": "2025-04-18T00:00:00.000Z",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 6,
    "imageUrl": "",
    "title": "유니티 애니메이션 다운로드 및 관리 방방법 영상",
    "description": "영상 1: https://www.youtube.com/watch?v=oFBGs4_jJ0Y\n\n\n\n \n \n영상 2: https://www.youtube.com/watch?v=5WyebyiOayk\n\n\n\n이 영상에 잘 나와있네요\n리소스 다운로드 방법\n휴머노이드로 전환\n애니메이션만 따로 빼서 저장\n등등이 있습니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1272",
    "pubDate": "Fri, 18 Apr 2025 12:41:19 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/개발메모"
    ]
  },
  {
    "id": 7,
    "imageUrl": "",
    "title": "Qodana For Code Quality in STEM",
    "description": "Your code drives discovery. Keep it precise. In STEM fields, software isn’t just a product, it underpins innovation, research, and life-critical infrastructure. Qodana brings advanced static code analysis to STEM software projects, helping ensure code quality, security, and compliance where it matters most. Qodana for STEM Why code quality matters in STEM Software in science, […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/qodana/2025/04/qodana-for-code-quality-in-stem/",
    "pubDate": "Tue, 22 Apr 2025 10:37:18 +0000",
    "creator": "Kerry Beetge",
    "categories": [
      "case-study-qodana",
      "qodana",
      "code-analysis",
      "stem"
    ]
  },
  {
    "id": 8,
    "imageUrl": "",
    "title": "코드 품질 개선 기법 8편: 실상과 허상",
    "description": "안녕하세요. 커뮤니케이션 앱 LINE의 모바일 클라이언트를 개발하고 있는 Ishikawa입니다.저희 회사는 높은 개발 생산성을 유지하기 위해 코드 품질 및 개발 문화 개선에 힘쓰고...",
    "reviews": [],
    "syllabus": [],
    "link": "https://techblog.lycorp.co.jp/ko/techniques-for-improving-code-quality-8",
    "pubDate": "Fri, 18 Apr 2025 02:00:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 9,
    "imageUrl": "",
    "title": "미친 사람들과 같이 일하기",
    "description": "미친 사람들. 이게 내가 요새 우리 투자사 창업가들과 만날 때마다 내 머릿속에 떠오르는 단어다. 우리가 투자한 창업가들은 본인들의 사업이 잘되든, 잘 안되든, 내가 지금까지 만난 모든 직장인 중 일 잘하는 순위를 매겨보면 상위 1%에 들어가는 분들이다. 일을 좀 하는 분들이 아니라, 오지게 잘하는 분들이고, 남이 만들어 놓은 회사에서 직장인 생활을 하면 날아다닐 정도로 야무지게, 그리고(...)",
    "reviews": [],
    "syllabus": [],
    "link": "https://www.thestartupbible.com/2025/04/working-with-crazy-people.html",
    "pubDate": "Sun, 20 Apr 2025 21:41:00 +0000",
    "creator": "Kihong Bae",
    "categories": [
      "Uncategorized",
      "failure",
      "FoundersAtWork",
      "hustle",
      "korea",
      "people",
      "Strong"
    ]
  },
  {
    "id": 10,
    "imageUrl": "",
    "title": "더 똑똑해진 챗GPT o3와 o4-mini 공개 , 기존 모델과 차이는?",
    "description": "OpenAI의 새 모델 o3와 o4-mini가 뭐길래 이렇게 화제인걸까요? 더 오래 생각하고, 도구를 사용하며, 이미지까지 이해하는 이 모델들이 AI의 미래를 어떻게 바꿀지 함께 알아보세요!  \n\n\n \n요즘 인공지능 업계는 진짜 숨 돌릴 틈이 없는 것 같아요. 오늘은 OpenAI가 또 새로운 모델을 내놨네요. 솔직히 따라가기 벅찬 느낌이랄까요? 특히 이번에 공개된 OpenAI의 o3와 o4-mini는 정말 많은 관심을 받고 있더라고요. 근데 이게 진짜 대단한 혁신인지, 아니면 그냥 마케팅 전략인지 궁금해서 한번 자세히 들여다봤어요. 여러분도 이런 고민 한번쯤 해보셨죠?\n \no 시리즈가 뭘까? 그리고 이게 왜 중요할까?  \nOpenAI의 새로운 o3와 o4-mini는 생각하는 시간을 더 길게 가지고 응답할 수 있도록 학습된 O 시리즈의 최신 모델입니다. 이 모델들은 지금까지 OpenAI가 출시한 모델 중 가장 똑똑한 모델로, ChatGPT의 기능에 큰 변화를 가져올 것으로 예상됩니다.\n특히 주목할 점은 이 모델들이 챗GPT 내의 모든 도구를 에이전트처럼 사용하고 결합할 수 있다는 것입니다. 여기에는 웹 검색, 업로드된 파일 및 기타 데이터를 Python으로 분석하는 기능, 시각적 입력에 대한 심층 추론, 심지어 이미지 생성까지 포함됩니다. 이건 진짜 획기적인 변화 아닐까요?  \n \n이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이를 통해 다면적인 질문을 더 효과적으로 해결할 수 있게 되었고, 이는 사용자를 대신해 독립적으로 작업을 실행할 수 있는 더 에이전트형 ChatGPT를 향한 한 걸음이라고 볼 수 있습니다.\n \n최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.\n \no3와 o4-mini의 차이점은 무엇일까?  \n모델\n주요 특징\n최적 사용 케이스\n\n\n\n\nOpenAI o3\n가장 강력한 추론 모델, 코딩/수학/과학/시각적 인식에서 최고 성능, o1보다 20% 더 적은 오류율\n복잡한 다면적 분석, 이미지/차트/그래픽 분석, 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상\n\n\nOpenAI o4-mini\n빠르고 비용 효율적인 추론에 최적화, 크기와 비용 대비 뛰어난 성능, AIME 2024/2025 벤치마크 1위\n수학, 코딩, 시각적 작업, 데이터 과학, 고용량/고처리량 필요 작업\n\n\n\nOpenAI o3는 회사의 가장 강력한 추론 모델로, 코딩, 수학, 과학, 시각적 인식 등 여러 분야에서 최첨단 성능을 발휘합니다. Codeforces, SWE-bench (별도의 모델별 스캐폴드 없이), MMMU 등의 벤치마크에서 새로운 최고 성능을 기록했죠. 이 모델은 복잡한 다면적 분석이 필요하고 즉각적인 답이 명확하지 않은 복잡한 질의에 이상적입니다. 특히 이미지, 차트, 그래픽 분석과 같은 시각적 작업에서 강점을 보입니다.\n \n외부 전문가들의 평가에 따르면, o3는 어려운 실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘합니다. 초기 테스터들은 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력을 강조했습니다.\n \n반면에, OpenAI o4-mini는 빠르고 비용 효율적인 추론에 최적화된 더 작은 모델입니다. 크기와 비용 대비 놀라운 성능을 보이며, 특히 수학, 코딩, 시각적 작업에서 뛰어납니다. AIME 2024와 2025 벤치마크에서 가장 뛰어난 성능을 보이는 모델입니다. 전문가 평가에서도 데이터 과학과 같은 분야뿐만 아니라 비-STEM 작업에서도 이전 모델인 o3-mini보다 뛰어난 성능을 보였습니다.\n효율성 덕분에 o3보다 훨씬 더 높은 사용 제한을 지원하여, 추론이 필요한 질문에 대해 강력한 고용량, 고처리량 옵션이 됩니다.\n \n실제 성능은 어떨까?  \n벤치마크/작업\no1\no3-mini\no3\no4-mini\n\n\n\n\nAIME 2024 (경쟁 수학)\n74.3%\n87.3%\n91.6%\n93.4%\n\n\nCodeforces (경쟁 코딩)\n1891\n2073\n2706\n2719\n\n\nMMMU (대학 수준 시각적 문제 해결)\n77.6%\n-\n82.9%\n81.6%\n\n\n\n벤치마크 성능을 보면 정말 놀랍습니다. 외부 전문가 평가자들은 두 모델 모두 향상된 명령 준수와 이전 모델보다 더 유용하고 검증 가능한 응답을 보여준다고 평가했습니다. 이는 향상된 지능과 웹 소스의 통합 덕분입니다. 이전 추론 모델 반복과 비교할 때, 이 두 모델은 특히 기억과 과거 대화를 참조하여 응답을 더 개인화하고 관련성을 높이는 데 있어 더 자연스럽고 대화적이라고 합니다.\n \nOpenAI o3는 ChatGPT 내 전체 도구 접근권과 함께 API를 통한 사용자 지정 도구에도 접근할 수 있습니다. 이 모델들은 문제 해결 방법을 추론하고, 도구를 언제, 어떻게 사용할지 선택하여 일반적으로 1분 이내에 올바른 출력 형식으로 상세하고 사려 깊은 답변을 빠르게 생성하도록 학습되었습니다.\n \n예를 들어, 사용자가 \"캘리포니아의 여름 에너지 사용량이 작년과 비교하여 어떻게 될까요?\"라고 물을 수 있습니다. 이때 모델은 공공 유틸리티 데이터에 대한 웹 검색을 하고, 예측을 구축하기 위한 Python 코드를 작성하고, 그래프나 이미지를 생성한 다음, 예측 뒤에 있는 주요 요소를 설명할 수 있습니다. 이 과정에서 여러 도구 호출을 연결합니다.\n \n추론을 통해 모델은 접하는 정보에 따라 필요에 따라 반응하고 방향을 전환할 수 있습니다. 예를 들어, 검색 제공업체의 도움을 받아 웹을 여러 번 검색하고, 결과를 살펴보고, 더 많은 정보가 필요한 경우 새로운 검색을 시도할 수 있습니다.\n \n예를 통해 본 성능 차이  \nOpenAI는 이 모델들의 뛰어난 성능을 보여주는 몇 가지 예시를 제공했습니다. o3와 o1의 성능을 비교하면 그 차이가 확연히 드러납니다.\n \n예를 들어, 복잡한 수학 문제에서 o3는 디크슨 다항식(Dickson polynomial)을 사용해 문제를 정확히 풀어내는 반면, o1은 시간이 더 걸리고 부정확한 해결책을 제시합니다.\n \n또한 호텔 체인 확장에 관한 질문에서도 o3는 실제 데이터를 활용한 철저한 분석을 통해 아테네와 오사카를 목표 도시로 추천했습니다. 각 도시의 점유율, RevPAR 성장률, 승객 증가율 등 구체적인 지표와 2024년 통계자료를 바탕으로 상세한 비교 테이블까지 제공했죠.\n \n배터리 기술 발전에 관한 질문에서도 o3는 리튬 이온 배터리, 솔리드 스테이트 배터리, 나트륨 이온 배터리 등 최신 기술의 영향을 상세히 분석하며, 2011년부터 2024년까지의 전기차 주행거리, 충전 속도, 보급률 등의 변화를 그래프로 시각화해 보여주었습니다.\nMLB 피치 클럭 규칙이 투수 성능과 게임 시간에 미친 영향에 관한 질문에서도 o3는 구체적인 통계 데이터를 활용해 2021년부터 2024년까지의 변화를 상세히 분석했습니다. 규칙 도입 이후 게임 시간이 24분 단축됐고, 초기에는 투수들의 ERA가 상승했지만 적응 기간을 거쳐 다시 안정되었다는 흥미로운 분석을 제공했죠.\n \n이런 예시들을 보면 o3와 o4-mini의 성능이 정말 인상적이라는 걸 알 수 있어요.\n \n핵심 기술적 특징  \n기술적 혁신\n특징\n영향\n\n\n\n\n강화학습 확장\n\"더 많은 컴퓨팅 = 더 나은 성능\" 트렌드 확인\n더 오래 생각할수록 성능이 지속적으로 향상\n\n\n에이전트형 도구 사용\n도구를 언제, 어떻게 사용할지 추론하는 능력\n시각적 추론, 다단계 워크플로우 처리 능력 향상\n\n\n이미지 통합 사고\n이미지를 사고 과정에 직접 통합\n시각적, 텍스트 추론을 혼합한 새로운 문제 해결 가능\n\n\n\nOpenAI의 o3 개발 과정에서, 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 GPT 시리즈 사전 학습에서 관찰된 것과 동일한 추세를 보여주는 것으로 확인됐습니다. OpenAI는 현재 강화학습에서 이 확장 경로를 다시 따라가며, 학습 컴퓨팅과 추론 시간을 추가로 10배 증가시켰음에도 여전히 성능 향상이 명확하게 보이는 것을 확인했습니다. 이는 모델이 더 오래 생각할수록 성능이 계속 향상된다는 것을 검증합니다.\n \no3와 o4-mini는 강화학습을 통해 도구를 사용하도록 학습되었습니다. 이는 단순히 도구 사용법을 학습하는 것이 아니라, 언제 도구를 사용할지에 대해 추론하는 능력을 키웠다는 의미입니다. 원하는 결과에 따라 도구를 배치하는 능력은 특히 시각적 추론과 다단계 워크플로우를 포함하는 개방형 상황에서 더 유능하게 만듭니다.\n \n이러한 개선은 학술 벤치마크와 실제 작업 모두에서 반영되어, 초기 테스터들의 보고에서도 확인됩니다.\n또한 이 모델들은 처음으로 이미지를 직접 사고 과정에 통합할 수 있습니다. 단순히 이미지를 보는 것이 아니라, 그것을 가지고 생각합니다. 이는 시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결을 가능하게 하며, 이는 다양한 다중모달 벤치마크에서의 최첨단 성능으로 반영됩니다.\n \n실생활에서의 응용 가능성  ️\n이 새로운 모델들의 활용 가능성은 정말 광범위해요. 일상적인 작업부터 복잡한 비즈니스 문제, 교육, 연구까지 다양한 분야에서 활용될 수 있습니다. 예를 들어, 공공 유틸리티 데이터를 검색하고, 예측 모델을 구축하며, 결과를 시각화하는 복잡한 작업을 한 번에 처리할 수 있습니다.\n\n\n \n이러한 유연하고 전략적인 접근 방식을 통해 모델은 모델의 내장 지식을 넘어서는 최신 정보에 대한 접근, 확장된 추론, 합성, 여러 양식에 걸친 출력 생성이 필요한 작업을 처리할 수 있습니다.\n \n특히 비즈니스 분야에서는 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘할 것으로 기대됩니다. 또한 생각의 파트너로서의 분석적 엄격함과 특히 생물학, 수학, 공학 맥락에서 새로운 가설을 생성하고 비판적으로 평가하는 능력은 과학 연구 분야에서도 큰 도움이 될 것입니다.\n \n앞으로의 발전 방향  \nOpenAI의 o 시리즈 모델들은 인공지능의 미래를 보여주는 중요한 이정표라고 생각해요. 대규모 강화학습이 \"더 많은 컴퓨팅 = 더 나은 성능\"이라는 추세를 따른다는 사실은, 앞으로도 더 많은 컴퓨팅 파워를 투입하면 성능이 계속 향상될 수 있다는 것을 시사합니다.\n \n또한 도구 사용에 대한 강화학습의 성공은 향후 AI 모델들이 더 다양한 도구를 효과적으로 활용할 수 있게 될 것임을 암시합니다. 이는 AI가 더 자율적이고 에이전트적인 역할을 할 수 있게 되는 방향으로 발전한다는 의미겠죠.\n시각적 추론과 텍스트 추론을 혼합한 새로운 종류의 문제 해결 능력은 앞으로 더 발전해 다양한 분야에서 혁신적인 응용을 가능하게 할 것입니다.\n\n\n정리해보자면...  \nOpenAI의 o3와 o4-mini는 그저 작은 업데이트가 아니라 AI 기술의 중요한 도약이라고 생각해요. 최첨단 추론 능력과 전체 도구 액세스의 결합된 성능은 학계 벤치마크와 실제 작업 모두에서 크게 향상된 성능으로 이어져 지능과 유용성 모두에서 새로운 표준을 세웠습니다.\n \n실제 작업에서 OpenAI o1보다 20% 더 적은 중대한 오류를 보이며, 특히 프로그래밍, 비즈니스/컨설팅, 창의적 아이디어 발상 영역에서 뛰어난 성능을 발휘한다는 사실은 이 모델들이 실용적인 면에서도 큰 가치가 있음을 보여줍니다.\n이 모델들은 도구를 언제, 어떻게 사용할지 추론하도록 학습되어 복잡한 문제에 대해 상세하고 사려 깊은 답변을 제공합니다. 덕분에 일반적으로 1분 이내에 더 복잡한 질문들을 효과적으로 처리할 수 있습니다. 이러한 능력은 AI 보조자의 역할과 가능성을 크게 확장시킬 것입니다.\n \n앞으로 AI 기술이 어떻게 발전할지, 그리고 우리의 삶과 일에 어떤 변화를 가져올지 정말 기대가 되네요. 여러분은 이런 새로운 AI 모델들에 대해 어떻게 생각하시나요? 댓글로 여러분의 생각을 공유해주세요!  \n자주 묻는 질문 (FAQ)\nQ: o3와 o4-mini는 언제부터 사용할 수 있나요?\nA: 이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.\nQ: o3와 o4-mini의 가장 큰 차이점은 무엇인가요?\nA: O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.\nQ: 이 모델들은 이전 GPT 모델들과 어떻게 다른가요?\nA: 더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.\nQ: 이 모델들은 어떤 도구들을 사용할 수 있나요?\nA: 웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.\nQ: 일반 사용자들에게는 어떤 혜택이 있나요?\nA: 더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.\n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini는 언제부터 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"이미 출시되었으며 ChatGPT를 통해 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"O3와 O4-mini의 가장 큰 차이점은 무엇인가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"O3는 더 강력한 성능을, O4-mini는 비용 효율성과 빠른 속도에 최적화되어 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 이전 GPT 모델들과 어떻게 다른가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 긴 사고 시간과 도구 사용 능력, 그리고 시각적 추론 기능이 가장 큰 차이점입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"이 모델들은 어떤 도구들을 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"웹 검색, Python 코드 실행, 파일 분석, 이미지 생성 등 ChatGPT의 모든 도구를 사용할 수 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"일반 사용자들에게는 어떤 혜택이 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"더 정확하고 상세한 답변, 복잡한 질문 처리 능력, 다양한 도구를 활용한 문제 해결 등이 있습니다.\"\n    }\n  }]\n}",
    "reviews": [],
    "syllabus": [],
    "link": "http://muzbox.tistory.com/483570",
    "pubDate": "Thu, 17 Apr 2025 08:39:33 +0900",
    "creator": "어떤오후의 프리웨어 이야기",
    "categories": [
      "AI, 미래기술/AI 챗봇 및 언어 모델",
      "AI 모델",
      "o4-mini",
      "openai o3",
      "강화학습",
      "도구 사용",
      "문제 해결",
      "벤치마크 성능",
      "시각적 추론",
      "에이전트 ai",
      "추론 능력"
    ]
  },
  {
    "id": 11,
    "imageUrl": "",
    "title": "토스인컴, '5월 종소세 신고' 앞두고 '추징 안심보상제' 실시",
    "description": "‘추징 안심보상제’와 ‘종소세 미리보기’ 서비스 출시",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.toss.im/article/tossincomeservices",
    "pubDate": "Mon, 21 Apr 2025 01:00:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 12,
    "imageUrl": "",
    "title": "TeamCity Pipelines Pulse: Enhanced Notification Options",
    "description": "In this TeamCity Pipelines release, we’re focusing on improving the user experience with more flexible notification options. You can now choose which specific email notifications you want to receive from the system. You can select between default or custom notification options or unsubscribe from everything. The following options are available for custom notifications: To change […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/teamcity/2025/04/teamcity-pipelines-pulse-enhanced-notification-options/",
    "pubDate": "Thu, 17 Apr 2025 10:42:45 +0000",
    "creator": "Olga Bedrina",
    "categories": [
      "news",
      "releases",
      "release",
      "teamcity-pipelines",
      "teamcity-pipelines-pulse"
    ]
  },
  {
    "id": 13,
    "imageUrl": "",
    "title": "Taint Analysis: Exploring Hidden Dangers in Your Team’s Code",
    "description": "Join us for an engaging roundtable discussion where our panel of developers will share their firsthand insights on the latest Taint Analysis from JetBrains. Discover how critical checks can improve codebase security and be easily implemented in your code review process. Session abstract Whether you’re new to JetBrains or looking to deepen your understanding of […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/qodana/2025/04/taint-analysis-exploring-hidden-dangers-in-your-team-s-code/",
    "pubDate": "Mon, 21 Apr 2025 20:22:19 +0000",
    "creator": "Kerry Beetge",
    "categories": [
      "livestream",
      "livestreams",
      "security",
      "taint-analysis"
    ]
  },
  {
    "id": 14,
    "imageUrl": "",
    "title": "유니티 애셋 / 살이 출렁이는 연출 /",
    "description": "영상: https://www.youtube.com/watch?v=VDyPjhugZSM\n\n\n\n \n \n홍보영상: https://www.youtube.com/watch?v=_mSPXq_2saU\n\n\n\n \n보잉 같은건가 싶기도 하고 ...\n아무튼 출렁임",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1273",
    "pubDate": "Fri, 18 Apr 2025 15:03:36 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/유니티 에셋 리뷰"
    ]
  },
  {
    "id": 15,
    "imageUrl": "",
    "title": "유니티 베지어 커브 구현 사이트 찾았음",
    "description": "이걸로 그림 그리면 따라 다니는 그런 게임을 만들 수 있을 것 같습니다.\n \n소스코드 링크: https://leekangw.github.io/posts/49/\n\n \n[Unity] 베지어 곡선(Bezier Curves) 구현해보기\n게임을 개발하다보면 곡선을 그려야 할 때가 자주 있다.\nleekangw.github.io\n\n \n데모 영상: https://youtu.be/RzzFah7zOjU",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1276",
    "pubDate": "Sun, 20 Apr 2025 01:08:22 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/개발메모"
    ]
  }
]