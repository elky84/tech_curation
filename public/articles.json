[
  {
    "id": 1,
    "imageUrl": "",
    "title": "Integration Tests for Plugin Developers: UI Testing",
    "description": "In our previous blog post, we created a basic integration test that:  Now, let’s explore how to interact with UI elements in our tests. UI hierarchy IntelliJ-based IDEs primarily use Swing and AWT for their user interface, while JCEF is used in specific cases like Markdown rendering. This UI framework organizes elements in a parent-child […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-ui-testing/",
    "pubDate": "Fri, 28 Feb 2025 18:30:11 +0000",
    "creator": "Maxim Kolmakov",
    "categories": [
      "plugin-development",
      "marketplace",
      "plugins",
      "testing"
    ]
  },
  {
    "id": 2,
    "imageUrl": "",
    "title": "3월의 콘텐츠와 캘린더 by 머니그라피 ",
    "description": "2025년 3월 문화 이벤트 달력 다운로드 받기",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.toss.im/article/moneygraphy-calendar-03",
    "pubDate": "Wed, 26 Feb 2025 04:51:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 3,
    "imageUrl": "",
    "title": "CI/CD and Serverless Computing: Best Practices for Microservices",
    "description": "This article was brought to you by Mdu Sibisi, freelance writer, draft.dev. Cloud technology has reshaped how developers manage and deliver software. For example, “serverless computing” allows a provider to dynamically manage the allocation and provisioning of servers for you, which makes it ideal for running microservices. When paired with CI/CD practices, serverless computing can […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/teamcity/2025/02/ci-cd-and-serverless-computing-best-practices-for-microservices/",
    "pubDate": "Thu, 27 Feb 2025 13:41:42 +0000",
    "creator": "Olga Bedrina",
    "categories": [
      "how-tos",
      "teamcity-2",
      "best-practices",
      "guide",
      "how-to"
    ]
  },
  {
    "id": 4,
    "imageUrl": "",
    "title": "라면엔 방부제가 없다 / 마케팅에 또 속는다",
    "description": "영상: https://www.youtube.com/watch?v=TIyGbS0TVD4\n\n\n\n7분 30초에 나옵니다.\n어차피 튀겨버리면 수분이 없어져서 미생물이 살 수 없다고 합니다.\n방부제 쓸 비용을 절약한거죠\n안튀겨 나온것도 역시 수분을 빼면 괸찮습니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1156",
    "pubDate": "Thu, 27 Feb 2025 19:05:36 +0900",
    "creator": "SIDNFT",
    "categories": []
  },
  {
    "id": 5,
    "imageUrl": "",
    "title": "JetBrains Academy – February Digest",
    "description": "Here’s a roundup of all the good stuff from February  – AI skills to develop, scholarship opportunities, the latest programming and AI trends, and, as a little extra treat, a discount on a Hyperskill Premium subscription!",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/education/2025/02/28/jetbrains-academy-december-february/",
    "pubDate": "Fri, 28 Feb 2025 20:10:59 +0000",
    "creator": "Maria Sharobaeva",
    "categories": [
      "digest",
      "jetbrains-academy",
      "newsletter"
    ]
  },
  {
    "id": 6,
    "imageUrl": "",
    "title": "Leverage vision in Copilot Chat",
    "description": "Now, in the preview channel, you can attach images in GitHub Copilot chat to help you illustrate your ideas effectively and get the best responses.  Imagine working on a UI development task where describing a design or layout through text just doesn’t cut it. Or perhaps you’re debugging an issue and need to share a […]\nThe post Leverage vision in Copilot Chat appeared first on Visual Studio Blog.",
    "reviews": [],
    "syllabus": [],
    "link": "https://devblogs.microsoft.com/visualstudio/attach-images-in-github-copilot-chat/",
    "pubDate": "Mon, 24 Feb 2025 17:33:16 +0000",
    "creator": "Jessie Houghton",
    "categories": [
      "Copilot",
      "GitHub Copilot",
      "Visual Studio",
      "CopilotFree",
      "GitHub Copilot Chat"
    ]
  },
  {
    "id": 7,
    "imageUrl": "",
    "title": "Cursor 0.46, 뭔가 달라졌다! Agent의 변화를 체크해보세요.",
    "description": "Cursor 0.46 업데이트에서 중요한 변화들이 있었네요! 주요 포인트를 정리해보면 다음과 같습니다.\n🔥 Cursor 0.46 업데이트 핵심 요약\n💡 Agent 기본 모드로 통합\nChat, Composer, Agent가 하나의 인터페이스로 정리됨.\n기존 모드 이름 변경\n          \nChat → Ask\nComposer (일반) → Edit\nComposer (Agent 모드) → Agent\n단축어: ⌘ + . (모드 전환 가능)\nAsk ↔ Agent 같은 컨텍스트에서 자유롭게 전환 가능!\n🌐 웹 검색 기본 제공\n이제 프롬프트에 @web을 포함하지 않아도 웹 검색이 자동 적용됨.\n만약 웹 검색이 되지 않는다고 느껴진다면, \"웹에서 공식 문서를 검색한 다음 구현을 진행\" 같은 문장을 포함하면 해결 가능.\n🖥️ 터미널 참조 기능 추가 (@terminals)\n@terminals를 사용하여 터미널 내용을 바로 참조 가능\n기존에 Agent에 터미널 내용을 전달하는 과정이 불편했는데, 이제 더 직관적인 디버깅 환경 제공\n✨ 이 업데이트의 의미는?\n더 자연스럽고 편리한 워크플로우 → 하나의 인터페이스에서 모든 기능을 수행 가능\n웹 검색이 더 직관적 → @web을 따로 입력할 필요 없이 자동 제공\n터미널 디버깅이 개선 → @terminals로 바로 참조 가능\n더 자세한 정보는?\nCursor 공식 변경 로그\n  \n이제 코딩할 때 더 빠르고 매끄럽게 작업할 수 있겠네요! 🚀🔥",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.gaerae.com/2025/03/cursor-046-agent.html",
    "pubDate": "Sun, 02 Mar 2025 14:57:00 +0000",
    "creator": "noreply@blogger.com (Unknown)",
    "categories": [
      {
        "_": "ai",
        "$": {
          "domain": "http://www.blogger.com/atom/ns#"
        }
      }
    ]
  },
  {
    "id": 8,
    "imageUrl": "",
    "title": "미니PC 강자 미니스포럼(MINISFORUM), 한국어 공식 홈페이지 오픈",
    "description": "미니PC 업계에서 유명한 미니스포럼(MINISFORUM)의 한국어 공식 홈페이지(https://www.minisforum.kr/)가 열렸습니다.\n \n미니스포럼은 Kommend Technology Co., Limited의 브랜드로, 중국 심천(Shenzen)에서 2012년부터 시작하여 만들어진 컴퓨터 제조사입니다. 다만 글로벌 페이지에서는 2018년부터 미니스포럼 브랜드가 만들어졌다고 하니 좀 혼란스럽네요.\n아무튼 다양한 미니PC 관련 제품을 내놓으면서 조금씩 유명해진 회사입니다.\n \n국내에서는 AMD 라이젠 프로세서를 채용한 UM 시리즈로 유명합니다만, 공식 판매 채널이 없어서 직구로만 구입 가능했고 AS는 사실상 불가능했죠.\n \n\n\n \n이번에 오픈한 미니스포럼 한국어 페이지에서는 현재 몇몇 미니PC를 판매 중입니다. 다만 가격 면에서 직구보다는 아직 많이 비싸군요. 제품 보증이 중요한 분들이 선택하실 것 같습니다.\n \n참고로 미니스포럼 한국어 페이지에서 구입하는 경우 12개월의 제한적인 보증을 제공합니다. 그리고 제품을 받고 30일 안에 초기 불량에 대해서는 교환 또는 환불을 지원합니다.\n물론 우리나라에는 대리점이 없으므로 본사와 직접 제품을 주고 받아야 하니 시간은 좀 들어갈 것 같습니다.\n \n더 자세한 내용은 이곳을 확인하시기 바랍니다.\n \n당연한 이야기지만 여전히 리셀러를 통한 직구 방식의 구입에 대해서는 어떤 보증도 해주지 않습니다.\n \n(출처 : 미니스포럼)\n \n실제로 아직 구입하여 후기를 남긴 고객이 없는지라 직구에 비해 얼마나 이득을 줄지는 모르겠지만 일단 환영합니다.\n \n \n \n관련 글\n\n \n미니스포럼 고성능 미니워크스테이션 MS-A1, 라이젠 8700G AM5 플랫폼의 미니PC 출시\n미니PC로 유명한 미니스포럼(Minisforum)에서 AMD 라이젠7 8700G를 지원하는 MS-A1을 출시합니다.  Minisforum MS-A1의 주요 특징 이 제품은 미니스포럼에서 내놓은 인텔 플랫폼 기반의 MS-01과 비슷한 하우\nlazion.com\n\n\n \n미니스포럼, 최초의 터치스크린 코어 울트라 9 고성능 미니PC AtomMan X7 Ti 발표\n소형 PC 제조사 미니스포럼(MINISFORUM)에서 최초로 터치스크린과 인텔 코어 울트라 9 프로세서를 갖고 나온 미니PC AtomMan X7 Ti를 발표했습니다.  미니스포럼의 하이엔드 브랜드인 아톰맨(AtomMan)으\nlazion.com\n\n\n \n인텔 N100 스틱PC, MINISFORUM S100(미니스포럼 S100) 출시\n초소형 PC를 만드는 미니스포럼(MINISFORUM)에서 S100이라는 이름으로 인텔 N100 프로세서가 들어간 스틱PC를 출시합니다.  마치 좀 큰 USB 메모리스틱을 연상시키는 모양의 스틱PC는 주로 모니터 뒤에\nlazion.com",
    "reviews": [],
    "syllabus": [],
    "link": "http://lazion.com/2513739",
    "pubDate": "Fri, 28 Feb 2025 15:23:51 +0900",
    "creator": "늑돌이",
    "categories": [
      "#작은PC/#미니PC",
      "miniPC",
      "Minisforum",
      "News",
      "PC"
    ]
  },
  {
    "id": 9,
    "imageUrl": "",
    "title": "[MULTI] 야쿠자가 바다로 간 까닭은, 용과 같이 8 외전 파이리츠 인 하와이",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://bbs.ruliweb.com/news/board/11/read/2289",
    "pubDate": "Fri, 28 Feb 2025 19:22:58 +0900",
    "creator": "(RULIWEB`Д')/",
    "categories": [
      "리뷰"
    ]
  },
  {
    "id": 10,
    "imageUrl": "",
    "title": "TeamCity Pipelines: SSH Authentication Option, Custom Git URL Support, and more",
    "description": "We’ve been busy improving TeamCity Pipelines to make your CI/CD workflows even smoother. Here’s a quick update on what’s new! SSH authentication option Exciting news – we’re expanding the list of authentication options in TeamCity Pipelines! Now, you can easily authenticate using SSH. Once you set up SSH keys, you can push and pull without […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/teamcity/2025/02/teamcity-pipelines-ssh-authentication/",
    "pubDate": "Tue, 25 Feb 2025 11:05:04 +0000",
    "creator": "Olga Bedrina",
    "categories": [
      "releases",
      "news",
      "release",
      "teamcity-pipelines",
      "teamcity-pipelines-pulse"
    ]
  },
  {
    "id": 11,
    "imageUrl": "",
    "title": "비디오프록 컨버터 videoproc / AI 이미지 동영상 화질 향상 / 프레임 향상 / 소음제거 프로그렘 / 유료 / 4만원",
    "description": "영상: https://www.youtube.com/watch?v=X-Zjm18F3gY\n\n\n\n \n비디오프록 : https://www.videoproc.com/kr/video-converting-software/?ttref=y1bd-nr2502-isumo\n\n \n비디오프록 컨버터(VideoProc Converter) – 원스톱 AI 미디어 개선 & 변환 프로그램\n비디오프록 컨버터(VideoProc Converter)는 4K/HD 동영상, 오디오, DVD를 전환하고, 완전 GPU 가속화를 통해 동영상을 압축, 편집, 수정, 녹화, 다운로드할 수 있는 올인원 툴입니다.\nwww.videoproc.com\n\n \n중국꺼 같은데 해킹이 묻어있을 수 있으니 주의 해야합니다.\n기능 자체는 좋아서 보안에 취약해도 되는 PC 에서 구동하면 될꺼 같군요.\n은행\n주식\n암호화폐 \n관련된 작업을 하닌 PC 에선 하지말라는 이야기\n나중에 저렴해질 수도 있으니 자주 확인해봐야겠습니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1157",
    "pubDate": "Thu, 27 Feb 2025 20:37:49 +0900",
    "creator": "SIDNFT",
    "categories": []
  },
  {
    "id": 12,
    "imageUrl": "",
    "title": "IntelliJ IDEA 2025.1 EAP 7: Maven 4 Support And Improved Support For Multi-Release JARs",
    "description": "IntelliJ IDEA 2025.1 EAP 7 is here!  You can download this version from our website, update directly from within the IDE, use the free Toolbox App, or install it via snap packages for Ubuntu. Download IntelliJ IDEA 2025.1 EAP 7 The IntelliJ IDEA 2025.1 Early Access Program is nearing its end, but there’s still time […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/idea/2025/02/intellij-idea-2025-1-eap-7/",
    "pubDate": "Thu, 27 Feb 2025 21:14:39 +0000",
    "creator": "Maria Kosukhina",
    "categories": [
      "eap",
      "2025-1-eap",
      "intellij-idea-2025-1",
      "intellij-idea-2025-1-eap"
    ]
  },
  {
    "id": 13,
    "imageUrl": "",
    "title": "일론머스크의 DOGE 기관이 하는 일을 알아보자",
    "description": "영상: https://www.youtube.com/watch?v=dtMqHIK1ol0\n\n\n\n \n평화의시대에 너무 나태해졌습니다.\n이젠 중국과의 경쟁을 해야하는 판이라 더이상 미룰 수 없고\n혁신이 필요할때 같습니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1162",
    "pubDate": "Sat, 1 Mar 2025 17:08:44 +0900",
    "creator": "SIDNFT",
    "categories": [
      "유튜브"
    ]
  },
  {
    "id": 14,
    "imageUrl": "",
    "title": "BigQuery PIPE 사용법 : SQL의 새로운 형태",
    "description": "2024년 연말에 새로 생긴 BigQuery Pipe 사용법에 대해 작성한 글입니다\n    \n이 글은 2025년 3월 초 기준으로 작성되었습니다\n파이프 문법 Cheatsheet가 궁금하면 BigQuery 가이드북을 방문해주세요\n키워드 : BigQuery Pipe, BigQuery PIPE syntax\n\nBigQuery Pipe Syntax\n이 부분은 구글의 논문인 SQL Has Problems. We Can Fix Them: Pipe Syntax In SQL을 참고했음\n기존 SQL의 문제점\nSQL은 데이터 작업을 위한 표준 언어가 되었고, 대부분의 SQL 엔진 대부분 비슷한 문법을 사용함\n    \n하지만 SQL은 배우기 어렵고, 사용하기 어렵고, 확장하기 어려움\n이런 문제를 해결하기 위해 새로운 언어를 개발해서 제안한 사람들이 있으나, 새로운 언어를 채택하는 과정은 반발심도 있어서 쉽지 않음\nSQL은 다음과 같은 문제점이 존재함\n    \n고정된 구문 순서\n중복된 구문(예 : 필터링)\n서브 쿼리 사용\n내부 -> 외부의 데이터 흐름\n동일한 컬럼들의 반복\n고정된 구문 순서\nSELECT - FROM - WHERE - GROUP BY 순서가 고정되어 있어서 유연성이 떨어짐\n    \n문법과 의미 관점에서 순서가 다름\n데이터는 FROM에서 나오기 때문에, FROM 절부터 생각해야 함\n    \n그러나 쿼리의 시작이 SELECT라 헷갈리게 됨\n처음 SQL을 학습할 때 많은 분들이 이 부분에 대해 어려워 함\n중복된 구문(예 : 필터링)\n데이터를 필터링할 때, WHERE, HAVING, QUALIFY를 사용할 수 있음\n    \n이 3개가 사용되는 경우는 모두 다르지만, 결국에 데이터를 필터링할 때 사용됨. 그래서 처음 SQL을 공부하는 사람이 헷갈리게 됨. 언제 WHERE? 언제 HAVING?\n아래 쿼리를 보면 WHERE, HAVING, QUALIFY에 대해 작성되어 있음. 궁극적으로 이걸 하나로 통일할 수는 없을까?\n\nSELECT\n  customer_name,\n  order_date,\n  SUM(amount) AS total,\n  RANK() OVER (PARTITION BY customer_name ORDER BY SUM(amount) DESC) AS rk\nFROM customers \nJOIN orders ON customers.id = orders.customer_id\nWHERE region = 'East'           -- 집계 전 필터링\nGROUP BY customer_name, order_date\nHAVING SUM(amount) > 1000       -- 집계 후 필터링\nQUALIFY rk = 1  \n\n\n서브 쿼리 사용\n다중 집계, 계산된 표현의 재사용 등을 위해 서브 쿼리를 사용해야 함\n    \n서브 쿼리는 들여쓰기가 많아져서 가독성을 해치고, 편집할 때 실수를 유발할 가능성이 생김\n간단한 연산이지만 서브 쿼리가 필요한 경우\n    \n두 번 이상 합산하기\n지원되는 세 곳(WHERE, HAVING, QUALIFY) 이외의 위치에 필터링을 해야할 때, 서브 쿼리로 한번 감싸서 처리해야 함\nBigQuery ML을 사용해서 임베딩 모델을 예측하고, 그 후에 예측할 때 서브 쿼리를 사용해야 함(2번 연속으로 서브 쿼리 사용)\n\nSELECT *\nFROM ML.PREDICT(\n  MODEL `my_project.imdb_classifier`,\n  (\n    SELECT *\n    FROM ML.PREDICT(\n      MODEL `my_project.nnlm_embedding_model`,\n      (SELECT '<text>' AS input, 7 AS rating)\n    )\n  )\n)\n\n\n내부 -> 외부의 데이터 흐름\n서브 쿼리, JOIN 등이 혼합된 쿼리를 볼 때 제일 안쪽에 있는 FROM을 확인하고, 바깥쪽으로 쿼리문을 읽어야 함\n    \n이 과정이 직관적이지 않고, 쿼리를 보는 시간을 늘림\n아래 쿼리를 보면 FROM customer 부터 이해를 하고, 그 안에 있는 부분 => 바깥을 이해해야 함\n\nSELECT\n  c_count,\n  COUNT(*) AS custdist\nFROM (\n  SELECT\n    c_custkey,\n    COUNT(o_orderkey) c_count\n  FROM customer\n  LEFT OUTER JOIN orders ON c_custkey = o_custkey\n  AND o_comment NOT LIKE '%unusual%packages%'\n  GROUP BY c_custkey\n) AS c_orders\nGROUP BY\n  c_count\nORDER BY\n  custdist DESC,\n  c_count DESC;\n\n\n동일한 컬럼들의 반복\nSELECT, GROUP BY, ORDER BY 등에 중복된 컬럼을 사용하는 경우가 있음\n하나의 컬럼을 변경할 때, 다른 곳을 모두 변경해야 함(물론 GROUP BY는 GROUP BY ALL로 대체할 수 있긴 함)\n아래 쿼리에서 SELECT에 있는 컬럼을 바꾸면 GROUP BY, ORDER BY도 수정해야 할 수 있음\n\nSELECT\n  department,\n  employee_name,\n  salary, \n  RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank\nFROM employees\nGROUP BY\n  department,\n  employee_name,\n  salary\nORDER BY\n  department,\n  rank\n\n\n\nGoogleSQL의 시도 : PIPE 구문 추가\nGoogleSQL에선 새로운 언어를 만드는 방법이 아닌 기존 SQL 기능을 확장해서 문제를 해결하려고 함\n    \nSQL에 data flow syntax를 추가했고 확장하기 쉽고 유연하게 되었음\ndata flow syntax는 쉘 커맨드의 파이프 구문, 스파크의 체이닝과 유사하다고 보면 됨\nSQL에서 표준 절은 정의된 하나의 순서로 발생함. 파이프 구문을 사용하면 임의의 순서로 연산을 만들 수 있음\n\nFROM Produce\n|> WHERE item != 'bananas' AND category IN ('fruit', 'nut')\n|> AGGREGATE COUNT(*) AS num_items, SUM(sales) AS total_sales\n   GROUP BY item\n|> ORDER BY item DESC\n\n\nBigQuery PIPE 문법의 특징\nLinear Flow : 순차적 실행\nReduced Nesting : 서브쿼리를 사용하지 않음\n재생산성이 가능하고 직관적임\nFROM 부터 시작함\n파이프 연산자로 |>을 사용함\n파이프 연산자는 유효한 쿼리 뒤에 계속 추가할 수 있음\n아래 이미지를 보면 파이프 문법에선 의미론적인 순서와 동일해짐\n\n\n파이프 문자(|>)를 사용하는 이유\n친숙함과 선례 관점\n    \n(1) 유닉스 파이프는 널리 이해되는 패러다임으로, 이 구문과 동작을 친숙하고 이해하기 쉽게 만듦\n(2) 다른 데이터 처리 언어(예: KQL)도 파이프 구문을 사용함\n(3) 파이프와 같은 데이터 흐름은 Pandas DataFrames와 Apache Beam 등의 데이터 처리 프레임워크에서도 사용됨\n기술적 관점\n    \n(1) 파이프 연산자를 사용하면 어디서 구문이 시작되는지 명확히 알 수 있음\n(2) 파싱하는 방법이 간단해져서 확장성이 증가됨\n(3) 파이프 연산자는 이전 단계의 결과에 존재하는 컬럼만 접근할 수 있음. 명확해지고 예측이 가능해짐\n(4) 파이프 연산자를 사용해서 순차적으로 연산을 진행할 수 있음\n가독성 관점\n    \n(1) 언제 파이프 연산자로 전환되는지 인식하기 수월함\n(2) 여러 절로 구성된 파이프 연산자를 하나의 논리적인 단위로 인식할 수 있게 해줌\n\n  |> AGGREGATE SUM(sales) AS total_sales, AVG(price) AS avg_price\n     GROUP BY region, product\n\n        \n(3) 구조적 가시성 : 쿼리를 순차적인 N개의 연산으로 표현 가능. 쿼리의 논리적 흐름을 시각적으로 더 잘 반영함\n파이프 문자로 |을 사용할 수 있지만, 비트 연산에 사용되기 때문에 헷갈리고 충돌이 생기게 됨. 그래서 |>을 선택함\n\n\n\n\n\nBigQuery PIPE 문법\n공식 문서에서 확인할 수 있고, 앞으로 계속 늘어날 것으로 예상\n일반적으로 사용하는 FROM, SELECT, JOIN, WHERE, LIMIT, ORDER BY은 동일하다고 생각하면 됨\n아래에선 PIPE 문법 중 특별한 부분만 기록\n\n\nSET\nSELECT * REPLACE(expression AS col)와 동일한 표현\n컬럼을 다른 값으로 대체함\n\n(\n  SELECT 1 AS x, 11 AS y\n  UNION ALL\n  SELECT 2 AS x, 22 AS y\n)\n|> SET x = x * x, y = 3;\n\n/*\n+---+---+\n| x | y |\n+---+---+\n| 1 | 3 |\n| 4 | 3 |\n+---+---+\n*/\n\n\n\nEXTEND\nSELECT *, new_col과 동일한 표현\n기존 테이블의 모든 컬럼에 새로운 컬럼 추가\n    \n파이프 문법에선 이전 결과에 나오는 컬럼만 선택할 수 있어서 EXTEND를 사용해야 할 수 있음\n\n(\n  SELECT 'apples' AS item, 2 AS sales\n  UNION ALL\n  SELECT 'carrots' AS item, 8 AS sales\n)\n|> EXTEND item IN ('carrots', 'oranges') AS is_orange;\n\n/*\n+---------+-------+------------+\n| item    | sales | is_orange |\n+---------+-------+------------+\n| apples  | 2    | FALSE     |\n| carrots | 8    | TRUE      |\n+---------+-------+------------+\n*/\n\n\n\nAGGREGATE\n전체 테이블 또는 컬럼의 값에 대한 집계 수행\n전체 테이블 집계\n\n  -- Full-table aggregation\n  (\n    SELECT 'apples' AS item, 2 AS sales\n    UNION ALL\n    SELECT 'bananas' AS item, 5 AS sales\n    UNION ALL\n    SELECT 'apples' AS item, 7 AS sales\n  )\n  |> AGGREGATE COUNT(*) AS num_items, SUM(sales) AS total_sales;\n    \n  /*\n  +-----------+-------------+\n  | num_items | total_sales |\n  +-----------+-------------+\n  | 3        | 14        |\n  +-----------+-------------+\n  */\n\n    \nGROUP BY와 함께 사용해서 집계\n\n  -- Aggregation with grouping\n  (\n    SELECT 'apples' AS item, 2 AS sales\n    UNION ALL\n    SELECT 'bananas' AS item, 5 AS sales\n    UNION ALL\n    SELECT 'apples' AS item, 7 AS sales\n  )\n  |> AGGREGATE COUNT(*) AS num_items, SUM(sales) AS total_sales\n     GROUP BY item;\n    \n  /*\n  +---------+-----------+-------------+\n  | item   | num_items | total_sales |\n  +---------+-----------+-------------+\n  | apples  | 2       | 9         |\n  | bananas | 1       | 5         |\n  +---------+-----------+-------------+\n  */\n\n    \nGROUP AND ORDER BY를 사용하면 컬럼을 반복적으로 입력하지 않아도 괜찮음\n\n  -- Aggregation with grouping and order by\n  (\n    SELECT 'apples' AS item, 2 AS sales\n    UNION ALL\n    SELECT 'bananas' AS item, 5 AS sales\n    UNION ALL\n    SELECT 'apples' AS item, 7 AS sales\n  )\n  |> AGGREGATE COUNT(*) AS num_items, SUM(sales) AS total_sales\n     GROUP AND ORDER BY item;\n\n    \n\nPIVOT\nStandardSQL의 PIVOT 함수를 사용할 수도 있음\n열(Row)을 컬럼(Column)으로 회전\n\n(\n  SELECT \"kale\" AS product, 51 AS sales, \"Q1\" AS quarter\n  UNION ALL\n  SELECT \"kale\" AS product, 4 AS sales, \"Q1\" AS quarter\n  UNION ALL\n  SELECT \"kale\" AS product, 45 AS sales, \"Q2\" AS quarter\n  UNION ALL\n  SELECT \"apple\" AS product, 8 AS sales, \"Q1\" AS quarter\n  UNION ALL\n  SELECT \"apple\" AS product, 10 AS sales, \"Q2\" AS quarter\n)\n|> PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2'));\n\n/*\n+---------+----+------+\n| product | Q1 | Q2  |\n+---------+-----------+\n| kale    | 55 | 45  |\n| apple   | 8  | 10  |\n+---------+----+------+\n*/\n\n\nUNPIVOT\n컬럼(Column)을 열(Row)로 회전\n\n(\n  SELECT 'kale' as product, 55 AS Q1, 45 AS Q2\n  UNION ALL\n  SELECT 'apple', 8, 10\n)\n|> UNPIVOT(sales FOR quarter IN (Q1, Q2));\n\n/*\n+---------+-------+---------+\n| product | sales | quarter |\n+---------+-------+---------+\n| kale   | 55    | Q1    |\n| kale   | 45    | Q2    |\n| apple  | 8     | Q1    |\n| apple  | 10    | Q2    |\n+---------+-------+---------+\n*/\n\n\nUNION ALL BY NAME\nUNION ALL을 할 때 이름으로 자동으로 매칭해줌(UNION ALL만 사용하면 순서도 맞춰줘야 함\n\nSELECT 1 AS one_digit, 10 AS two_digit\n|> UNION ALL BY NAME\n    (SELECT 20 AS two_digit, 2 AS one_digit);\n\n/*\n+-----------+-----------+\n| one_digit | two_digit |\n+-----------+-----------+\n| 1        | 10      |\n| 2        | 20      |\n+-----------+-----------+\n*/\n\n\n\nCALL\n테이블 값 함수(Table Value Function, TVF) 호출\n    \nTVF가 궁금하면 공식 문서 참고\n\nFROM input_table\n|> CALL tvf1(arg1)\n|> CALL tvf2(arg2, arg3);\n\n\n\nWINDOW\n윈도우 함수 계산하고 싶을 때 사용\n    \n윈도우 함수는 AGGREGATE와 사용하는 것이 아니고 WINDOW를 명시해서 사용해야 함\n\n(\n  SELECT 'apples' AS item, 2 AS sales\n  UNION ALL\n  SELECT 'bananas' AS item, 5 AS sales\n  UNION ALL\n  SELECT 'carrots' AS item, 8 AS sales\n)\n|> WINDOW SUM(sales) OVER() AS total_sales;\n\n/*\n+---------+-------+-------------+\n| item   | sales | total_sales |\n+---------+-------+-------------+\n| apples  | 2    | 15        |\n| bananas | 5    | 15        |\n| carrots | 8    | 15        |\n+---------+-------+-------------+\n*/\n\n\n\nDROP\n컬럼을 제외하고 싶을 때 사용\n\nSELECT 'apples' AS item, 2 AS sales, 'fruit' AS category\n|> DROP sales, category;\n\n/*\n+--------+\n| item  |\n+--------+\n| apples |\n+--------+\n*/\n\n\n\nRENAME\n컬럼의 이름을 변경하고 싶은 경우 사용\n\nSELECT 1 AS x, 2 AS y, 3 AS z\n|> AS t\n|> RENAME y AS renamed_y\n|> SELECT *, t.y AS t_y;\n\n/*\n+---+-----------+---+-----+\n| x | renamed_y| z | t_y |\n+---+-----------+---+-----+\n| 1 | 2       | 3 | 2  |\n+---+-----------+---+-----+\n*/\n\n\n\nAS\nInput 테이블에 대해 Alias를 지정하고 싶을 때 사용\n    \nWITH base 대신 AS를 바로 사용해서 쓸 수 있음\n\n(\n  SELECT \"000123\" AS id, \"apples\" AS item, 2 AS sales\n  UNION ALL\n  SELECT \"000456\" AS id, \"bananas\" AS item, 5 AS sales\n) AS sales_table\n|> AGGREGATE SUM(sales) AS total_sales GROUP BY id, item\n-- The sales_table alias is now out of scope. We must introduce a new one.\n|> AS t1\n|> JOIN (SELECT 456 AS id, \"yellow\" AS color) AS t2\n   ON CAST(t1.id AS INT64) = t2.id\n|> SELECT t2.id, total_sales, color;\n\n\n/*\n+-----+-------------+--------+\n| id  | total_sales| color  |\n+-----+-------------+--------+\n| 456 | 5         | yellow |\n+-----+-------------+--------+\n*/\n\n\n\n언제 유용할까?\nBigQuery 처음 학습하는 분들에게 추천\n    \n그러나 회사에서 BigQuery를 사용하지 않으면 애매함(다른 DB에선 아직 지원을 안할 수 있으므로)\nText to SQL을 구현할 때 추천\n    \n기존의 SQL 쿼리에서 파싱이 어려웠는데, 이젠 명확하게 쿼리를 분석하기 좋음\n자연어로 쿼리를 생성할 때, 파이프를 사용하는 것이 더 유리할 것으로 예상\n유사하게 Programmatic하게 쿼리를 생성할 때도 추천\n데이터 엔지니어링 파이프라인\n    \n데이터 엔지니어링 파이프라인 중 Flow가 중요한 경우 추천\n쉘 커맨드에서 데이터를 처리하는 것처럼 사용할 수 있음\n\n문법 정리\n문법을 잘 정리된 형태로 보면 좋을 것 같아, 별도의 웹페이지로 제작함\n    \nBigQuery Guide Book - 빅쿼리 가이드북 - PIPE Cheatsheet 참고\n\n\n\n\n\nStandardSQL vs Pipe 쿼리 비교\n초보자를 위한 BigQuery(SQL) 입문 강의에서 진행한 연습 문제 쿼리를 비교\nStandardSQL\n\n  SELECT\n    p.type1,\n    COUNT(tp.id) AS pokemon_cnt\n  FROM (\n    SELECT\n      id,\n      trainer_id,\n      pokemon_id,\n      status\n    FROM basic.trainer_pokemon\n    WHERE\n      status IN (\"Active\", \"Training\")\n  ) AS tp\n  LEFT JOIN basic.pokemon AS p\n  ON tp.pokemon_id = p.id\n  WHERE\n    type1 = \"Grass\"\n  GROUP BY\n    type1\n  ORDER BY\n    2 DESC \n\n    \nPIPE\n\n  FROM basic.trainer_pokemon AS tp\n  |> WHERE status IN ('Active', 'Training')\n  |> LEFT JOIN basic.pokemon AS p\n    ON tp.pokemon_id = p.id  \n  |> WHERE type1 = 'Grass'\n  |> AGGREGATE\n    COUNT(tp.id) AS pokemon_cnt\n    GROUP BY p.type1\n  |> ORDER BY pokemon_cnt DESC\n\n    \n\n확실히 더 직관적이고, 짧아짐\n\nFirebase, 앱 로그 데이터의 퍼널 쿼리 비교\nBigQuery 활용편(퍼널 분석, 리텐션 분석)에서 진행한 쿼리 비교\nStandardSQL\n\n  WITH base AS (\n    SELECT\n      event_date,\n      event_timestamp,\n      event_name,\n      user_id,\n      user_pseudo_id,\n      platform,\n      MAX(IF(event_param.key = \"firebase_screen\", event_param.value.string_value, NULL)) AS firebase_screen,\n      MAX(IF(event_param.key = \"session_id\", event_param.value.string_value, NULL)) AS session_id\n    FROM advanced.app_logs\n    CROSS JOIN UNNEST(event_params) AS event_param\n    WHERE\n      event_date BETWEEN \"2022-08-01\" AND \"2022-08-18\"\n    GROUP BY ALL\n  ), filter_event_and_concat_event_and_screen AS (\n    SELECT\n      * EXCEPT(event_name, firebase_screen, event_timestamp),\n      CONCAT(event_name, \"-\", firebase_screen) AS event_name_with_screen,\n      DATETIME(TIMESTAMP_MICROS(event_timestamp), 'Asia/Seoul') AS event_datetime\n    FROM base\n    WHERE\n      event_name IN (\"screen_view\", \"click_payment\")\n  )\n  SELECT\n    event_date, # 일자별로 퍼널별 유저 수 쿼리\n    event_name_with_screen,\n    CASE \n      WHEN event_name_with_screen = \"screen_view-welcome\" THEN 1\n      WHEN event_name_with_screen = \"screen_view-home\" THEN 2\n      WHEN event_name_with_screen = \"screen_view-food_category\" THEN 3\n      WHEN event_name_with_screen = \"screen_view-restaurant\" THEN 4\n      WHEN event_name_with_screen = \"screen_view-cart\" THEN 5\n      WHEN event_name_with_screen = \"click_payment-cart\" THEN 6\n    ELSE NULL\n    END AS step_number,\n    COUNT(DISTINCT user_pseudo_id) AS cnt\n  FROM filter_event_and_concat_event_and_screen\n  GROUP BY ALL\n  HAVING step_number IS NOT NULL\n  ORDER BY event_date, step_number\n\n    \nPIPE\n    \n좀 더 간결하게 만들 수 있을 것 같지만 일단 이정도로 올려봄\n\n  FROM advanced.app_logs\n  |> CROSS JOIN UNNEST(event_params) AS event_param\n  |> WHERE event_date BETWEEN \"2022-08-01\" AND \"2022-08-18\" AND event_name IN (\"screen_view\", \"click_payment\")\n  |> AGGREGATE\n     MAX(IF(event_param.key = \"firebase_screen\", event_param.value.string_value, NULL)) AS firebase_screen,\n     MAX(IF(event_param.key = \"session_id\", event_param.value.string_value, NULL)) AS session_id\n     GROUP BY event_date, event_timestamp, event_name, user_id, user_pseudo_id, platform\n  |> SELECT\n      * EXCEPT(event_name, firebase_screen, event_timestamp),  \n      CONCAT(event_name, \"-\", firebase_screen) AS event_name_with_screen,\n      DATETIME(TIMESTAMP_MICROS(event_timestamp), 'Asia/Seoul') AS event_datetime\n  |> EXTEND\n      CASE\n        WHEN event_name_with_screen = \"screen_view-welcome\" THEN 1\n        WHEN event_name_with_screen = \"screen_view-home\" THEN 2      \n        WHEN event_name_with_screen = \"screen_view-food_category\" THEN 3\n        WHEN event_name_with_screen = \"screen_view-restaurant\" THEN 4       \n        WHEN event_name_with_screen = \"screen_view-cart\" THEN 5\n        WHEN event_name_with_screen = \"click_payment-cart\" THEN 6        \n        ELSE NULL\n      END AS step_number\n  |> WHERE step_number IS NOT NULL    \n  |> AGGREGATE\n       COUNT(DISTINCT user_pseudo_id) AS cnt\n       GROUP BY event_date, event_name_with_screen, step_number\n  |> ORDER BY event_date, step_number\n\n    \nStandardSQL -> PIPE 마이그레이션 가이드\n1주일 정도 파이프 문법을 사용하면서 어떻게 옮겨야 할까? 생각해보고 작성한 내용입니다. 추후에 더 추가될 수도 있음\nFROM 절은 항상 쿼리의 시작\n    \n기존: FROM 절이 SELECT 절 뒤에 위치\n파이프: FROM 절을 쿼리의 가장 앞으로 이동\nJOIN은 FROM 절 안에 포함하거나 파이프 연산자로 분리\n    \n기존: FROM 절 안에서 JOIN 사용\n파이프: FROM 절 안에 JOIN을 그대로 사용하거나, 별도의 파이프 연산자로 분리\nWHERE 절은 필터링이 필요한 위치에 파이프 연산자를 사용하여 배치\n    \n기존: WHERE 절은 FROM 절과 GROUP BY 절 사이에 위치\n파이프: WHERE 절을 필요한 위치에 파이프 연산자로 연결\nSELECT 절은 주로 쿼리의 뒷부분에 파이프 연산자를 사용하여 배치\n    \n기존: SELECT 절이 쿼리의 맨 앞에 위치\n파이프: SELECT 절을 필요한 위치에 파이프 연산자로 연결, 주로 쿼리의 뒷부분에 배치\nGROUP BY와 집계 함수는 AGGREGATE 파이프 연산자를 사용\n    \n기존: GROUP BY와 집계 함수를 SELECT 절과 함께 사용\n파이프: GROUP BY와 집계 함수를 AGGREGATE 파이프 연산자로 결합하여 사용\n서브쿼리는 파이프 연산자를 사용하여 단계적으로 처리\n    \n기존: 여러 개의 중첩된 서브쿼리 사용\n파이프: 파이프 연산자를 사용하여 서브쿼리를 단계적으로 연결(AS 사용)\n불필요한 절과 구문은 제거하고 쿼리를 간소화한다.\n    \n기존: 복잡하고 중복된 구문 사용\n파이프: 파이프 연산자를 활용하여 쿼리를 간소화하고 가독성 향상\n\n참고 자료\nSQL Has Problems. We Can Fix Them: Pipe Syntax In SQL\nBigQuery Pipe 공식 문서\nRevolutionizing SQL with pipe syntax, now available in BigQuery and Cloud Logging\n글 작성하는데 걸린 시간 : 167분\n    \n하고자 하는 이야기, 개요 정리 : 10분\n초안 글 작성 : 112분\n초안 후 수정 : 45분\n이 개념에 대한 학습은 150분 정도 소요",
    "reviews": [],
    "syllabus": [],
    "link": "https://zzsza.github.io/gcp/2025/03/01/bigquery-pipe/",
    "pubDate": "Sat, 01 Mar 2025 00:00:00 +0000",
    "creator": "Unknown",
    "categories": [
      "BigQuery",
      "gcp"
    ]
  },
  {
    "id": 15,
    "imageUrl": "",
    "title": "c# 실수 / 배열에서 콤마 빼먹어도 돌아가네",
    "description": "코드\nfloat[] arr_pos = new float[] {\n   -2.55f, \n   -2.0f     // <-- 여기에 콤마가 없습니다.\n   -1.5f, \n  -0.85f, \n   0, \n   0.85f, \n   1.5f, \n   2.0f, \n   2.55f, \n};\n요 코드 입니다. \n-2.0f 뒤에 콤마를 빼먹어도 컴파일이 됩니다.\n저는 배열이 당연 9개라고 생각했지만 콤마가 없어서 8개가 됩니다.\n숫자는 이상하게 들어가 버리나봅니다.\n \n컴파일에서 요류가 나게 하려면 배열의 크기를 지정하면 됩니다.\nfloat[] arr_pos = new float[9] { // 9개라고 선언해버림\n   -2.55f,\n   -2.0f     // <-- 여기에 콤마가 없습니다.\n   -1.5f,\n  -0.85f,\n   0,\n   0.85f,\n   1.5f,\n   2.0f,\n   2.55f,\n};\n이러면 9개를 초기값으로 넣으라고 오류를 냅니다.\n잡는데 오래걸려서 납겨둡니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1158",
    "pubDate": "Fri, 28 Feb 2025 00:07:42 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/개발메모"
    ]
  }
]