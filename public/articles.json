[
  {
    "id": 1,
    "imageUrl": "",
    "title": "네팔 혁명은 디스코드로 부터",
    "description": "영상: https://www.youtube.com/watch?v=i8axj6qTXjk&t=104s\n\n\n\n \n시위 상태에서 군은 시민을 보호했고 대통령을 교체에 성공했습니다.\n이때 대통령 교체 투표를 디스코드로 했다는 것입니다.\n디스코드 대단하네요",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1391",
    "pubDate": "Sun, 14 Sep 2025 20:23:40 +0900",
    "creator": "SIDNFT",
    "categories": [
      "유튜브",
      "네팔",
      "디스코드",
      "중국"
    ]
  },
  {
    "id": 2,
    "imageUrl": "",
    "title": "포토샵은 옛말? 2025년, 나노바나나로 사진 편집 끝내기!",
    "description": "사진 편집, 아직도 어렵고 복잡하게 느끼시나요? 포토샵의 높은 문턱에 좌절했던 분들이라면 주목해주세요! 2025년, 구글 Gemini의 강력한 AI 모델 '나노바나나'가 사진 편집의 판도를 바꾸고 있습니다. 초보자도 전문가처럼, 단 몇 번의 대화만으로 놀라운 결과물을 얻을 수 있는 이 혁신적인 도구에 대해 자세히 알아보겠습니다.\n  포토샵은 옛말? AI 기반 이미지 편집의 도래\n\n\n예전에는 멋진 사진을 만들려면 포토샵 같은 전문 프로그램을 다루는 기술이 필수적이었죠. 하지만 수십 가지의 도구와 슬라이더, 복잡한 레이어 개념까지… 숙련된 편집자가 아니라면 원하는 결과를 얻기란 여간 어려운 일이 아니었습니다. 저 역시 처음 포토샵을 배울 때 수많은 튜토리얼을 찾아보며 진땀을 뺐던 기억이 생생합니다. 바로 이런 지점에서 AI 기술이 사진 편집의 새로운 지평을 열고 있습니다.\n최근 저는 제 셀피를 픽셀(Pixel)의 AI 편집 기능으로 수정해봤는데, 결과가 정말 훌륭했어요. 그러나 이제는 Gemini를 통해 편집하면 포토샵이 필요 없을 정도로 놀라운 경험을 할 수 있게 되었습니다. 특히 Gemini의 최신 모델인 ‘나노바나나(Nano Banana)’는 이미지 편집에 특화되어, 마치 마법처럼 사진을 변신시켜줍니다.\n✂️ 포토샵, 그 익숙함 뒤의 불편함\n포토샵은 분명 놀라운 소프트웨어입니다. 전문적인 결과물을 만들어낼 수 있는 다양한 도구들을 제공하며, 일부는 AI 기술로 구동되기도 하죠. 막히는 부분이 있다면 인터넷에 넘쳐나는 튜토리얼이 큰 도움이 됩니다. 하지만 포토샵을 제대로 활용하려면 몇 가지 넘어야 할 산이 있습니다.\n높은 진입 장벽: 기술과 비용\n기술적 난이도: 포토샵은 일정 수준의 기술 숙련도를 요구합니다. 수많은 기능들을 익히는 데 상당한 시간과 노력이 필요하죠.\n고사양 컴퓨터: 프로그램을 원활하게 실행하려면 강력한 사양의 컴퓨터가 필요합니다.\n구독료 부담: 어도비(Adobe)의 구독료는 적지 않은 재정적 투자를 요구합니다. 첫 사진을 열어보기도 전에 비용 지불이 선행되어야 합니다.\n복잡한 사용법과 시간 투자\n물론 포토샵이 제공하는 정밀한 제어 기능은 훌륭합니다. 하지만 사실 전문 사진작가나 그래픽 디자이너가 아니라면 그 모든 기능이 다 필요하지 않을 때가 많습니다. 대부분의 일반적인 사진 편집에는 포토샵이 제공하는 복잡성이 과도하게 느껴질 수 있습니다. 가파른 학습 곡선 때문에 원하는 결과물을 얻기까지 오랜 시간 시행착오를 겪어야 한다는 점도 큰 부담입니다.\n  팁! 전문적인 작업이 아니라면, 포토샵 대신 무료로 이용할 수 있는 다양한 대체 프로그램들도 많습니다. 하지만 AI 편집 도구는 그마저도 뛰어넘는 간편함을 제공하죠.\n  나노바나나의 등장: 이미지 편집의 새로운 기준\nGemini의 2.5 Flash 모델, 코드명 나노바나나(Nano Banana)는 이미지 편집의 패러다임을 완전히 바꾸고 있습니다. 이제 수백 개의 슬라이더와 도구를 조작하는 대신, 여러분이 원하는 변경 사항을 단순히 입력하거나 말하기만 하면 Gemini가 알아서 편집을 처리해 줍니다. 정말 놀랍지 않나요?\n간편함의 미학: 직관적인 AI 편집\n나노바나나를 사용하는 방법은 매우 간단합니다. 데스크톱에서 Gemini 웹사이트에 접속하거나 Gemini 앱을 열고 ‘이미지 생성(Create images)’ 모드를 선택합니다. 그 다음, “+” 아이콘을 눌러 편집하고 싶은 이미지를 업로드하고 원하는 편집 내용을 텍스트로 입력하기만 하면 됩니다. 정말 이보다 더 쉬울 수 있을까요?\n구독료도, 고사양 컴퓨터도 필요 없습니다. 그냥 원하는 편집을 Gemini에게 알려주기만 하면 끝입니다. 나노바나나는 특히 다음과 같은 작업에 매우 강력한 성능을 보여줍니다.\n기능\n설명\n\n\n\n\n객체 제거 및 추가\n사진 속 불필요한 요소를 지우거나 새로운 객체를 자연스럽게 추가합니다.\n\n\n배경 교체\n원하는 배경으로 사진의 분위기를 완전히 바꿀 수 있습니다.\n\n\n이미지 간 스타일 전환\n특정 이미지의 스타일을 다른 이미지에 적용하여 독특한 결과물을 만듭니다.\n\n\n색상 및 조명 조정\n사진의 색감과 밝기를 최적화하여 분위기를 살립니다.\n\n\n여러 사진 합성\n두 장 이상의 사진을 자연스럽게 하나로 합쳐줍니다.\n\n\n\n ️ 대화형 편집: 창의력의 날개를 달다\n나노바나나로 사진을 편집할 때 가장 매력적인 점은 바로 ‘다단계 대화형 편집’이 가능하다는 것입니다. 한 번의 프롬프트에서 모든 변경 사항을 지정할 필요 없이, 마치 친구와 대화하듯 편집을 이어나갈 수 있습니다. 예를 들어, 첫 번째 요청으로 하늘을 바꾸고, 다음 요청으로 조명을 미세하게 조절하거나 배경 요소를 추가·삭제하는 식이죠.\n단계별 편집의 자유\n이러한 대화형 편집 방식은 여러분의 편집 경험 자체를 변화시킵니다. 더 이상 복잡한 도구와 기술 수준에 얽매이지 않고, 오롯이 자신의 창의적인 아이디어 구현에 집중할 수 있게 됩니다. 편집 속도가 빠르고 노력도 적게 들기 때문에, 다양한 아이디어를 주저 없이 시도해볼 수 있다는 것도 큰 장점입니다. 이제는 기술이 아니라 여러분의 창의적인 비전이 편집의 중심이 됩니다.\n음성 편집, 아직은 성장 중\n만약 타이핑이 번거롭다면, 음성 모드로 전환해 Gemini에게 말로 편집을 요청할 수도 있습니다. 하지만 제 경험상 아직 음성 모드는 완벽하게 작동하지는 않았습니다. 가끔 설명 없는 오류가 반복적으로 발생하곤 했어요. 원인은 알 수 없지만, 텍스트 입력은 언제나 안정적으로 작동했으니 참고하시면 좋겠습니다.\n✍️ 나노바나나 프롬프트, 이렇게 활용해 보세요!\n나노바나나의 AI 편집 능력은 여러분의 프롬프트에 달려있습니다. 원하는 결과를 얻기 위해서는 명확하고 구체적인 설명이 중요합니다. 다음은 효과적인 프롬프트를 작성하기 위한 몇 가지 팁입니다.\n구체적인 지시: 단순히 ‘배경을 바꿔줘’보다는 ‘배경을 울창한 열대우림으로 바꿔주고, 빛은 나뭇잎 사이로 스며드는 듯한 효과를 줘’와 같이 구체적으로 설명해주세요.\n명확한 목표: ‘사진을 더 밝게’보다는 ‘전체적으로 따뜻한 색감으로 밝기를 한 단계 올려줘’와 같이 목표를 명확히 제시합니다.\n단계별 접근: 복잡한 편집은 한 번에 처리하기보다 여러 단계로 나누어 요청하는 것이 좋습니다. 예를 들어, 먼저 객체를 제거하고, 그 다음 배경을 교체한 후, 마지막으로 색상 보정을 하는 식입니다.\n예시 활용: 특정 스타일이나 느낌을 원한다면, ‘인상주의 화풍으로 바꿔줘’처럼 예시를 들어 설명할 수도 있습니다.\n  팁! 처음에는 간단한 편집부터 시작하여 나노바나나의 작동 방식을 익히는 것이 좋습니다. 점점 더 복잡한 요청을 시도하며 여러분만의 노하우를 쌓아가세요!\n⏱️ 복잡한 작업도 순식간에: 시간 절약의 마법\n포토샵에서 배경을 바꾸는 단순한 작업조차 숙련자에게도 몇 분, 초보자에게는 몇 시간이 걸릴 수 있습니다. 레이어 작업이나 마스킹을 통해 객체를 제거하거나 배경을 교체하고, 요소를 옮기는 데 많은 집중과 시간이 필요하죠. 하지만 나노바나나에서는 같은 작업을 불과 몇 초 만에 끝낼 수 있습니다.\n제가 직접 경험한 일화가 있습니다. 친구가 자전거 사고를 당해서 병원에 있었고, 사고 난 자전거 사진을 보내주기를 원했어요. 손상된 자전거가 수리점으로 운반 중인 사진이었는데, 저는 나노바나나에게 사진을 산속에 주차된 것처럼 편집해 달라고 요청했습니다. 결과는 정말 놀라웠어요! 자전거와 헬멧까지 정확하게 표현했고, 심지어 그림자, 조명, 흙먼지까지 자연스럽게 반영되어 있었죠. 이 정도 편집을 포토샵에서 했다면 훨씬 오랜 시간이 걸렸을 뿐 아니라 반드시 책상 앞에 앉아 작업해야 했을 겁니다. 나노바나나는 워터마크 제거, 배경 교체, 객체 추가·삭제를 거의 요청과 동시에 수행해냅니다.\n✅ 일관성 유지: AI 편집의 신뢰성 확보\n기존 AI 편집 도구의 가장 큰 문제점 중 하나는 바로 ‘일관성’이었습니다. 특히 인물의 얼굴이나 주요 피사체가 편집 과정에서 미묘하게 바뀌어 버리는 경우가 많았죠. 나 자신이나 지인의 사진을 편집할 때 작은 변화만 있어도 어색하게 느껴질 수 있습니다. 비슷하지만 똑같지 않은 AI 편집 결과물은 사실상 쓸모가 없었습니다.\n인물, 반려동물 사진 편집의 안정성\n하지만 구글은 Gemini, 특히 나노바나나를 개발하면서 이러한 문제점을 해결하는 데 집중했습니다. 나노바나나는 사람, 가족, 친구, 반려동물의 사진을 편집할 때 원래 모습의 일관성을 유지할 수 있도록 설계되었습니다. 따라서 어떤 편집을 하든 인물의 모습은 그대로 유지될 가능성이 매우 큽니다. 이제 AI가 임의로 추가하는 왜곡된 결과물이 아닌, 여러분이 지정한 편집만 정확히 반영된 결과물을 기대할 수 있습니다.\n여러 사진 합성도 자연스럽게\n이러한 일관성 유지 기능은 특히 여러 이미지를 합성하여 한 장의 결과물을 만들 때 더욱 유용합니다. 두 장의 사진 속에 있던 사람들이 하나의 프레임에 함께 있어도 각자의 모습이 자연스럽게 유지되는 것을 확인할 수 있습니다. 이제 여러분의 소중한 추억을 AI의 도움으로 더욱 아름답게 만들 수 있습니다.\n  핵심 요약\n✅ 간편한 접근성: 포토샵과 달리 고사양 PC나 유료 구독 없이 Gemini 웹사이트나 앱에서 즉시 이용 가능합니다.\n✅ 직관적인 대화형 편집: 복잡한 도구 없이 자연어 프롬프트(텍스트 또는 음성)로 원하는 편집을 명령할 수 있습니다.\n✅ 시간 절약과 효율성: 배경 교체, 객체 제거 등 복잡한 작업도 수 초 만에 처리하여 작업 시간을 혁신적으로 단축합니다.\n✅ 일관성 유지: 인물이나 주요 피사체의 원래 모습을 정확히 보존하며, 여러 사진 합성 시에도 자연스러운 결과물을 제공합니다.\n나노바나나는 전문가뿐만 아니라 일반 사용자에게도 사진 편집의 즐거움을 선사하는 강력한 도구입니다. 지금 바로 경험해보세요!\n ️ 대화형 편집: 창의력의 날개를 달다\n1.  애니메이션을 실제 모델로 변경\nGenerate a photo of a girl cosplaying this illustration, with the background set at Comiket\n\n\n \n2.  다양한 헤어스타일로 변경\n\n\nGenerate avatars of this person with different hairstyles in a 3x3 grid format\n \n 3.  드로잉과 사진의 합성\n\n\nChange the pose of the person in Figure 1 to that of Figure 2, and shoot in a professional studio\n❓ 자주 묻는 질문 (FAQ)\nQ1: 나노바나나는 포토샵을 완전히 대체할 수 있나요?\nA1: 나노바나나는 일반적인 사진 편집 작업을 매우 쉽고 빠르게 처리하여 포토샵의 필요성을 크게 줄여줍니다. 하지만 그래픽 디자인이나 고도로 정밀한 수작업이 필요한 전문적인 작업에서는 여전히 포토샵이 주된 도구로 사용될 수 있습니다. 나노바나나는 포토샵의 훌륭한 대안이자 보완재 역할을 합니다.\nQ2: 나노바나나를 사용하려면 별도 프로그램 설치나 구독이 필요한가요?\nA2: 아니요, Gemini의 2.5 Flash 모델인 나노바나나는 Gemini 웹사이트나 앱에서 ‘이미지 생성’ 모드를 통해 바로 사용할 수 있습니다. 별도의 프로그램 설치나 유료 구독 없이 무료로 주요 편집 기능을 이용할 수 있어 접근성이 매우 뛰어납니다.\nQ3: AI 편집 시 인물이나 배경이 부자연스러워지지는 않나요?\nA3: 나노바나나는 인물, 가족, 친구, 반려동물 등의 주요 피사체를 편집할 때 원래 모습의 일관성을 유지하도록 설계되었습니다. 배경 교체나 객체 추가 시에도 자연스러운 그림자, 조명, 질감을 반영하여 전체적인 조화를 해치지 않는 뛰어난 결과물을 제공합니다.\n포토샵은 여전히 그래픽 디자이너와 전문 사진작가들의 강력한 도구로 남을 것입니다. 하지만 Gemini의 나노바나나는 훌륭한 대안이자 혁신적인 미래를 제시합니다. 복잡한 제어나 기술적인 도구 다루는 것에 어려움을 느끼는 분들에게, 나노바나나는 사진을 쉽고 빠르게 원하는 대로 편집할 수 있는 최고의 도구가 될 것입니다. 지금 바로 나노바나나로 여러분의 사진 편집 경험을 한 단계 업그레이드해보세요!\n\n \n나노바나나를 가장 스마트하게 사용하는 법. 바나나 캔버스 무료 공개\nAI 이미지 생성과 편집의 새로운 지평을 연 구글의 제미나이 2.5 Flash Image, 일명 나노바나나를 가장 스마트하게 활용하는 법을 소개합니다. 특히 나노바나나의 강력한 기능을 누구나 쉽게 사용할\nmuzbox.tistory.com",
    "reviews": [],
    "syllabus": [],
    "link": "http://muzbox.tistory.com/483654",
    "pubDate": "Thu, 11 Sep 2025 10:59:40 +0900",
    "creator": "어떤오후의 프리웨어 이야기",
    "categories": [
      "AI, 미래기술/AI 인사이트",
      "AI 사진 합성",
      "AI 이미지 보정",
      "AI 편집 튜토리얼",
      "gemini 2.5 flash",
      "Gemini AI 편집",
      "나노바나나",
      "무료 사진 편집",
      "사진 편집 AI",
      "쉬운 사진 편집",
      "포토샵 대체"
    ]
  },
  {
    "id": 3,
    "imageUrl": "",
    "title": "[MULTI] 우리 시리즈 정상 영업합니다, 슈퍼로봇대전 Y",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://bbs.ruliweb.com/news/board/11/read/2359",
    "pubDate": "Thu, 11 Sep 2025 21:26:37 +0900",
    "creator": "(RULIWEB`Д')/",
    "categories": [
      "리뷰"
    ]
  },
  {
    "id": 4,
    "imageUrl": "",
    "title": "습관을 형성하는 기계",
    "description": "얼마 전에 한 팟캐스트에서 습관에 대해 연구하는 작가의 인터뷰를 들었다. 이분이 최근에 출시한 책은 습관은 무엇이고, 어떻게 하면 큰 목표를 달성하기 위한 습관을 형성할 수 있는지에 대한 내용인데, 이 책을 출간하면서 가장 많이 참고했던 게 군대이고, 가장 많이 인터뷰했던 사람들이 군인이라고 한다. 특히 작가가 했던 말 중 내 기억에 인상 깊게 남았던 말은 “군대는 습관을(...)",
    "reviews": [],
    "syllabus": [],
    "link": "https://www.thestartupbible.com/2025/09/the-habit-forming-machine.html",
    "pubDate": "Wed, 10 Sep 2025 21:28:00 +0000",
    "creator": "Kihong Bae",
    "categories": [
      "Uncategorized",
      "FoundersAtWork",
      "inspiring",
      "people"
    ]
  },
  {
    "id": 5,
    "imageUrl": "",
    "title": "JetBrains at the ICPC World Finals 2025 Baku",
    "description": "The ICPC World Finals 2025 in Baku was an unforgettable event, and we were honored to be part of it once again. It’s always a joy to see the brightest students from across the globe. The Finals reminds us why supporting the ICPC is such a vital mission – it’s about community, talent, and the […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/blog/2025/09/11/jetbrains-at-the-icpc-world-finals-2025-baku/",
    "pubDate": "Thu, 11 Sep 2025 14:22:17 +0000",
    "creator": "Margarita Shadrina",
    "categories": [
      "competitive-programming",
      "icpc"
    ]
  },
  {
    "id": 6,
    "imageUrl": "",
    "title": "[MULTI] 도전과 절망 그리고 그 끝의 절정, 할로우 나이트 : 실크송",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://bbs.ruliweb.com/news/board/11/read/2356",
    "pubDate": "Wed, 10 Sep 2025 16:12:50 +0900",
    "creator": "［RULIWEB］",
    "categories": [
      "리뷰"
    ]
  },
  {
    "id": 7,
    "imageUrl": "",
    "title": "걸음 보조 로봇 기사",
    "description": "영상: https://www.youtube.com/watch?v=QjHcJfI7Cik\n\n\n\n \n치아 임플란트 처럼 결국 더 걸을 수 있음으로서\n인간의 수명은 늘어날 것입니다.\n \n추천주\n미국 - 테슬라, 엔비디아\n한국 - 로보티즈, 원익홀딩스\n중국 - Kodex 차이나휴머노이드로봇\n잘모르시면 그냥 글로벌로\nPLUS 글로벌휴머노이드로봇액티브",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1389",
    "pubDate": "Sat, 13 Sep 2025 13:18:23 +0900",
    "creator": "SIDNFT",
    "categories": [
      "투자",
      "로봇"
    ]
  },
  {
    "id": 8,
    "imageUrl": "",
    "title": "치열한 미·중 갈등 속에서 찾는 투자 전략",
    "description": "중국 견제에 진심인 미국과 버틸 힘을 기르는 중국",
    "reviews": [],
    "syllabus": [],
    "link": "https://toss.im/tossfeed/article/US-Investment-Insights-2",
    "pubDate": "Mon, 15 Sep 2025 09:19:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 9,
    "imageUrl": "",
    "title": "Democratizing Performance: The Copilot Profiler Agent in Action on Real Code",
    "description": "We’re excited to announce the Copilot Profiler Agent available in Visual Studio 2026 Insiders, it’s an AI-powered performance assistant built directly into Visual Studio. Forget staring at endless call trees or walls of mysterious numbers that leave you asking, “where do I even start?” The Copilot Profiler Agent changes that.   Instead of raw data, you […]\nThe post Democratizing Performance: The Copilot Profiler Agent in Action on Real Code appeared first on Visual Studio Blog.",
    "reviews": [],
    "syllabus": [],
    "link": "https://devblogs.microsoft.com/visualstudio/copilot-profiler-agent-visual-studio/",
    "pubDate": "Thu, 11 Sep 2025 16:05:09 +0000",
    "creator": "Harshada Hole",
    "categories": [
      "Visual Studio",
      "Debugging and Diagnostics",
      "Performance Improvements",
      "Profiling",
      "Visual Studio 2026"
    ]
  },
  {
    "id": 10,
    "imageUrl": "",
    "title": "게임 성인물 차단 움직임이 점점 강해지고 있다.",
    "description": "좋다 나쁘다의 판단은 없습니다.\n문화의 움직임은 중요하기 때문에 관심을 가져야합니다.\n \n작년\n일본 성인 만화 결제를 비자가 막았습니다.\n올해\n스팀과 이치.io 에서 성인물 관련 게임을 차단했고\n마스터카드도 동창했습니다.\n영국의 온라인 안전법 등장\n넥서스모드도 성인 인증후에 모드를 다운로드 할 수 있습니다.\n \n \n영상: https://www.youtube.com/watch?v=0glLHO42dow\n\n\n\n5분에 나옵니다.\n \n유저들은 검열이라면서 불만을 쏟아내고 있는데\n성인물을 차단하는 근본적인 이유는 잘 모르겠습니다.\n \n아무튼 카드회사에 이어 국가도 나섰다는 점을 주목해야할 것입니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1390",
    "pubDate": "Sat, 13 Sep 2025 17:42:30 +0900",
    "creator": "SIDNFT",
    "categories": [
      "투자",
      "게임",
      "성인물"
    ]
  },
  {
    "id": 11,
    "imageUrl": "",
    "title": "[MULTI] 루터슈터의 왕좌 탈환, 보더랜드 4",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://bbs.ruliweb.com/news/board/11/read/2358",
    "pubDate": "Thu, 11 Sep 2025 21:05:01 +0900",
    "creator": "「RULIWEB」",
    "categories": [
      "리뷰"
    ]
  },
  {
    "id": 12,
    "imageUrl": "",
    "title": "Your Voice Belongs Here: Creating Compelling KotlinConf Proposals [Livestream]",
    "description": "Have you given a talk before – maybe at a meetup, online event, or a smaller conference – and wondered if you’re ready for a bigger stage like KotlinConf? This supportive and practical webinar is designed for people from underrepresented groups in tech who already have some speaking experience and are ready to level up. […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/kotlin/2025/09/creating-kotlinconf-proposals/",
    "pubDate": "Fri, 12 Sep 2025 16:57:17 +0000",
    "creator": "Ksenia Shneyveys",
    "categories": [
      "news",
      "kotlinconf"
    ]
  },
  {
    "id": 13,
    "imageUrl": "",
    "title": "태재 AI 아카데미 - 금융 AI 전망 (윤송이 박사) - 금융 + AI 과정",
    "description": "태재 AI 아카데미: 금융 + AI 과정 챗GPT (3.5) 출시 후 빠르게 나왔던 엔씨 LLM 바르코와 <가장 인간적인 미래> 책으로 만났던, 윤송이 박사님 “AI Transformation at Full Speed in Finance\" 강연  몇 가지 인사이트가 인상에 남아 잊기 전 기록  - AI 버블은 기술 거품이라기보다, 유능한 창업자 공급 부족으",
    "reviews": [],
    "syllabus": [],
    "link": "https://brunch.co.kr/@@PUo/49",
    "pubDate": "Thu, 11 Sep 2025 15:33:23 GMT",
    "creator": "Soomin Kim",
    "categories": []
  },
  {
    "id": 14,
    "imageUrl": "",
    "title": "Kotlin 2.2.20 Released",
    "description": "The Kotlin 2.2.20 release is out, delivering important changes for web development. Kotlin/Wasm is now Beta, with improvements to exception handling in JavaScript interop, npm dependency management, built-in browser debugging support, and a new shared source set for js and wasmJs targets. Additionally, here are some main highlights: For the complete list of changes, see […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/kotlin/2025/09/kotlin-2-2-20-released/",
    "pubDate": "Wed, 10 Sep 2025 09:54:07 +0000",
    "creator": "Sarah Haggarty",
    "categories": [
      "releases"
    ]
  },
  {
    "id": 15,
    "imageUrl": "",
    "title": "Kubernetes CPU Limit을 사용하면 벌어지는 일",
    "description": "[![NHN Cloud_meetup banner_K8s CPU limit_202509-01.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerK8s%20CPU%20limit20250901.png)](https://www.nhncloud.com/kr)\r\r\n\r\r\n## 들어가며\r\r\n오늘날 대부분의 서비스가 컨테이너 환경을 이용하고 있고, 컨테이너를 실행하는 환경으로는 Kubernetes가 표준으로 자리 잡고 있습니다. Kubernetes에서 컨테이너를 실행할 때는 Pod를 사용하는데요. Pod를 사용할 때 컨테이너의 리소스를 얼마나 할당할 것인가는 클러스터의 안정성과 연결되어 있기 때문에 중요한 문제 중 하나입니다. Pod의 컴퓨팅 리소스는 보통 다음과 같이 **requests**와 **limit**으로 설정할 수 있습니다.\r\r\n\r\r\n```\r\r\napiVersion: v1\r\r\nkind: Pod\r\r\nmetadata:\r\r\n  name: frontend\r\r\nspec:\r\r\n  containers:\r\r\n  - name: app\r\r\n    image: images.my-company.example/app:v4\r\r\n    resources:\r\r\n      requests:\r\r\n        memory: \"64Mi\"\r\r\n        cpu: \"250m\"\r\r\n      limits:\r\r\n        memory: \"128Mi\"\r\r\n        cpu: \"500m\"\r\r\n  - name: log-aggregator\r\r\n    image: images.my-company.example/log-aggregator:v6\r\r\n    resources:\r\r\n      requests:\r\r\n        memory: \"64Mi\"\r\r\n        cpu: \"250m\"\r\r\n      limits:\r\r\n        memory: \"128Mi\"\r\r\n        cpu: \"500m\"\r\r\n\r\r\n```\r\r\n\r\r\n리소스를 설정할 때 우리는 보통 메모리를 중심으로 정하는데요, 컨테이너의 메모리 사용량이 한계값에 도달하면 Pod는 재실행됩니다.\r\r\n그렇다면, CPU 사용량의 경우에는 어떨까요? 자주 사용되진 않지만 한 번쯤 알아두면 좋은 CPU 사용량 제한에 대해 알아보았습니다.\r\r\n\r\r\n## Kubernetes CPU Resource 설정\r\r\n먼저 Pod의 Resource 항목에서 설정 가능한 CPU의 Request와 Limit, 그리고 단위에 대해 알아보도록 하겠습니다.\r\r\n\r\r\n### 1. CPU Requests\r\r\nCPU requests는 컨테이너가 정상적으로 실행하기 위한 최소한의 CPU 양을 의미합니다. requests는 kube-scheduler가 Pod를 노드에 할당하는 스케줄링 작업에서 사용합니다. kube-scheduler는 Pod의 requests 값을 합산하여 할당 가능한 노드를 찾아서 Pod를 배치합니다. 노드에 Pod의 requests를 수용할 만한 여유가 있어야 할당이 되는 것이죠. 이 조건을 만족하는 노드가 없다면 Pod는 pending 상태로 스케줄링되지 않습니다.\r\r\nPod가 특정 노드에 스케줄링되었다면 요청된 CPU의 양은 보장됩니다. 이 말은 requests의 양만큼 CPU를 항상 점유한다는 뜻은 아닙니다. CPU 사용에 경합이 발생했을 때도 요청한 만큼의 CPU 시간을 할당 받는 것을 보장합니다. requests의 값이 없다면 Pod가 비효율적으로 배치될 수 있고 필요 이상의 클러스터 자원을 사용하여 불필요한 비용 지출이 발생할 수 있습니다.\r\r\n\r\r\n### 2. CPU Limits\r\r\nCPU limits는 컨테이너가 사용할 수 있는 CPU의 절대적인 최댓값을 의미하며 kubelet이 관리합니다. Pod의 컨테이너가 limits를 초과하여 CPU를 사용하려 할 때 해당 컨테이너의 CPU 사용을 인위적으로 낮추는 스로틀링(Throttling)을 통해 상한선을 강제합니다. limits는 여러 서비스가 동시에 실행되고 있는 Kubernetes 클러스터에서 하나의 컨테이너가 CPU를 과점하여 다른 컨테이너의 성능에 영향을 주거나 노드의 안정성을 해치는 CPU 기아 상태를 방지하는 데 의미가 있습니다.\r\r\n\r\r\n### 3. CPU Unit\r\r\nKubernetes에서 CPU의 단위는 절대적인 양으로 사용되며 1 Kubernetes CPU는 1vCPU 또는 물리적인 1 CPU 코어의 컴퓨팅 파워와 동일한 것으로 간주합니다.\r\r\nKubernetes에서는 코어를 밀리코어(millicore)로 더 작게 나누어 설정할 수 있습니다. 1000m은 1 CPU와 동일하며 0.5 CPU는 500m과 같습니다.\r\r\n\r\r\n### 4. QoS(quality of service, 서비스 품질) 클래스\r\r\nKubernetes는 설정한 requests와 limits에 따라서 자동으로 QoS 클래스를 할당합니다.\r\r\n• **Guaranteed (보장)**: Pod 내의 모든 컨테이너가 CPU와 메모리에 대해 requests와 limits를 모두 설정하고, 그 값이 서로 동일할 때(requests.cpu == limits.cpu) 할당됩니다. 이 Pod들은 가장 높은 우선순위를 가지며, 노드에 리소스 압박이 발생했을 때 가장 마지막에 축출(eviction)됩니다.\r\r\n• **Burstable (버스트 가능)**: Pod 내에 최소 하나 이상의 컨테이너가 CPU 또는 메모리 requests를 설정했지만, Guaranteed 클래스의 조건을 충족하지 못할 때 할당됩니다(예: requests.cpu < limits.cpu). 이 Pod들은 노드에 여유 리소스가 있을 경우, 요청한 양보다 더 많은 리소스를 \"버스트(burst)\"하여 사용할 수 있습니다.\r\r\n• **BestEffort (최선 노력)**: Pod 내의 어떤 컨테이너도 CPU나 메모리에 대한 requests나 limits를 설정하지 않았을 때 할당됩니다. 이 Pod들은 가장 낮은 우선순위를 가지며, 노드 리소스가 부족해지면 가장 먼저 축출 대상이 됩니다. \r\r\n\r\r\n## 리눅스 커널의 CPU 관리 메커니즘\r\r\nKubernetes에서 설정한 requests와 limits를 리눅스 커널이 어떻게 실제로 CPU를 할당하고 제한하는지 알아보도록 하겠습니다. 여기에는 컨테이너 기술을 탄생시킨 cgroup(Control Group)과 CFS(Completely Fair Scheduler)가 사용됩니다.\r\r\n\r\r\n### 1. 리눅스 컨트롤 그룹(cgroup)\r\r\ncgroup은 프로세스들의 집합에 대해 CPU, 메모리, I/O와 같은 시스템 리소스의 사용량을 제한하고, 추적하며, 격리합니다. cgroup은 /sys/fs/cgroup/이라는 가상 파일 시스템 내에 계층적 구조로 구성됩니다. Kubernetes는 이 구조 내에 kubepods.slice라는 전용 경로를 만들어 Pod들의 리소스를 관리합니다.\r\r\nCPU 리소스 관리를 담당하는 cgroup의 특정 모듈을 ‘컨트롤러’ 또는 ‘서브시스템’이라 부르며, Kubernetes가 CPU requests와 limits를 구현하기 위해 사용하는 것이 바로 CPU 서브시스템입니다.\r\r\n\r\r\n### 2. Completely Fair Scheduler(CFS)\r\r\nCFS는 리눅스 커널의 기본 프로세스 스케줄러로, 그 이름처럼 ‘완전한 공정성’을 목표로 합니다. CFS는 마치 ‘이상적인 멀티태스킹 CPU’가 존재하는 것처럼, 실행 가능한 모든 태스크(프로세스)가 정확히 동일한 비율의 CPU 시간을 할당 받도록 노력합니다.\r\r\n실제 하드웨어는 한 번에 하나의 작업만 실행할 수 있기 때문에, CFS는 ‘가상 런타임(virtual runtime, vruntime)’이라는 개념을 사용합니다. CFS는 항상 가장 작은 vruntime 값을 가진 작업, 즉 지금까지 가장 적게 실행된 작업을 선택하여 실행함으로써 장기적인 관점에서 공정성을 보장합니다.\r\r\n\r\r\n### 3. Kubernetes와 커널의 매핑\r\r\nkubelet은 Kubernetes의 yaml 명세를 실제 커널에 적용하기 위해서 변환 작업을 수행합니다. kubelet은 resources 설정을 읽어 해당 컨테이너의 cgroup 디렉터리 내 특정 파일에 값을 덮어쓰는 방식으로 커널에 지시를 내립니다.\r\r\n\r\r\n#### **3.1. Requests와 cpu.shares: 상대적 가중치 시스템**\r\r\nPod의 resources.requests.cpu 값은 cgroup의 cpu.shares 파일 값으로 변환됩니다. 공식은 다음과 같습니다.\r\r\n```\r\r\ncpu.shares=requests.cpu (millicores)×1024/1000.\r\r\n```\r\r\n예를 들어, 1000m(1 코어) 요청은 1024 shares로, 500m 요청은 512 shares로 변환됩니다. 가장 중요한 점은 cpu.shares가 **노드에 CPU 경합이 있을 때만 의미를 가지는 상대적 가중치**라는 것입니다. 만약 CPU 자원을 두고 경쟁하는 두 컨테이너가 있고, 하나는 2048 shares, 다른 하나는 1024 shares를 가지고 있다면, 전자는 후자보다 두 배의 CPU 시간을 할당 받게 됩니다. 하지만 노드가 유휴 상태이고 CPU 경합이 없다면, 컨테이너는 자신의 shares 값과 무관하게 필요한 만큼의 CPU를 사용할 수 있습니다.\r\r\n\r\r\n#### **3.2. Limits와 cpu.cfs_period_us & cpu.cfs_quota_us: 절대적 시간 할당량 시스템**\r\r\nPod의 resources.limits.cpu 값은 CFS 대역폭 제어라는 메커니즘을 통해 강제됩니다. 이 메커니즘은 두 가지 파라미터에 의해서 결정됩니다.\r\r\n• cpu.cfs_period_us: 할당량을 정산하는 주기로 단위는 마이크로초입니다. Kubernetes는 기본값인 100000(즉 100ms)을 사용합니다. 이 한 window 내에서 할당량이 정해집니다.\r\r\n• cpu.cfs_quota_us: 위에서 정의된 period 동안 cgroup이 소비할 수 있는 총 CPU 시간을 정의합니다. 단위는 마이크로초입니다. 이 값은 resources.limitscpu로부터 계산됩니다. limits가 없을 경우 -1로 할당량 없음을 의미합니다.\r\r\n\r\r\n변환 공식은 다음과 같습니다.\r\r\n```\r\r\ncpu.cfs_quota_us=limits.cpu (cores)×cpu.cfs_period_us.\r\r\n```\r\r\n예를 들어, limits.cpu를 500m(0.5 코어)로 설정하면, cpu.cfs_quota_us=0.5×100000=50000이 됩니다. 이는 해당 컨테이너가 매 100ms 주기마다 최대 50,000 마이크로초(50ms)의 CPU 시간만 사용할 수 있음을 의미합니다.\r\r\n\r\r\n#### 요약\r\r\n| Kubernetes 설정 | Kubernetes에서의 목적 | 리눅스 cgroup 파일 | 동작 |\r\r\n| --- | --- | --- | --- |\r\r\n| resources.requests.cpu | 스케줄링 및 경합 시 최소 CPU 보장 | cpu.shares | 상대적 가중치; CPU 경합 시에만 활성화 |\r\r\n| resources.lmits.cpu | 런타임 시 최대 CPU사용량 제한 | cpu.cfs_quota_us | 절대적 시간 할당량; 항상 활성화, 스로틀링 발생 |\r\r\n\r\r\n## Limits 적용으로 발생할 수 있는 현상\r\r\nCPU limits를 설정했을 때 발생하는 가장 중요하고 종종 오해 받는 현상이 바로 CPU 스로틀링입니다. 스로틀링은 단순히 성능을 약간 늦추는 것이 아니라, 애플리케이션의 지연 시간에 심각하고 예측 불가능한 영향을 미칠 수 있는 ‘정지-대기(stop-wait)’ 프로세스입니다.\r\r\n\r\r\n### 1. CPU 스로틀링과 발생 원인\r\r\nCPU 스로틀링은 컨테이너 내의 프로세스들이 현재의 cfs_period_us(보통 100ms) 동안 할당된 cfs_quota_us를 모두 소진했을 때 발생합니다. 할당량을 모두 사용한 컨테이너의 프로세스들은 커널 스케줄러에 의해 실행이 '정지'됩니다. 그리고 다음 100ms 주기가 시작되어 할당량이 다시 채워질 때까지 대기해야 합니다.\r\r\n이 현상은 특히 멀티 스레드 애플리케이션에서 증폭되어 나타납니다. 예를 들어, 한 컨테이너가 1 코어(cfs_quota_us=100000)의 limit을 가지고 있지만, 4개의 바쁜 스레드를 동시에 실행한다고 가정해 봅시다.\r\r\n이 컨테이너는 4개의 코어를 동시에 사용하여 단 25ms의 실제 시간만에 100ms의 CPU 시간 할당량을 모두 소진할 수 있습니다. 그 후, 해당 컨테이너는 남은 75ms 동안 노드에 유휴 코어가 있더라도 완전히 스로틀링되어 아무 작업도 수행할 수 없게 됩니다.\r\r\n![K8s_CPU limit_1.png](https://image.toast.com/aaaadh/real/2025/techblog/K8sCPU%20limit1.png)\r\r\n\r\r\n### 2. CPU 스로틀링으로 인한 지연 시간 증가\r\r\n![K8s_CPU limit_2.png](https://image.toast.com/aaaadh/real/2025/techblog/K8sCPU%20limit2.png)\r\r\n스로틀링은 애플리케이션 요청 처리 시간에 직접적으로 지연을 추가합니다. 예를 들어, 어떤 작업을 완료하는 데 순수하게 300ms의 CPU 시간이 필요한 애플리케이션이 100ms 주기당 50ms의 limit에 의해 제한된다고 가정해 봅시다. 이 작업은 다른 시스템 부하가 전혀 없더라도 최소 6개의 주기, 즉 600ms의 실제 시간이 걸려야 완료될 수 있습니다. 이러한 지연은 타임아웃, 연쇄적인 장애, 그리고 궁극적으로는 나쁜 사용자 경험으로 이어질 수 있습니다.\r\r\n스로틀링은 전통적인 CPU 사용률 지표로는 확인하기가 힘든 경우가 있습니다. 어떤 컨테이너가 CPU 사용률 50%(자신의 limit 값)를 보이고 있더라도, 실제로는 심각하게 스로틀링되어 매우 느린 상태일 수 있습니다. 이 경우 CPU는 전통적인 의미에서 '최대치로 사용'되는 것이 아니라, 인위적으로 억제되고 있는 상태입니다.\r\r\n\r\r\n\r\r\n### 3. '시끄러운 이웃' 오해\r\r\nlimits가 ‘시끄러운 이웃(noisy neighbor)’ 문제, 즉 하나의 애플리케이션이 리소스를 독점하여 다른 애플리케이션에 영향을 주는 것을 막아 줄 수 있을 것처럼 보입니다. 하지만 실제로는 requests에 의해 결정되는 cpu.shares가 경합 상황에서도 적절하게 리소스를 배분할 수 있는 시스템이라고 할 수 있습니다. 만약 모든 Pod에 적절한 requests가 설정되어 있다면, CFS 스케줄러는 shares 값에 비례하여 CPU 시간을 분배함으로써 특정 Pod가 다른 Pod들이 기아 상태에 빠지는 것을 방지합니다. 반면 limits는 다른 누구도 CPU를 필요로 하지 않는 상황에서조차 Pod의 사용량을 제한하는 무딘 도구에 가깝습니다.\r\r\n\r\r\n## 스로틀링 테스트\r\r\n테스트를 위해 한 웹 애플리케이션을 만들었습니다. 이 애플리케이션에 1 CPU를 할당하면 작업을 완료하는 데 대략 12초 정도 걸립니다.\r\r\n이 애플리케이션에 각각 1 CPU, 0.1 CPU를 할당하여 CPU 사용량과 작업 시간을 확인하여 지금까지 확인한 현상이 발생하는지 테스트해 보았습니다.\r\r\n\r\r\n### 테스트용 Pod 준비\r\r\n아래와 같이 CPU limit만 다르게 설정하여 Pod를 생성하였습니다.\r\r\n```\r\r\napiVersion: apps/v1\r\r\nkind: Deployment\r\r\nmetadata:\r\r\n  name: cpu-test-app\r\r\n  labels:\r\r\n    app: cpu-test-app\r\r\nspec:\r\r\n  replicas: 1\r\r\n  selector:\r\r\n    matchLabels:\r\r\n      app: cpu-test-app\r\r\n  template:\r\r\n    metadata:\r\r\n      labels:\r\r\n        app: cpu-test-app\r\r\n    spec:\r\r\n      containers:\r\r\n      - name: cpu-test-app\r\r\n        image: cpu-test-app\r\r\n        ports:\r\r\n        - containerPort: 8081\r\r\n        resources:\r\r\n          requests:\r\r\n            memory: \"64Mi\"\r\r\n            cpu: \"100m\"    # 0.1 코어\r\r\n          limits:\r\r\n            memory: \"128Mi\"\r\r\n            cpu: \"100m\"    # 0.1 코어로 제한\r\r\n        livenessProbe:\r\r\n          httpGet:\r\r\n            path: /health\r\r\n            port: 8080\r\r\n          initialDelaySeconds: 10\r\r\n          periodSeconds: 30\r\r\n        readinessProbe:\r\r\n          httpGet:\r\r\n            path: /health\r\r\n            port: 8080\r\r\n          initialDelaySeconds: 5\r\r\n          periodSeconds: 10\r\r\n---\r\r\n# 1 코어 제한 버전\r\r\napiVersion: apps/v1\r\r\nkind: Deployment\r\r\nmetadata:\r\r\n  name: cpu-test-app-1core\r\r\n  labels:\r\r\n    app: cpu-test-app-1core\r\r\nspec:\r\r\n  replicas: 1\r\r\n  selector:\r\r\n    matchLabels:\r\r\n      app: cpu-test-app-1core\r\r\n  template:\r\r\n    metadata:\r\r\n      labels:\r\r\n        app: cpu-test-app-1core\r\r\n    spec:\r\r\n      containers:\r\r\n      - name: cpu-test-app\r\r\n        image: cpu-test-app\r\r\n        ports:\r\r\n        - containerPort: 8080\r\r\n        resources:\r\r\n          requests:\r\r\n            memory: \"64Mi\"\r\r\n            cpu: \"1000m\"   # 1 코어\r\r\n          limits:\r\r\n            memory: \"128Mi\"\r\r\n            cpu: \"1000m\"   # 1 코어로 제한\r\r\n        livenessProbe:\r\r\n          httpGet:\r\r\n            path: /health\r\r\n            port: 8080\r\r\n          initialDelaySeconds: 10\r\r\n          periodSeconds: 30\r\r\n        readinessProbe:\r\r\n          httpGet:\r\r\n            path: /health\r\r\n            port: 8080\r\r\n          initialDelaySeconds: 5\r\r\n          periodSeconds: 10\r\r\n```\r\r\n\r\r\n### 응답 시간 비교\r\r\n0.1 CPU를 할당한 애플리케이션에서는 122초가 소요된 반면 1 CPU가 할당된 애플리케이션에서는 11.51초만 소요된 것을 확인할 수 있었습니다.\r\r\n![K8s_CPU limit_3.png](https://image.toast.com/aaaadh/real/2025/techblog/K8sCPU%20limit3.png)\r\r\n\r\r\n### 그라파나를 통한 스로틀링 현상 확인\r\r\n* 초록색: 1 CPU\r\r\n* 노란색: 0.1 CPU\r\r\n\r\r\nCPU 사용률에서 노란색 그래프가 CPU limits가 0.1로 설정되어 그 이상 사용하지 못하는 모습을 보여줍니다. CPU 할당 횟수에서 노란색이 Limits에 걸려서 더 많은 cpu 할당이 발생한 것을 확인할 수 있습니다. 이것은 스로틀링으로 인한 지연 시간 증가 시뮬레이션과 일치하는 결과입니다. 당연하게도 스로틀링 비율도 노란색이 더 높은 것을 알 수 있습니다.\r\r\n![K8s_CPU limit_4.png](https://image.toast.com/aaaadh/real/2025/techblog/K8sCPU%20limit4.png)\r\r\n중요한 지표는 스로틀링 비율로서 비율이 5%를 지속적으로 넘는 현상이 발생한다면 스로틀링이 빈번하게 발생하여 성능에 제약을 받아 서비스가 느려져 있을 가능성이 있으므로 조치를 취해야 합니다.\r\r\n\r\r\n#### 스로틀링 비율 지표 예시\r\r\n```\r\r\nsum by (namespace, pod) (rate(container_cpu_cfs_throttled_periods_total{container!=\"\"}[5m]))\r\r\n/\r\r\nsum by (namespace, pod) (rate(container_cpu_cfs_periods_total{container!=\"\"}[5m]))\r\r\n```\r\r\n\r\r\n## 나가며\r\r\n결론은 아래와 같습니다.\r\r\n* 일반적인 경우,\r\r\n\t* request만 설정하여 자원이 더 필요할 때는 노드의 가용 자원을 사용하고 자원이 모자랄 때는 비율로 할당 받도록 하는 것이 좋은 것 같습니다. (QoS는 Burstable로 설정됨)\r\r\n\t* QoS가 Burstable로 설정되지만 CPU는 Eviction의 조건이 아니기 때문에 throttling이 발생할지언정 pod가 eviction 되지는 않습니다.\r\r\n* limit만 설정하는 경우는 피해야 합니다. limit만 설정할 경우 request가 0이 되어 자원 가용량이 없는 노드에도 스케줄링 될 수 있으며 런타임 시 예측이 어려워집니다.\r\r\n* CPU request는 Pod가 노드에 할당될 때는 절댓값으로 사용되고 할당된 뒤에는 상대적인 비율로 사용됩니다.\r\r\n\r\r\n\r\r\n긴 글을 읽어 주셔서 감사합니다. \r\r\n\r\r\n### 참고 문헌\r\r\n• Kubernetes, Resource Management for Pods and Containers, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\r\r\n• KubeBlog, Understanding CPU Requests and Limits, 2023. 10. 5., https://www.kubeblog.com/basics/understanding-cpu-requests-and-limits/\r\r\n• Itiel Shwartz, Kubernetes CPU Limits: What’s the Right Way to Assign CPU Resources?, 2025. 1. 14., https://komodor.com/learn/kubernetes-cpu-limits-throttling/\r\r\n• Eliran Cohen, For the love of god, learn when to use CPU limits on Kubernetes., 2023. 3. 5., https://medium.com/@eliran89c/for-the-love-of-god-learn-when-to-use-cpu-limits-on-kubernetes-2225341e9dbd\r\r\n• Max Levin, Kubernetes CPU Throttling: What it is, and Best Practices, 2024. 6. 6., https://www.groundcover.com/blog/kubernetes-cpu-throttling\r\r\n• CODE FARM, Linux CGroups and Containers, 2024. 2. 3., https://blog.codefarm.me/2021/11/23/linux-cgroups-containers/\r\r\n• Andreas Karis Blog, Quick guide for cgroups, 2020. 9. 3., https://andreaskaris.github.io/blog/linux/cgroups/\r\r\n• Martin, Cgroups - Deep Dive into Resource Management in Kubernetes, 2023. 2. 20., https://martinheinz.dev/blog/91\r\r\n• Jianhao, Kubernetes CPU requests and limits, 2021. 11. 11., https://jaanhio.me/blog/kubernetes-cpu-requests-limits/\r\r\n• Red Hat, Resource Management Guide > CPU, https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/resource_management_guide/sec-cpu\r\r\n• Real-time Ubuntu, Linux kernel schedulers, https://documentation.ubuntu.com/real-time/latest/explanation/schedulers/\r\r\n• Rifewang, Kubernetes: CPU Configuration, Linux CFS, and Performance Issues with Programming Languages, 2024. 12. 11., https://medium.com/@rifewang/kubernetes-cpu-configuration-linux-cfs-and-performance-issues-with-programming-languages-ccef783ed22e\r\r\n• JettyCloud, Making Sense of Kubernetes CPU Requests And Limits, 2023. 3. 20., https://medium.com/@jettycloud/making-sense-of-kubernetes-cpu-requests-and-limits-390bbb5b7c92\r\r\n• Tania Duggal, PerfectScale, Kubernetes CPU Limit: Best Practices for Optimal Performance, 2024. 10. 24., https://www.perfectscale.io/blog/kubernetes-cpu-limit-best-practises\r\r\n• Shane Corbett, AWS Blogs, Using Prometheus to Avoid Disasters with Kubernetes CPU Limits, 2022. 9. 21., https://aws.amazon.com/blogs/containers/using-prometheus-to-avoid-disasters-with-kubernetes-cpu-limits/\r\r\n\r\r\n\r\r\n[![NHN Cloud_meetup banner_footer_blue_202509.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerfooterblue202509.png)](https://www.nhncloud.com/kr)",
    "reviews": [],
    "syllabus": [],
    "link": "https://meetup.nhncloud.com/posts/395",
    "pubDate": "Sun, 14 Sep 2025 23:39:12 GMT",
    "creator": "Unknown",
    "categories": []
  }
]