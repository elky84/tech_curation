[
  {
    "id": 1,
    "imageUrl": "",
    "title": "리눅스용 사용자 지정 스크립트 확장 사용 시 주의 사항",
    "description": "Considerations and Improvements When Using \"Custom Script for Linux\" Extensions \n가상 머신 확장 집합(VMSS)이나 가상 머신(VM)에서 리눅스 OS를 사용할 경우 [설정] 섹션의 [확장 프로그램 + 애플리케이션] 메뉴에서 리눅스용 사용자 지정 스크립트를 적용할 수 있습니다. \nAzure를 처음 사용하거나 포털 사용법이 아직 익숙하지 않은 사람의 경우 이 기능을 사용할 때 자주하는 실수가 있습니다. \n다음 그림은 우분투 서버를 사용하는 VM에서 자동화 스크립트를 적용하는 모습입니다. \n사람들이 자주하게 되는 실수는 [Script files] 항목에서 [찾아보기] 버튼을 눌러 실행하기 원하는 스크립트를 하나 이상 선택한 다음(빨간 상자), 아래 [Command] 항목의 녹색 상자내의 파란 상자 부분을 호출할 스크립트(이름 및 확장자)로 바꾸지 않고 사용자 지정 스크립트를 적용하는 경우입니다.\n \n\n\n \n이 기능을 몇 가지 케이스로 테스트해 봤습니다. 사용성을 조금 더 높여 실수를 줄일 수 있는 방안이라고 생각되는 2가지 개선안을 도출했고, 마이크로소프트에도 제안 메일을 보내놓은 상태입니다.\n혹, 받아들여지지 않더라도 가상머신에 자동화 스크립트를 적용할 때 이런 주의 사항이 있다는 점을 기억할 수 있도록 이 글을 작성해 놓은 것 자체로 의미가 있을 것 같습니다.\n \n[개선 제안 내용]\n1. 빨간 상자에 하나의 스크립트가 선택되면 파란 상자의 스크립트도 자동으로 변경합니다. \n2. 빨간 상자에 둘 이상의 스크립트가 선택되면, 최초 호출되는 스크립트 선택 창을 표시하고 선택한 스크립트로 변경합니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://www.dokyun.pe.kr/363",
    "pubDate": "Sun, 20 Apr 2025 21:05:27 +0900",
    "creator": "강철 벼룩",
    "categories": [
      "Azure &amp; Windows/Azure",
      "AzureVM",
      "customscript",
      "extension",
      "VMSS"
    ]
  },
  {
    "id": 2,
    "imageUrl": "",
    "title": "IntelliJ Scala Plugin 2025.1 Is Out!",
    "description": "Support for new features in Scala 3 Context Bounds and Givens Scala 3.6 introduced a new syntax for context bounds and givens. You can read more about it in SIP-64. In short, before Scala 3.6, it was impossible to name the context bound in the same place where it was defined. The way to do […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/scala/2025/04/16/intellij-scala-plugin-2025-1-is-out/",
    "pubDate": "Wed, 16 Apr 2025 13:05:20 +0000",
    "creator": "Maciej Gorywoda",
    "categories": [
      "news",
      "releases",
      "scala",
      "scala-programming",
      "intellij-idea"
    ]
  },
  {
    "id": 3,
    "imageUrl": "",
    "title": "유니티 픽셀라이저 / 도트로 보이게 만들자",
    "description": "영상: https://youtu.be/q4epArkvVnE?t=1034\n\n\n\n12분에 나옵니다.\n \n애셋 링크: bing.com/ck/a?!&&p=75737a337e71df6ed009a8ed37376a2d33afc7c860ba34cee95c9fb3c24d295aJmltdHM9MTc0NTAyMDgwMA&ptn=3&ver=2&hsh=4&fclid=103bf7f7-14f0-64e7-025e-e4ca15636503&psq=unity+asset+store+pro+pixelizer&u=a1aHR0cHM6Ly9hc3NldHN0b3JlLnVuaXR5LmNvbS9wYWNrYWdlcy92Zngvc2hhZGVycy9mdWxsc2NyZWVuLWNhbWVyYS1lZmZlY3RzL3Byb3BpeGVsaXplci1yZWFsdGltZS0zZC1waXhlbC1hcnQtMTc3ODc3Izp-OnRleHQ9QWRkJTIwZGVwdGglMjB0byUyMHlvdXIlMjBwcm9qZWN0JTIwd2l0aCUyMFByb1BpeGVsaXplciUyMC0sbW9yZSUyMFZGWCUyMG9wdGlvbnMlMjBvbiUyMHRoZSUyMFVuaXR5JTIwQXNzZXQlMjBTdG9yZS4&ntb=1\n\n \nunity asset store pro pixelizer - Bing\nBing은 지능적인 검색 기능은 사용자가 원하는 정보를 빠르게 검색하고 보상을 제공합니다.\nwww.bing.com\n\n \n애셋 홍보영상: ProPixelizer for Unity\n\n\n\n \n나중에 써보도록 하자",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1277",
    "pubDate": "Sun, 20 Apr 2025 15:48:46 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/유니티 에셋 리뷰",
      "유니티"
    ]
  },
  {
    "id": 4,
    "imageUrl": "",
    "title": "MPS 2025.1 Release Candidate Is Here!",
    "description": "We’re excited to announce that the Release Candidate for MPS 2025.1 is now available! Download it today and be among the first to try out the latest features and improvements. DOWNLOAD MPS 2025.1 RC Curious about what’s new? Check out this blog post for a deep dive into all the updates. The full list of […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/mps/2025/04/the-mps-2025-1-rc-ready/",
    "pubDate": "Thu, 17 Apr 2025 15:57:02 +0000",
    "creator": "Vaclav Pech",
    "categories": [
      "releases",
      "eap",
      "release"
    ]
  },
  {
    "id": 5,
    "imageUrl": "",
    "title": "Pure Virtual C++ 2025: Full Schedule",
    "description": "Pure Virtual C++ is our free, one-day, virtual conference for the whole C++ community. This year, it is running on the 30th April. We’re pleased to announce the schedule of live talks: 14:00 UTC: Welcome to v1.0 of the meta::[[verse]]! with Inbal Levi 14:30 UTC: Proxy: Next Generation Polymorphism with Mingxin Wang 15:00 UTC: Making […]\nThe post Pure Virtual C++ 2025: Full Schedule appeared first on C++ Team Blog.",
    "reviews": [],
    "syllabus": [],
    "link": "https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2025-full-schedule/",
    "pubDate": "Tue, 15 Apr 2025 12:15:38 +0000",
    "creator": "Sy Brand",
    "categories": [
      "C++"
    ]
  },
  {
    "id": 6,
    "imageUrl": "",
    "title": "유니티 애셋 / 살이 출렁이는 연출 /",
    "description": "영상: https://www.youtube.com/watch?v=VDyPjhugZSM\n\n\n\n \n \n홍보영상: https://www.youtube.com/watch?v=_mSPXq_2saU\n\n\n\n \n보잉 같은건가 싶기도 하고 ...\n아무튼 출렁임",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1273",
    "pubDate": "Fri, 18 Apr 2025 15:03:36 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/유니티 에셋 리뷰"
    ]
  },
  {
    "id": 7,
    "imageUrl": "",
    "title": "GPT-4.1, mini, nano 총정리: 성능, 가격, 활용법까지 한번에",
    "description": "GPT-4.1 시리즈의 혁신적 기능과 성능 향상을 소개합니다. 코딩, 긴 컨텍스트 처리, 지시 이행 능력이 크게 개선되었고, 최초의 나노 모델까지 출시된 GPT-4.1의 모든 것을 파헤쳐볼게요!\n\n\n \n어제 정말 신기한 뉴스를 봤어요. OpenAI가 또 새로운 모델을 출시했더라고요. 요새 AI 기술이 진짜 미친 속도로 발전하는데, 그냥 따라가기도 버거울 지경이에요. 근데 이번에 나온 GPT-4.1 시리즈는 뭔가 특별해 보이더라고요. 코딩 능력이 확 좋아졌다는데, 개발자분들은 어떻게 생각하세요? 저같은 일반인한테도 도움될까요?\n \nGPT-4.1 시리즈, 무엇이 달라졌을까?  \nOpenAI가 API를 통해 제공하는 세 가지 새로운 모델을 소개했어요. GPT-4.1, GPT-4.1 mini, 그리고 GPT-4.1 nano까지. 이 모델들은 기존의 GPT-4o와 GPT-4o mini보다 전반적으로 더 뛰어난 성능을 보여준다고 해요. 특히 코딩과 지시사항 이행 능력에서 엄청난 발전이 있었다고 하네요.\n \n가장 눈에 띄는 변화는 컨텍스트 윈도우의 크기예요. 무려 100만 토큰까지 처리할 수 있게 되었다고 해요! 이전 모델들이 128,000 토큰까지 처리할 수 있었던 것과 비교하면 정말 큰 발전이죠. 그리고 단순히 더 많은 컨텍스트를 처리하는 것뿐만 아니라, 그 컨텍스트를 더 효율적으로 이해하고 활용할 수 있게 되었다고 해요.\n \n또한 지식 기반도 업데이트되어 2024년 6월까지의 정보를 담고 있어요. 이제 좀 더 최신 정보에 대해서도 물어볼 수 있겠네요.\n \n코딩 능력이 대폭 향상됐어요  \n제가 개인적으로 가장 흥미로웠던 부분은 코딩 능력의 향상이에요. GPT-4.1은 SWE-bench Verified에서 54.6%의 점수를 받았다고 해요. 이는 GPT-4o의 33.2%보다 무려 21.4% 포인트나 높은 점수예요!\n모델\nSWE-bench Verified 점수\n향상된 정도\n\n\n\n\nGPT-4.1\n54.6%\n기준\n\n\nGPT-4o\n33.2%\n-21.4%\n\n\nGPT-4.5\n38.0%\n-16.6%\n\n\n\n실제 사용자들의 반응도 놀라웠어요. Windsurf라는 회사에서는 GPT-4.1이 내부 코딩 벤치마크에서 GPT-4o보다 60% 높은 점수를 받았다고 해요. 특히 도구 호출에서 30% 더 효율적이었고, 불필요한 편집을 반복할 가능성이 약 50% 낮았다고 하네요.\n이거 진짜 대단한 발전 아닌가요? 개발자들이 코드를 작성하고, 디버깅하는 데 훨씬 더 도움이 될 것 같아요. 제가 개발자는 아니지만, 이런 발전이 미래의 소프트웨어 개발에 어떤 영향을 미칠지 정말 궁금해요.\n \n지시 이행 능력도 확실히 좋아졌어요  \nGPT-4.1은 지시 이행 능력도 크게 향상되었어요. 특히 Format following, Negative instructions, Ordered instructions, Content requirements, Ranking, Overconfidence 등 여러 범주에서 성능이 향상되었다고 해요.\n벤치마크\nGPT-4.1\nGPT-4o\n향상도\n\n\n\n\nMultiChallenge\n38.3%\n27.8%\n+10.5%\n\n\nIFEval\n87.4%\n81.0%\n+6.4%\n\n\n내부 API 지시 이행 (어려운 유형)\n49.1%\n29.2%\n+19.9%\n\n\n\n실제로 세금 관련 회사인 Blue J에서는 GPT-4.1이 내부 벤치마크에서 GPT-4o보다 53% 더 정확했다고 해요. Hex라는 회사에서는 SQL 평가 세트에서 거의 2배 향상된 성능을 보였다고 하네요.\n \n이런 개선은 복잡한 지시사항을 더 잘 따를 수 있게 해준다는 뜻이니까, 실무에서 활용도가 훨씬 높아질 것 같아요. 솔직히 말해서, 이전 모델들도 간단한 지시는 잘 따랐지만 복잡한 지시나 여러 단계의 지시는 종종 헷갈려 했잖아요? 이제 그런 문제가 많이 해결될 것 같네요.\n \n100만 토큰의 긴 컨텍스트, 어떻게 활용할까?  \nGPT-4.1 시리즈의 가장 큰 변화 중 하나는 100만 토큰의 컨텍스트 윈도우예요. 이건 React 코드베이스 전체를 8개 넣을 수 있는 양이라고 하네요. 진짜 엄청난 양이죠?\n \nOpenAI는 GPT-4.1이 이 긴 컨텍스트에서 정보를 효과적으로 찾고 활용할 수 있도록 특별히 훈련시켰다고 해요. 'Needle in a Haystack' 테스트에서 GPT-4.1은 100만 토큰 안에 숨겨진 정보를 정확하게 찾아낼 수 있었다고 해요.\n \n또 흥미로운 점은 OpenAI가 새로운 평가 방식인 OpenAI-MRCR과 Graphwalks를 공개했다는 거예요. 이 평가들은 모델이 긴 컨텍스트에서 여러 정보를 어떻게 찾고 연결하는지 테스트하는 방식이라고 해요.\n모델\n컨텍스트 윈도우\nOpenAI-MRCR (2 바늘) 128k\nGraphwalks bfs <128k\n\n\n\n\nGPT-4.1\n100만 토큰\n57.2%\n61.7%\n\n\nGPT-4.1 mini\n100만 토큰\n47.2%\n61.7%\n\n\nGPT-4.1 nano\n100만 토큰\n36.6%\n25.0%\n\n\nGPT-4o\n128k 토큰\n31.9%\n41.7%\n\n\n\n실제 사용 사례도 인상적이었어요. Thomson Reuters는 GPT-4.1을 사용해 다중 문서 검토 정확도를 17% 향상시켰고, Carlyle은 매우 큰 문서에서 세부적인 재무 데이터를 추출하는 성능이 50% 향상되었다고 해요.\n \n솔직히 말해서, 이런 긴 컨텍스트 기능은 법률, 금융, 의료 등 복잡한 문서를 다루는 분야에서 정말 혁신적인 변화를 가져올 것 같아요. 생각해보세요, 수백 페이지의 계약서나 의료 기록을 한 번에 분석할 수 있다면 얼마나 편리할까요?\n 컨텍스트는 AI 모델이 대화나 질문을 이해하기 위해 고려하는 배경 정보나 이전 대화 내용을 의미해요. 쉽게 설명하자면, 사람과 대화할 때 이전에 나눈 모든 대화를 기억하고 참고하는 것과 비슷해요.\n \n비전(Vision) 능력도 강화됐어요  ️\nGPT-4.1 시리즈는 이미지 이해 능력도 크게 향상되었어요. 특히 GPT-4.1 mini는 이미지 벤치마크에서 종종 GPT-4o보다 더 좋은 성능을 보여줬다고 해요.\n벤치마크\nGPT-4.1\nGPT-4.1 mini\nGPT-4o\n\n\n\n\nMMMU\n74.8%\n72.7%\n68.7%\n\n\nMathVista\n72.2%\n73.1%\n61.4%\n\n\nCharXiv-R\n56.7%\n56.8%\n52.7%\n\n\nVideo-MME (자막 없음)\n72.0%\n-\n65.3%\n\n\n\nMMMU에서 GPT-4.1은 74.8%, GPT-4.1 mini는 72.7%의 점수를 받았어요. 이는 GPT-4o의 68.7%보다 훨씬 높은 점수죠. MathVista에서도 GPT-4.1은 72.2%, GPT-4.1 mini는 73.1%로 GPT-4o의 61.4%를 크게 앞섰어요.\n \nVideo-MME 테스트에서는 GPT-4.1이 72.0%의 점수를 얻어 GPT-4o의 65.3%보다 훨씬 좋은 성적을 거뒀어요. 이 테스트는 30-60분 길이의 자막 없는 비디오를 기반으로 질문에 답하는 테스트인데, 정말 인상적인 성능이죠?\n \n아직 사진이나 비디오를 많이 활용하진 않지만, 앞으로는 이런 비전 능력을 활용한 애플리케이션이 더 많아질 것 같아요. 제 생각엔 교육이나 의료 분야에서 특히 유용할 것 같네요.\n \n가격은 어떻게 변했을까?  \n가격도 상당히 흥미로웠어요. OpenAI는 추론 시스템의 효율성 향상으로 GPT-4.1 시리즈의 가격을 낮출 수 있었다고 해요.\n모델\n입력 (100만 토큰)\n캐시된 입력 (100만 토큰)\n출력 (100만 토큰)\n혼합 가격*\n\n\n\n\nGPT-4.1\n$2.00\n$0.50\n$8.00\n$1.84\n\n\nGPT-4.1 mini\n$0.40\n$0.10\n$1.60\n$0.42\n\n\nGPT-4.1 nano\n$0.10\n$0.025\n$0.40\n$0.12\n\n\n\n*일반적인 입력/출력 및 캐시 비율 기준\n \nGPT-4.1은 중간 규모 쿼리의 경우 GPT-4o보다 26% 저렴하고, GPT-4.1 nano는 가장 저렴하고 빠른 모델이라고 해요.\n또 하나 좋은 점은 캐시된 입력에 대한 할인이 이전의 50%에서 75%로 증가했다는 거예요. 같은 컨텍스트를 반복해서 전달하는 경우에 더 많은 비용을 절약할 수 있게 된 거죠.\n \n확실히 더 저렴해진 가격은 중소기업이나 개인 개발자들에게 큰 도움이 될 것 같아요. 특히 GPT-4.1 nano는 정말 매력적인 가격대라고 생각해요.\n \n내가 받은 느낌은?  \n이번 GPT-4.1 시리즈 발표를 보면서 정말 많은 생각이 들었어요. AI 기술이 이렇게 빠르게 발전하는 걸 보니 약간 두렵기도 하지만, 동시에 정말 기대되기도 해요.\n \n특히 코딩 능력의 향상은 소프트웨어 개발 방식을 완전히 바꿀 수 있을 것 같아요. 개발자들이 복잡한 코드를 더 쉽게 작성하고 수정할 수 있게 되면, 더 빠르게 혁신적인 제품들이 나올 수 있겠죠.\n \n긴 컨텍스트 기능도 정말 흥미로워요. 법률 문서, 의학 연구, 학술 논문 등 긴 문서를 분석하는 데 엄청난 도움이 될 것 같아요. 이전에는 불가능했던 방식으로 정보를 처리하고 통찰력을 얻을 수 있게 될 거예요.\n지시 이행 능력의 향상은 AI가 더 신뢰할 수 있는 도구가 되었다는 걸 의미해요. 사용자가 원하는 정확한 결과를 더 쉽게 얻을 수 있게 되었으니까요.\n \n하지만 여전히 몇 가지 질문도 남아있어요. 이런 강력한 AI 도구들이 사회에 어떤 영향을 미칠까요? 직업 시장은 어떻게 변할까요? 우리는 어떻게 이 기술을 책임감 있게 사용할 수 있을까요?\n \nGPT-4.1 시리즈, 누구를 위한 모델일까?  \nGPT-4.1 시리즈는 다양한 사용자와 사용 사례를 위해 설계되었어요.\n모델\n주요 사용자층\n주요 특징\n비용 효율성\n\n\n\n\nGPT-4.1\n최고 성능을 원하는 사용자\n코딩 능력, 정확한 지시 이행, 긴 문서 분석\n중간\n\n\nGPT-4.1 mini\n균형 잡힌 성능과 비용을 원하는 사용자\nGPT-4o보다 더 좋은 성능, 지연 시간 절반\n높음\n\n\nGPT-4.1 nano\n짧은 대기 시간이 중요한 작업\n분류, 자동 완성, 100만 토큰 컨텍스트\n매우 높음\n\n\n\nGPT-4.1은 최고의 성능을 원하는 사용자를 위한 모델이에요. 복잡한 코딩 작업, 정확한 지시 이행이 필요한 작업, 긴 문서 분석 등에 적합해요.\n \nGPT-4.1 mini는 균형 잡힌 성능과 비용을 원하는 사용자에게 적합해요. GPT-4o보다 여러 벤치마크에서 더 좋은 성능을 보이면서도 지연 시간은 절반으로 줄고 비용은 83% 감소했다고 하니 정말 매력적이죠.\n \nGPT-4.1 nano는 짧은 대기 시간이 중요한 작업에 적합해요. 분류나 자동 완성과 같은 작업에 이상적이라고 해요. 100만 토큰의 컨텍스트 윈도우를 가지고 있으면서도 MMLU에서 80.1%, GPQA에서 50.3%의 높은 점수를 받았대요.\n저는 개인적으로 GPT-4.1 mini가 가성비 면에서 가장 좋은 선택일 것 같다는 생각이 들어요. 대부분의 일반적인 작업에 충분한 성능을 제공하면서도 비용은 상당히 저렴하니까요.\n \n\n\n\n자주 묻는 질문 (FAQ) ❓\nQ: GPT-4.1은 ChatGPT에서도 사용할 수 있나요?\nA: 아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.\nQ: GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?\nA: GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.\nQ: GPT-4.1 시리즈의 가격은 어떻게 되나요?\nA: GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.\nQ: GPT-4.5 Preview는 어떻게 되나요?\nA: GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.\nQ: GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?\nA: 2024년 6월까지의 정보를 담고 있습니다.\n \n \n \n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1은 ChatGPT에서도 사용할 수 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"아니요, GPT-4.1은 API를 통해서만 제공됩니다. ChatGPT에서는 지시 이행, 코딩, 지능 향상 등의 개선 사항이 GPT-4o의 최신 버전에 점진적으로 통합되고 있습니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1의 컨텍스트 윈도우는 얼마나 큰가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1, GPT-4.1 mini, GPT-4.1 nano 모두 100만 토큰의 컨텍스트 윈도우를 지원합니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 가격은 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.1은 입력 100만 토큰당 $2, GPT-4.1 mini는 $0.40, GPT-4.1 nano는 $0.10입니다. 출력 토큰은 각각 $8, $1.60, $0.40입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.5 Preview는 어떻게 되나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"GPT-4.5 Preview는 3개월 후인 2025년 7월 14일에 API에서 중단될 예정입니다. GPT-4.1이 더 낮은 비용과 지연 시간으로 더 좋거나 유사한 성능을 제공하기 때문입니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"GPT-4.1 시리즈의 지식 기반은 언제까지의 정보를 포함하고 있나요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"2024년 6월까지의 정보를 담고 있습니다.\"\n    }\n  }]\n}",
    "reviews": [],
    "syllabus": [],
    "link": "http://muzbox.tistory.com/483569",
    "pubDate": "Wed, 16 Apr 2025 10:06:48 +0900",
    "creator": "어떤오후의 프리웨어 이야기",
    "categories": [
      "AI, 미래기술/AI 챗봇 및 언어 모델",
      "AI 개발",
      "gpt-4.1",
      "gpt-4.1 mini",
      "gpt-4.1 nano",
      "OpenAI",
      "긴 컨텍스트",
      "인공지능",
      "지시 이행",
      "컨텍스트 윈도우",
      "코딩 능력"
    ]
  },
  {
    "id": 8,
    "imageUrl": "",
    "title": "TeamCity 2025.03.1 Bug Fix Is Now Available!",
    "description": "The first bug-fix update for version 2025.03, TeamCity On-Premises 2025.03.1, is out and ready to be installed on your servers! This update ships around 30 bug fixes, performance enhancements, and security patches. We highly recommend upgrading to keep your system secure and optimized. The list of resolved issues includes: See TeamCity 2025.03.1 Upgrade Notes for […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/teamcity/2025/04/teamcity-2025-03-1-bug-fix/",
    "pubDate": "Wed, 16 Apr 2025 14:00:08 +0000",
    "creator": "Dmitrii Korovin",
    "categories": [
      "bug-fix"
    ]
  },
  {
    "id": 9,
    "imageUrl": "",
    "title": "ChatGPT의 GPT-4o 이미지 생성, DALL-E를 어떻게 뛰어넘었나?",
    "description": "ChatGPT의 GPT-4o 이미지 생성 기능의 혁신적인 변화! DALL-E와는 무엇이 다른지, 실제 사용해보니 드러난 장단점과 창작계에 미칠 파장까지. AI 이미지 생성의 새 시대가 열렸다고? 디자이너라면 꼭 알아야 할 모든 것.\n\n\n \n요즘 들어 SNS를 보면 지브리풍 일러스트부터 놀라울 정도로 사실적인 사진까지, 모두 ChatGPT로 만들었다는 이미지들이 넘쳐나고 있어요. \"뭐야, ChatGPT도 이제 이미지를 만들어?\" 라고 생각하시는 분들 많으실 텐데요. 네, 맞습니다. 2025년 3월 26일, OpenAI가 GPT-4o를 출시하면서 DALL-E를 대체하는 이미지 생성 기능을 통합했거든요.\n \n저는 디자인 분야에서 일하다 보니 미드저니, 스테이블 디퓨전부터 DALL-E까지 거의 모든 AI 이미지 생성 도구를 업무에 활용해왔는데요. GPT-4o의 이미지 생성 기능을 처음 접했을 때는 정말 놀랐어요. 왜 그랬는지, 그리고 이 변화가 우리에게 어떤 의미인지 함께 알아볼까요?\n \nDALL-E에서 GPT-4o로, 무엇이 바뀌었나?  \n이전까지 ChatGPT에서 이미지를 생성하려면 별도의 DALL-E 모델을 호출해야 했어요. 대화하다가 \"이 설명을 이미지로 만들어줘\"라고 하면 모드 전환이 일어나면서 DALL-E가 작동했죠. 하지만 이제는 GPT-4o 하나로 대화와 이미지 생성이 모두 가능해졌어요.\n주요 변화점  \n통합된 사용자 경험 - 대화 흐름 중에 자연스럽게 이미지 생성이 가능해졌어요. 모드 전환 없이 대화하듯 이미지를 요청하면 바로 만들어줍니다.\n향상된 응답 속도 - DALL-E는 이미지 생성에 10-20초가 걸렸는데, GPT-4o는 대략 절반 정도로 시간이 단축됐어요.\n텍스트 렌더링 성능 향상 - 이전 DALL-E의 큰 약점 중 하나가 이미지 속 텍스트 처리였는데, GPT-4o는 이 부분이 획기적으로 개선되었어요. 포스터나 책 표지 같은 텍스트가 포함된 이미지 생성이 훨씬 정확해졌답니다.\n스타일 일관성 - 다양한 예술 스타일을 요청했을 때 일관된 퀄리티를 유지하는 능력이 향상되었어요. 특히 '지브리풍'으로 유명해진 애니메이션 스타일 구현이 뛰어나죠.\n솔직히 말하자면, 순수하게 사진 같은 사실적 이미지만 놓고 보면 기존 DALL-E가 약간 더 나은 경우도 있었어요. 하지만 전반적인 성능과 사용성은 GPT-4o가 훨씬 뛰어납니다.\n \n실제 사용해보니 느낀 GPT-4o 이미지 생성의 강점  \n실제로 제가 업무에 활용해보니 GPT-4o의 강점이 확실히 드러나더라고요.\n1. 맥락 이해 능력\n제가 가장 놀란 부분은 대화 맥락을 기반으로 이미지를 생성한다는 점이에요. 예를 들어, 로고 디자인에 대해 길게 대화를 나눈 후 \"이걸 이미지로 만들어줘\"라고 하면 이전 대화 내용을 모두 고려한 이미지를 만들어줍니다. DALL-E는 그냥 그 한 문장만 고려했죠.\n2. 디테일 컨트롤\n\"조금 더 밝게\", \"왼쪽 캐릭터의 표정을 더 행복하게\" 같은 세부 수정 요청에 훨씬 더 정확하게 반응해요. 이전에는 비슷한 프롬프트로 처음부터 다시 생성하는 경우가 많았는데, GPT-4o는 원하는 부분만 정확히 수정해주는 경우가 많아요.\n3. 텍스트와 이미지의 완벽한 조화\n포스터나 인포그래픽처럼 텍스트가 포함된 이미지를 만들 때 정말 빛을 발해요. DALL-E에서는 \"Happy Birthday\"라는 간단한 문구조차 \"Ha9py Birtиday\" 같은 이상한 글자로 나오는 경우가 많았는데, GPT-4o는 거의 완벽하게 텍스트를 렌더링합니다.\n \n아직 아쉬운 점들  \n물론 완벽하진 않아요. 제가 실제 사용하면서 느낀 한계점도 있습니다:\n복잡한 구도의 한계 - 여러 사람이 특정 동작을 취하고 있는 복잡한 장면을 요청하면 여전히 손이나 발이 이상하게 나오는 경우가 있어요.\n해상도 제한 - 현재 생성되는 이미지의 해상도가 제한적이라 고품질 인쇄물용으로 사용하기엔 부족해요.\n스타일 제한 - 특정 작가나 브랜드의 스타일을 정확하게 모방하는 데는 여전히 한계가 있습니다.\n \n이 변화가 창작 산업에 미칠 영향  \nGPT-4o의 이미지 생성 기능은 단순한 기술적 발전을 넘어 창작 방식 자체를 바꿀 잠재력이 있어요. 이제 누구나 쉽게 자신의 아이디어를 시각화할 수 있게 되었으니까요.\n디자이너와 일러스트레이터에게는?\n솔직히 말해서, 불안함을 느끼는 디자이너분들 많으실 거예요. 하지만 저는 이걸 위협보다는 도구로 봐야 한다고 생각해요. 디자인 초안을 빠르게 만들거나, 클라이언트와 소통하는 과정에서 아이디어를 시각화하는 데 정말 유용하거든요.\n실제로 저는 로고 디자인 작업할 때 클라이언트에게 다양한 방향성을 빠르게 제시하기 위해 GPT-4o를 활용하고 있어요. 물론 최종 결과물은 직접 다듬지만, 아이디어 발상 과정이 훨씬 효율적으로 바뀌었답니다.\n마케팅과 콘텐츠 제작에는?\nSNS 마케팅이나 블로그 콘텐츠 제작자들에게는 정말 혁명적인 변화에요. 이제 디자이너 없이도 괜찮은 퀄리티의 이미지를 즉석에서 만들 수 있으니까요. 특히 텍스트 렌더링이 개선되어 광고나 프로모션 이미지 제작이 훨씬 쉬워졌어요.\n \nGPT-4o 이미지 생성, 어떻게 활용해야 할까?  \n제가 실제로 GPT-4o 이미지 생성을 활용하면서 터득한 팁을 몇 가지 공유할게요:\n맥락이 풍부한 프롬프트 작성하기 - 단순히 \"고양이 그림\"보다는 \"푸른 하늘 아래 햇살을 받으며 창가에 앉아있는 티베트산 하얀 고양이, 스튜디오 조명, 소니 A7 카메라로 촬영한 느낌\"처럼 구체적으로 설명하세요.\n대화 맥락 활용하기 - 이미지를 생성하기 전에 원하는 스타일이나 분위기에 대해 충분히 설명하면 더 좋은 결과물을 얻을 수 있어요.\n반복 생성으로 완성도 높이기 - 첫 결과물에 만족하지 못했다면 \"이 이미지에서 배경을 더 밝게, 인물의 표정을 더 행복하게 수정해줘\"처럼 구체적인 피드백을 주세요.\n텍스트 활용하기 - GPT-4o는 텍스트 렌더링이 강점이니 포스터, 책 표지, 로고 등 텍스트가 포함된 이미지 생성에 적극 활용해보세요.\n\n\n결론: 창작의 민주화가 시작됐다  \nGPT-4o의 이미지 생성 기능은 DALL-E를 단순히 대체한 것이 아니라, AI 이미지 생성의 패러다임 자체를 바꾸고 있어요. 기술적으로는 더 정교해졌고, 사용자 경험 측면에서는 훨씬 더 접근성이 높아졌죠.\n물론 전문 디자이너나 사진작가의 창의적 작업을 완전히 대체하진 못하겠지만, 창작의 문턱을 크게 낮췄다는 점은 분명해요. 이제 \"난 그림을 못 그려\"라는 말은 더 이상 변명이 되지 않을지도 모르겠네요.\n여러분도 GPT-4o의 이미지 생성 기능을 사용해보셨나요? 어떤 경험을 하셨는지, 또 어떻게 활용하고 계신지 댓글로 공유해주세요!  \n자주 묻는 질문  \nQ: GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?\nA: OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.\nQ: GPT-4o 이미지 생성은 무료인가요?\nA: ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.\nQ: DALL-E는 이제 완전히 사라진 건가요?\nA: 네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.\nQ: 생성된 이미지를 편집할 수 있나요?\nA: 현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.\nQ: 생성된 이미지의 해상도는 어떻게 되나요?\nA: 현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.\n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o로 생성한 이미지의 저작권은 누구에게 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"OpenAI의 정책에 따르면 생성된 이미지의 저작권은 사용자에게 있습니다. 상업적 용도로도 사용 가능해요.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"GPT-4o 이미지 생성은 무료인가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"ChatGPT Plus나 Team, Enterprise 구독자에게 제공되며, 무료 사용자는 제한된 수의 이미지만 생성할 수 있습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"DALL-E는 이제 완전히 사라진 건가요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"네, 2025년 3월 26일부터 DALL-E는 GPT-4o의 이미지 생성 기능으로 자연스럽게 대체되었습니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지를 편집할 수 있나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 GPT-4o 자체에서는 생성된 이미지를 직접 편집할 수는 없고, 프롬프트를 통한 재생성만 가능합니다.\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"생성된 이미지의 해상도는 어떻게 되나요?\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"현재 기본 해상도는 약 1024x1024 픽셀 수준입니다.\"\n      }\n    }\n  ]\n}",
    "reviews": [],
    "syllabus": [],
    "link": "http://muzbox.tistory.com/483568",
    "pubDate": "Tue, 15 Apr 2025 08:42:07 +0900",
    "creator": "어떤오후의 프리웨어 이야기",
    "categories": [
      "AI, 미래기술/AI 이미지 및 아트 생성",
      "AI 이미지",
      "ai 창작 도구",
      "ai 프롬프트 작성법",
      "chatgpt 그림 기능",
      "dall-e 대체",
      "gpt-4o 이미지 생성",
      "디자인 자동화",
      "이미지 생성 프롬프트",
      "지브리풍 ai",
      "텍스트 렌더링"
    ]
  },
  {
    "id": 10,
    "imageUrl": "",
    "title": "Google Gemini 2.5 Pro arrives in JetBrains AI Assistant",
    "description": "JetBrains AI Assistant now supports Google’s latest and most intelligent AI model, Gemini 2.5 Pro. This integration makes your JetBrains IDE even smarter, providing enhanced accuracy and deep reasoning capabilities to streamline your coding experience. At JetBrains, we aim to equip developers with AI tools that simplify complex tasks and make everyday coding more productive […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/ai/2025/04/google-gemini-2-5-pro-arrives-in-jetbrains-ai-assistant/",
    "pubDate": "Thu, 17 Apr 2025 12:53:15 +0000",
    "creator": "Oksana Mandryka",
    "categories": [
      "news",
      "ai-assistant"
    ]
  },
  {
    "id": 11,
    "imageUrl": "",
    "title": "Big News! JetBrains Qodana’s Code Quality Plugin Is Now Available for Visual Studio",
    "description": "It’s no secret that Qodana is a team tool that JetBrains designed to integrate seamlessly with its suite of IDEs, but every team and tech stack is different. One common question remains: “What about other members of our team who still use VS Code or Visual Studio?” To help with this problem, we decided to […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/qodana/2025/04/visual-studio-plugin/",
    "pubDate": "Wed, 16 Apr 2025 15:24:15 +0000",
    "creator": "Kerry Beetge",
    "categories": [
      "plugin-highlights",
      "plugins",
      "qodana",
      "release",
      "visual-studio"
    ]
  },
  {
    "id": 12,
    "imageUrl": "",
    "title": "Visual Studio의 새로운 디버깅 및 프로파일링 기능(v17.13)",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://jacking75.github.io/VS_20250420/",
    "pubDate": "Sun, 20 Apr 2025 00:00:00 +0900",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 13,
    "imageUrl": "",
    "title": "nhn 에서 제공하는 유니티 도움 패키지",
    "description": "게임 만들라고 만든거 같군요 Game 이라고 적혀있네요\n편리하게 쓰라고 좋은기능 많이 만들어둔거 같습니다.\n셰이더도 있구요\n \n영상: https://www.youtube.com/watch?v=qstN7DcLTBk\n\n\n\n \n소스: https://github.com/nhn/gpm.unity\n\n \nGitHub - nhn/gpm.unity: A brand of NHN providing free services required for game development.\nA brand of NHN providing free services required for game development. - nhn/gpm.unity\ngithub.com\n\n \n사이즈 같은거 자동으로 ㄱ산해줘서 좋아요",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1275",
    "pubDate": "Fri, 18 Apr 2025 20:07:08 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/유니티 에셋 리뷰",
      "유니티"
    ]
  },
  {
    "id": 14,
    "imageUrl": "",
    "title": "Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer",
    "description": "Visual Studio 17.14 Preview 3 introduces a new feature that enhances the Windows Forms out-of-process designer experience for .NET Framework projects. This release brings Toolbox support for Explicit Assembly References, addressing a long-standing need in legacy application development and migration workflows. What Are Explicit Assembly References? Explicit Assembly References are stand-alone assemblies directly referenced in […]\nThe post Toolbox Support for Explicit Assembly References in Windows Forms Out-of-Process Designer appeared first on Visual Studio Blog.",
    "reviews": [],
    "syllabus": [],
    "link": "https://devblogs.microsoft.com/visualstudio/toolbox-support-for-explicit-assembly-references-in-windows-forms-out-of-process-designer/",
    "pubDate": "Thu, 17 Apr 2025 14:45:27 +0000",
    "creator": "Merrie McGaw, Shyam Gupta",
    "categories": [
      "Visual Studio",
      "Windows Forms",
      "Assembly References",
      "designer",
      "out-of-process",
      "Toolbox",
      "WinForms"
    ]
  },
  {
    "id": 15,
    "imageUrl": "",
    "title": "단지 권한 기능을 추가해달라고 했을 뿐인데(feat. 인증 기능 개선)",
    "description": "안녕하세요. 스포카 백엔드팀 프로그래머 남경호입니다.\n개발자라면 누구나 오랫동안 미뤄두었던 과제가 하나쯤 있을 것입니다. 업무의 우선순위가 낮거나 긴급한 과제들에 밀려 지속적으로 백로그에 쌓여 있던 작업 말이죠. 최근 저희팀에서 왜 오랜 시간 미뤄두었던 인증 방식 개선 작업을 진행하게 되었는지, 그 과정에서 얻은 여러 경험을 여러분께 공유하고자 합니다.\n배경\n스포카 블로그를 꾸준히 보신 분이라면, 서버 언어 전환 이야기 글에서 JWT 관련 문제를 언급하며 향후 개선할 예정이라고 소개했던 내용을 기억하실 겁니다.\n\n약 3년이 흐른 지금, 드디어 저희가 인증 방식 개선을 진행하게 된 가장 큰 이유는 바로 키친보드 매장 앱에 권한관리 기능이 추가되었기 때문입니다.\n\n키친보드 매장 앱은 식자재 주문부터 거래대금 결제까지 다양한 기능을 제공합니다. 이 과정에서 사장님은 직원이 매장의 월 거래 내역 등 민감한 정보를 조회하지 못하도록 권한을 제어할 필요가 생겼는데요. 기존 JWT 인증은 무 상태(stateless) 특성상 권한 변경 시 즉각적으로 클라이언트의 인증 상태를 관리할 수 없다는 한계가 있었습니다.\n그래서 저희는 권한 기능을 추가하기에 앞서 인증 방식을 먼저 개선하기로 하였습니다.\n인증 방식 개선 방법\nRefresh Token 도입\n앞서 이야기했듯이, JWT 기반의 인증 방식은 서버가 사용자의 상태를 저장하지 않습니다. 덕분에 서버의 확장성이 높고 서버 부하를 줄일 수 있다는 장점이 있지만, 한번 발급된 토큰을 서버에서 직접 제어할 수 없다는 단점이 있습니다.\n이러한 특성은 보안 문제로 연결될 수 있는데요. 만약 인증을 통해 발급받은 토큰이 탈취된다면, 서버가 이 토큰을 제어할 수 없으므로 악의적인 사용자는 손쉽게 탈취된 토큰을 이용하여 정상 사용자처럼 서비스를 이용할 수 있게 됩니다. 보통 이러한 보안 위험을 방지하기 위해 Access Token의 만료 시간을 짧게 설정하지만, 이 경우 사용자가 자주 로그인해야 하는 번거로움이 발생하게 됩니다.\n이와 같은 문제를 해결할 수 있는 대표적인 방법의 하나가 바로 Refresh Token 의 도입입니다. Refresh Token은 Access Token과 달리 서버가 상태를 관리하는 토큰으로, Access Token을 갱신하는 데 사용됩니다. 앞서 말씀드린 대로, Access Token의 탈취 위험을 낮추기 위해 Access Token의 만료 시간을 짧게 설정하는 것이 좋은데요. 이때 Refresh Token을 활용하면 사용자가 Access Token의 만료 시점마다 다시 로그인하지 않아도 편리하게 새로운 Access Token을 발급받을 수 있습니다.\n다음 그림에서 Access Token과 Refresh Token의 인증 과정을 자세히 확인할 수 있습니다.\n\n사용자가 로그인을 요청하면 서버는 Access Token과 Refresh Token을 발급합니다.\n사용자는 발급받은 유효한 Access Token을 이용해 API를 호출하고, 서버는 요청된 데이터를 정상적으로 응답합니다.\n사용자가 만료된 Access Token을 가지고 API 요청을 하면 서버는 401 인증 에러를 반환합니다. 이때 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받고, 갱신된 Access Token으로 API를 재요청하여 정상적으로 데이터를 받을 수 있습니다.\n하지만 만약 사용자의 Refresh Token까지 만료된 상태라면, 서버는 최종적으로 401 인증 에러를 반환하여 사용자의 다시 로그인을 요구합니다.\n위 과정을 통해 일반적으로 Access Token의 만료 시간을 짧게 설정하여 Access Token의 탈취 위험을 최소화하고, Refresh Token을 통해 사용자 편의성 또한 유지할 수 있습니다.\n아래 그림을 통해 Access Token의 탈취로 인한 공격 시나리오로 Access Token의 만료시간이 짧으면 짧을수록 보안 위험도가 감소하게 됩니다.\n\n이처럼 Refresh Token을 적절히 도입하고 관리하면 토큰 탈취로 인한 보안 위험을 효과적으로 감소시킬 뿐만 아니라 사용자가 매번 로그인해야 하는 문제도 해결할 수 있으므로 사용성도 함께 챙길 수 있게 됩니다.\nRefresh Token Rotation\n한편, Access Token에 대한 탈취 위험은 Refresh Token도 동일한 것 아닌가? 라는 질문을 할 수 있을 것 같습니다. 맞습니다. Refresh Token이 탈취당하면 Access Token을 갱신할 수 있고 갱신된 Access Token을 통해 악의적 사용자는 손쉽게 탈취한 사용자인 척 서비스를 이용할 수 있게 됩니다.\n이러한 문제를 해결하기 위해 우리는 Refresh Token Rotation 을 도입하기로 합니다. Refresh Token Rotation은 아래와 같이 Refresh Token을 이용해 Access Token을 갱신할 때 Refresh Token도 함께 갱신하여 Refresh Token 탈취 시 발생할 수 있는 위험을 회피합니다.\n\n이슈\n클라이언트의 네트워크 이슈\n앞서 저희는 Refresh Token Rotation을 이용하여 Refresh Token 탈취에 대한 위험성을 회피하고자 하였습니다. 이렇게 하면 Refresh Token을 이용하여 Access Token을 갱신 요청할 때 요청한 Refresh Token도 새롭게 발급되어 더 이상 Refresh Token을 사용할 수 없게 되는데요. 보안 수준은 강화되었지만, 클라이언트 개발자분들이 한가지 우려 점을 제기해 주셨습니다.\n모바일 기기 특성상 지하실이나 엘리베이터안과같이 네트워크가 원활하지 않은 곳에서 사용할 가능성이 존재하는데요. 이때 아래 그림과 같이 첫 번째 요청한 Refresh Token을 재요청하는 경우가 발생할 수 있습니다. 하지만 Refresh Token을 매번 갱신하기 때문에 동일한 Refresh Token으로 여러번 Access Token을 갱신요청하게 된다면 두번째 요청부터는  인증 에러가 발생하게 됩니다.\n\n그래서 저희는 Token Family 방식 을 사용하여 요청 시마다 기존 Refresh Token을 지우지 않고 과거 토큰을 저장해 두었다가 첫 번째 요청으로 새롭게 발급된 토큰 또는 모종의 이유로 인해 갱신하지 못한 기존 토큰으로 토큰 갱신 요청을 할 수 있도록 구현하여 Refresh Token을 재사용할 수 있도록 하였습니다.\n\n이로써 클라이언트는 네트워크 이슈가 발생해도 Refresh Token을 갱신할 수 있게 되었습니다.\n\n인증 토큰의 하위 호환\n한편, 저희는 JWT를 다루는 라이브러리로 JJWT 를 사용하고 있습니다. 앞서 JWT는 상태를 가지지 않기 때문에 사용자가 사용하는 Access Token을 서버에서 제어할 수 없다고 말씀드렸었는데요. 그래서 Access Token의 만료 시간을 두어 새롭게 Access Token을 발급받도록 하여 우회적으로 제어할 수 있습니다. Access Token을 만료시키는 또 다른 방법은, 해당 토큰을 생성할 때 사용된 암호키를 변경하는 것입니다. 저희는 그래서 클라이언트에서 사용하는 Access Token을 만료시키고 새롭게 변경된 권한을 사용하는 Access Token으로 사용하도록 하기 위해 암호키를 바꾸기로 하였습니다. 다만 여기서 발생하는 문제가 바로 앱의 업데이트 타이밍이었습니다.\n개발자라면 다들 잘 아시겠지만, 서버와 앱은 동일한 시점에 개발이 완료되더라도 배포되는 시점이 다를 수 있습니다. 서버는 배포하는 즉시 배포가 되지만 앱은 심사 과정이 필요하고 배포가 되더라도 앱스토어에 배포된 버전이 전파되기까지 1일 이상 소요될 수 있습니다. 그러다 보니 Access Token을 변경하기 위해 키를 변경하게 되면 서버가 배포된 이후부터 앱이 업데이트되기 전까지 사용자가 서비스를 이용할 수 없다는 문제가 생길 수 있습니다. 그래서 저희는 과거 버전의 앱에서도 새롭게 배포된 서버의 인증을 문제없이 사용할 수 있도록 방법을 모색해야 했습니다.\nJJWT 버전 변경\n한편, 저희는 비밀키를 바꾸는 김에, 과거에 사용하던 서명 알고리즘(HS256)에 비해 보안성이 강화된 서명 알고리즘(PS256)을 변경하기로 합니다. 그러다 보니 JJWT라이브러리 버전을 업그레이드해야 했는데요. Gradle에 아래처럼 동일한 라이브러리를 서로 다른 버전으로 사용하는 경우 패키지 충돌이 발생하여 신규 버전에서 제공하는 함수를 사용할 수 없게 됩니다.\n\n// 구버전\nimplementation(\"io.jsonwebtoken:jjwt:0.9.1\")\n\n// 신규버전\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\n\n이러한 문제를 해결하기 위해 저희는 Jitpack 을 사용하기로 합니다. JitPack은 GitHub에 호스팅된 라이브러리를 쉽게 빌드하고 배포할 수 있게 해주는 Maven/Gradle 용 리포지터리 서비스입니다. GitHub 저장소를 바탕으로 라이브러리를 빌드하므로, 별도의 중앙 저장소(예: Maven Central) 등록 과정을 거치지 않아도 된다는 장점이 있습니다. 그리고 오픈소스 저장소에, 한에 무료로 사용할 수 있다는 점도 장점입니다.\n저희는 JJWT 라이브러리를 fork하여 Spoqa용 JJWT Github 저장소 를 생성하였습니다. 그런 다음 충돌 패키지 충돌이 발생하지 않도록 패키지명을 변경해 주었습니다.\n\n그런 다음 Release를 생성해 주면, 아래와 같이 Jitpack에서 조회할 수 있게 됩니다.\n\n마지막으로 아래와 같이 Gradle에 의존성을 추가해주면, 패키지명이 변경된 JJWT라이브러리를 사용할 수 있게 됩니다.\n\nimplementation(\"com.github.spoqa:jjwt:1.0.2\")\nimplementation(\"javax.xml.bind:jaxb-api:2.3.1\")\n\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\nComposite 패턴 vs TokenManager\n저희는 Jitpack으로 생성한 과거버전의 JJWT를 의존하는 구현체를 아래와 같이 LegacyJwtProcessor로 변경하고 신규 버전을 사용하는 JwtProcessor를 새롭게 생성하였습니다. 그런 다음 아래와 같이 인증 로직에 과거 버전의 Access Token과 신규 버전의 Access Token을 모두 수용할 수 있도록 구현하였습니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val jwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal =\n            try {\n                jwtProcessor.getPrincipal(authentication.principal.toString())\n            } catch (e: AuthenticationException) {\n                legacyJwtProcessor.getPrincipal(authentication.principal.toString())\n            }\n\n        return JwtUserAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == JwtPreAuthenticationToken::class.java\n    }\n}\n\n\n이렇게 구현하면 앱이 배포되기 전에 서버가 먼저 배포되어도 기존 버전을 사용하는 사용자가 정상적으로 로그인을 유지할 수 있게 됩니다.\n한편, 인증 로직을 구현하는 곳 말고도 LegacyJwtProcessor를 사용하는 곳이 다수 존재하였는데요. 그러다 보니 새롭게 만들어진 JwtProcessor로 전환하는 것을 누락할 가능성이 존재하였습니다. 다행히 기능 테스트가 있어 놓친 구현을 바로잡을 순 있었지만, 코드의 응집성 측면에서는 좋은 코드는 아니라 생각하였습니다.\n그래서 Composite 패턴을 사용해서 아래와 같이 구현해 볼지 생각을 하였습니다.\n\ninterface JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String\n    fun getPrincipal(token: String): UserPrincipal\n}\n\nclass CompositeJwtProcessor(\n    private val newJwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: JwtProcessor,\n): JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n}\n\nclass NewJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\nclass legacyJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\n\nCompositeJwtProcessor를 이용하면 아래와 같이 JwtAuthenticationProvider는 더 이상 legacyJwtProcessor를 알지 않아도 되고 추후 legacyJwtProcessor가 제거되어도 영향범위는 CompositeJwtProcessor로 한정되기 때문에 응집도 높은 코드를 유지할 수 있게 됩니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val compositeJwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = compositeJwtProcessor.getPrincipal(authentication.principal.toString())\n\n        return JwtUserAuthenticationToken(principal)\n    }\n    \n    // 생략...\n}\n\n\n다른 방법으로는 TokenManager라는 상위 수준의 클래스를 만들어 응집도를 높이는 방법도 생각해 보았습니다.\n\n@Service\nclass TokenManager(\n    private val jwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val refreshTokenService: RefreshTokenService,\n) {\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n\n    fun generateAccessToken(userPrincipal: UserPrincipal): String {\n        // 생략...\n    }\n\n    fun generateRefreshToken(entity: RefreshToken): String {\n        // 생략...\n    }\n\n    fun replaceRefreshToken(principal: RefreshTokenUserPrincipal): String {\n        // 생략...\n    }\n}\n\n\n이렇게 하면 Token을 Composite 패턴을 사용한 것과 같이 하위호환을 지키는 코드와 함께 토큰과 관련된 다른 기능들도 해당 클래스로 모을 수 있어 응집도를 상당히 높일 수 있게 됩니다.\n어떤 방식이 더 나은 방식이라고 말씀드리긴 어려울 것 같습니다. 다만, 저희는 LegacyJwtProcessor는 앱 배포 이후에 제거될 클래스이므로 불필요하게 Composite 패턴을 사용하기보다 TokenManager를 생성하여 코드 응집도를 높이는 방법으로 결정하게 되었습니다.\nSpring Security - PreAuthorize\n저희는 인증과 인가를 위해 Spring Security를 사용하고 있습니다. JWT를 통해 인증된 사용자는 UserPrincipal이라는 인증된 사용자로 변환되고 UserPrinciapl이 가진 authorities를 통해 권한 처리를 하고 있습니다.\n\n@Component\nclass AccessTokenAuthenticationProvider(\n    private val tokenManager: TokenManager,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = tokenManager.getPrincipal(authentication.principal.toString())\n        return AccessTokenAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == AccessTokenPreAuthenticationToken::class.java\n    }\n}\n\nclass AccessTokenAuthenticationToken(\n    private val principal: UserPrincipal,\n) : AbstractAuthenticationToken(principal.authorities) {\n    init {\n        super.setAuthenticated(true)\n    }\n\n    override fun getPrincipal() = principal\n\n    override fun getCredentials() = null\n}\n\n\n사용자는 아래와 같이 @Secured를 통해 권한을 검증받고 API를 호출할 수 있습니다.\n\n@DgsMutation\n@Secured(STORE_ADMIN, STORE_MANAGER, VENDOR)\nfun createOrderSheet(\n    @InputArgument input: CreateOrderSheetInput,\n): CreateOrderSheet {\n    // 생략...\n}\n\n\n@Secured는 단순한 권한 Role 기반 접근을 제어하기에 적절합니다. 이전까지 키친보드는 관리자, 매장 사용자, 유통사 사용자로 명확하게 Role이 나뉘어져 있었기 때문에 @Secured는 요구사항을 충분히 충족하면서 단순하게 구현할 방법이었습니다.\n하지만 새로운 요구사항이 추가되면서 매장 사용자는 매장 관리자, 매장 직원으로 권한이 분리되게 되었는데요. 이에 따라 매장 사용자 모두 접근을 할 수 있는 API에는 아래와 같이 @Secured(STORE_ADMIN, STORE_MANAGER) 표현해야 하는 불편함이 있게 됩니다. 거기다 만약 STORE_INTERN이 추가된다면 매장 사용자 권한을 가져야 하는 API를 모두 찾아서 바꿔줘야 하니 상당히 번거로운 작업이 될 것이고 자칫 권한 변경을 누락할 수 있는 위험성 또한 내포하고 있습니다.\n이와 같은 문제를 해소하기 위해 Spring Security에서는 @PreAuthorize를 이용하여 유연하게 권한을 체크하는 기능을 제공합니다. 그래서 저희는 아래와 같이 매장 사용자 여부를 확인하는 서비스 함수를 만들어 SpEL 을 이용해 권한을 체크하도록 함으로써 권한을 일일이 나열하지 않고 새로운 권한이 생기더라도 유연하게 대처할 수 있도록 하였습니다.\n\n@PostMapping(\"/replace-store\")\n@PreAuthorize(\"@authorizationExpressionHelper.isManager()\")\nfun replaceStore(@RequestBody request: ReplaceStoreRequest): ReplaceStoreResponse {\n    // 생략...\n}\n\n@Service\nclass AuthorizationExpressionHelper {\n    fun isManager(): Boolean {\n        return PrincipalProvider.userPrincipal.isManager\n    }\n}\n\n\n마무리\n지금까지 저희가 권한 기능을 추가하기 위해 인증 로직을 어떻게 개선하였고 개선하면서 겪었던 이슈들을 공유해 보았습니다. 단순히 권한을 추가해 달라는 요구사항에서 시작되었지만, 그동안 우리가 가지고 있던 기술 부채도 해결함과 동시에 기술적인 여러 고민을 할 수 있어서 개인적으로 배운 게 많은 프로젝트였습니다.\n모쪼록 인증 기능 구현에 관심이 있으시거나 예정인 분들께 도움이 되었으면 합니다.\n긴 글 읽어주셔서 감사합니다.",
    "reviews": [],
    "syllabus": [],
    "link": "https://spoqa.github.io/2025/04/18/improve-auth.html",
    "pubDate": "2025-04-18T00:00:00.000Z",
    "creator": "Unknown",
    "categories": []
  }
]