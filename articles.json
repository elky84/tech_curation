[
  {
    "id": 1,
    "imageUrl": "",
    "title": "AI 시대에 필요한 미덕 &quot;실행&quot;",
    "description": "한동안 글을 쓰지 않았다.  작가라는 타이틀도 생기고, 구독자도 생기면서 고퀄리티의 글을 써야한다는 강박도 생겼고, 실제로 예전만큼 좋은 아이디어가 떠오르지 않아서이기도 하다. 그리고 전문가라고 생각했던 부분에 대한 무지함이 느껴져서 일수도 있다.  세상이 참 많이 바뀌었다. 예전에는 글을 쓰기 위해서 정말 많은 고민을 하고 탈고를 했는데, 이제는 AI랑",
    "reviews": [],
    "syllabus": [],
    "link": "https://brunch.co.kr/@@H9i/88",
    "pubDate": "Tue, 07 Oct 2025 10:19:12 GMT",
    "creator": "권용진",
    "categories": []
  },
  {
    "id": 2,
    "imageUrl": "",
    "title": "Introducing the Candle Subsea Cable, Updates to Our Asia-Pacific Connectivity Projects",
    "description": "We’re introducing Candle, a new submarine cable connecting countries across East Asia and Southeast Asia. We’re also announcing several updates to our subsea cables across the Asia-Pacific, including the completion of the Bifrost cable system. The Asia-Pacific (APAC) region is home to over 58% of the world’s internet users1 – many who rely on robust [...]\nRead More...\nThe post Introducing the Candle Subsea Cable, Updates to Our Asia-Pacific Connectivity Projects appeared first on Engineering at Meta.",
    "reviews": [],
    "syllabus": [],
    "link": "https://engineering.fb.com/2025/10/05/connectivity/introducing-the-candle-subsea-cable-updates-to-our-asia-pacific-connectivity-projects/",
    "pubDate": "Mon, 06 Oct 2025 02:30:07 +0000",
    "creator": "Unknown",
    "categories": [
      "Connectivity"
    ]
  },
  {
    "id": 3,
    "imageUrl": "",
    "title": "바이브코딩왕의 첫번째 레슨",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://coolspeed.wordpress.com/2025/10/07/%eb%b0%94%ec%9d%b4%eb%b8%8c%ec%bd%94%eb%94%a9%ec%99%95%ec%9d%98-%ec%b2%ab%eb%b2%88%ec%a7%b8-%eb%a0%88%ec%8a%a8/",
    "pubDate": "Tue, 07 Oct 2025 07:54:13 +0000",
    "creator": "coolspeed",
    "categories": [
      "未分类"
    ]
  },
  {
    "id": 4,
    "imageUrl": "",
    "title": "[MULTI] 잘 훈련된 퇴마사는 대략 0.5여고생 즉, 사일런트 힐 f",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://bbs.ruliweb.com/news/board/11/read/2370",
    "pubDate": "Thu, 09 Oct 2025 00:31:32 +0900",
    "creator": "(RULIWEB`Д')/",
    "categories": [
      "리뷰"
    ]
  },
  {
    "id": 5,
    "imageUrl": "",
    "title": "Crafting Your KotlinConf Proposal: Expert Tips to  Help You Stand Out",
    "description": "Thinking about sharing your Kotlin expertise on the big stage? KotlinConf is the premier event for all things Kotlin, and getting a talk accepted for inclusion in the conference is a fantastic way to contribute to the community and elevate your profile. However, submitting a talk proposal, especially for the first time, can feel daunting. […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/kotlin/2025/10/crafting-your-kotlinconf-proposal-expert-tips/",
    "pubDate": "Wed, 08 Oct 2025 16:26:27 +0000",
    "creator": "Daria Voronina",
    "categories": [
      "news",
      "events",
      "kotlinconf",
      "tips"
    ]
  },
  {
    "id": 6,
    "imageUrl": "",
    "title": "악역영애 4컷 만화 - 22화, 반장 선거인 데스와 ①",
    "description": "No description available",
    "reviews": [],
    "syllabus": [],
    "link": "https://bbs.ruliweb.com/news/board/11/read/2369",
    "pubDate": "Wed, 08 Oct 2025 19:28:47 +0900",
    "creator": "｜RULIWEB｜",
    "categories": [
      "웹툰"
    ]
  },
  {
    "id": 7,
    "imageUrl": "",
    "title": "개발자는 사라지고, “아키텍트”가 뜬다: AI가 다시 불러온 설계의 시대 [펌]",
    "description": "🚨<개발자는 사라지고, “아키텍트”가 뜬다: AI가 다시 불러온 설계의 시대> 🎞️영화 ‘매트릭스’에서 ‘네오’가 마지막에 만난 인물이, 가상현실 매트릭스의 지배자인 인공지능 ‘아키텍트’였다. 🧐 Agile은 한 시대를 구했지만, AI라는 새로운 플레이어 앞에서 균형을 잃었다. 잘못된 길 위에서의 속도는 재앙일 뿐이다. 결국 사람이 해야 할 일은 ‘방향을 잡는 것’이고, 기계는 그 방향 안에서 움직이는 패턴 복제자에 불과하다. 💡투자자는 “AI로 […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://coolspeed.wordpress.com/2025/10/07/%ea%b0%9c%eb%b0%9c%ec%9e%90%eb%8a%94-%ec%82%ac%eb%9d%bc%ec%a7%80%ea%b3%a0-%ec%95%84%ed%82%a4%ed%85%8d%ed%8a%b8%ea%b0%80-%eb%9c%ac%eb%8b%a4-ai%ea%b0%80-%eb%8b%a4%ec%8b%9c-%eb%b6%88%eb%9f%ac/",
    "pubDate": "Tue, 07 Oct 2025 07:56:00 +0000",
    "creator": "coolspeed",
    "categories": [
      "未分类"
    ]
  },
  {
    "id": 8,
    "imageUrl": "",
    "title": "팔란티어 온톨로지 플랫폼 아키텍처 기술 해부 및 구현 방법 ",
    "description": "이 글은 세계적으로 주목받고 있는 팔란티어(Palantir)의 온톨로지 플랫폼 아키텍처를 소프트웨어 공학 관점에서 분석하고, 오픈소스 기술을 활용한 구현 방법을 정리한다. 팔란티어의 핵심은 기존 시스템을 대체하는 것이 아니라, 통합하고 확장하는 개방성에 있다. 이 글은 팔란티어가 어떻게 검증된 오픈소스 기술 기반 위에 독자적인 온톨로지(Ontology)라는 의미론적 추상화 계층을 구축했는지, 그리고 그 구조를 파헤쳐 본다.\n\n\n\n팔란티어 아키텍처의 핵심 철학 - 개방과 통합\n팔란티어 아키텍처의 근간에는 '대체가 아닌 통합'이라는 철학이 있다. 이는 기업이 이미 막대한 투자를 한 데이터 레이크, ERP, CRM과 같은 기존 IT 환경을 교체하는 대신, 이들을 하나로 묶고 그 가치를 증대시키는 플랫폼 역할을 하는 것이다.\n\n이러한 철학은 아키텍처의 명확한 관심사 분리로 이어진다. 배포, 오케스트레이션, 데이터 처리와 같은 하위 계층은 의도적으로 쿠버네티스(Kubernetes), 스파크(Spark), 플링크(Flink) 등 보편적인 오픈소스 표준 위에 구축된다. 이를 통해 고객의 기존 기술 스택 및 엔지니어링 역량과 마찰 없이 통합된다. 반면, 온톨로지, AI 플랫폼(AIP)과 같은 상위 계층에는 팔란티어의 독자적인 지적 재산이 집중된다. 이 구조는 고객이 새로운 데이터베이스나 컴퓨팅 엔진이 아닌, 기존 자산과 상호 작용하는 새로운 패러다임을 구매하게 만들어 비지니스 가치를 제안한다.\n\n\n플랫폼의 안정성과 확장성은 두 가지 핵심 기술, 즉 자율 배포 시스템인 아폴로(Apollo)와 쿠버네티스 기반의 컨테이너 오케스트레이션 기판인 루빅스(Rubix)에 의해 뒷받침된다. 이 기반 위에서 데이터 통합 및 분석 플랫폼인 파운드리(Foundry), 국방 및 정보 분석에 특화된 고담(Gotham), 그리고 AI 모델을 온톨로지와 연결하는 AIP(Artificial Intelligence Platform)가 운영된다.\n\n팔란티어 아키텍처 구조 개념도\n\n\n데이터 처리 워크플로우 - 비정형 데이터에서 지식으로 변환\n팔란티어의 워크플로우는 이기종의 파편화된 데이터 소스를 연결하고, 이를 구조화된 지식으로 변환하여 온톨로지를 '활성화(Hydration)'하는 과정이다.\n\n\n데이터 수집 및 파싱\n\n\nPDF, 문서, 이미지와 같은 비정형 데이터는 먼저 '미디어 셋(media sets)'이라는 파일 모음으로 수집된다. 데이터를 파싱하는 과정은 블랙박스가 아니다. 개발자는 파이썬(Python)이나 자바(Java) 변환과 저수준 파일 시스템 API를 사용하여 직접 파이프라인을 구축한다. 이는 결정론적이고, 테스트 가능하며, 버전 관리가 가능한 파이프라인을 통해 신뢰성과 거버넌스를 확보하는 엔지니어링 중심의 접근 방식이다.\n\n\n\n\n\n더 나아가 AIP는 AI 기반 파싱 기능을 제공한다. 이는 사전 훈련되거나 맞춤화된 AI 모델(예: NLP 모델)을 파이프라인 내에 통합하여 개체명 인식, 요약과 같은 정교한 작업을 수행하는 방식이다. 이 구조는 엔지니어가 견고한 데이터 파이프라인을 구축하고, AI 엔지니어가 그 안에 두뇌 역할을 하는 모델을 배포하는 효율적인 이중 계층 시스템을 만든다.\n\n\n\n기반 처리 기술\n\n\n이러한 데이터 변환 및 통합 로직은 독점 엔진에 종속되지 않는다. 모든 데이터는 아파치 파케이(Apache Parquet), 아브로(Avro)와 같은 표준 형식으로 저장되며, 대규모 배치 처리를 위한 아파치 스파크, 실시간 스트림 처리를 위한 아파치 플링크와 같은 오픈소스 런타임을 사용한다.\n\n\n\n온톨로지 메타모델\n온톨로지는 팔란티어의 핵심 차별화 요소로, 기업의 모든 데이터, 모델, 프로세스를 현실 세계의 대응물(공장, 고객, 제품 등)과 연결하는 의미론적, 동역학적 계층이다. 이는 기업의 '디지털 트윈(digital twin)' 역할을 한다.\n\n\n온톨로지의 개념은 객체 지향 프로그래밍(OOP)과 매우 유사하다.\n\n객체(Object)는 클래스(Class)에 해당한다. 온톨로지의 '항공기' 객체 유형은 OOP의 Aircraft 클래스와 같다.\n속성(Property)은 속성(Attribute)에 해당한다. '항공기' 객체의 '꼬리 번호' 속성은 Aircraft 클래스의 tailNumber 속성과 같다.\n연결(Link)은 객체 간의 관계(Association)에 해당한다. '조종사'가 '항공기'에 탑승한다는 연결은 Pilot 객체와 Aircraft 객체 간의 관계를 정의한다.\n\n다음은 이를 역공학해본 온톨로지 메타모델 구조이다. \n\n\n팔란티어 온톨로지 메타모델(UML)\n\n\n본질적으로 온톨로지는 기업의 비즈니스 개념을 객체 지향 방식으로 모델링한 추상화 계층이다.\n\n\n\n\n온톨로지 작업 UI 메뉴\n\n\n\n\n플랫폼 아키텍처적 고려 - 디커플링(Decoupling)\n온톨로지의 가장 중요한 기능은 소스 데이터 시스템과 운영 애플리케이션 사이에 안정적인 추상화 계층을 제공하여 애플리케이션 계층을 데이터 계층과 분리(decouple)하는 것이다.\n\n\n일반적으로 애플리케이션은 ERP나 CRM 같은 소스 데이터베이스에 직접 연결된다. 만약 소스 시스템의 스키마가 변경되면 모든 종속 애플리케이션이 손상되어 막대한 기술 부채를 유발한다. 온톨로지는 중간 계층 역할을 한다. 애플리케이션은 원시 데이터 테이블이 아닌, 온톨로지의 안정적인 비즈니스 객체(예: '고객' 객체)를 기준으로 구축된다. 소스 시스템이 변경되더라도 '활성화' 파이프라인만 수정하면 되므로, 온톨로지 위에 구축된 수백 개의 운영 애플리케이션은 영향을 받지 않는다. 이는 사실상 온톨로지가 기업 전체 데이터에 대한 안정적인 API 역할을 수행하게 하여, 기업의 민첩성을 극적으로 높이고 유지보수 비용을 절감한다.\n\n\n클라이언트 앱 프로젝트 생성 UI 메뉴 \n \n\n온톨로지 메타모델 구현 방법\n팔란티어의 온톨로지는 마법이 아닌, 소프트웨어 공학적으로 설계된 데이터 모델링과 아키텍처 원칙의 조합이다. 이는 오픈소스 기술 스택으로 충분히 구현 가능한 구조이다.\n\n\n\n온톨로지의 요구사항은 특정 객체를 빠르게 조회하고, 객체 간의 복잡한 관계를 탐색하며, 대규모 데이터셋을 검색하는 것이다. 이를 만족시키기 위한 가장 가능성 높은 아키텍처는 단일 데이터베이스가 아닌, 여러 기술을 조합한 복합 아키텍처(Composite Architecture)이다.\n\n\n객체 저장소: 객체 데이터 자체는 카산드라(Cassandra)와 같은 수평적으로 확장 가능한 Key-Value 저장소에 저장될 수 있다. 각 객체는 고유 ID를 키(Key)로, 모든 속성을 담은 JSON 문서를 값(Value)으로 저장하는 방식이다.\n검색 및 그래프 인덱스: 빠른 검색, 집계, 그래프 탐색 기능을 위해서는 엘라스틱서치(Elasticsearch)나 루씬(Lucene) 기반의 검색 인덱스가 필수적이다. Key-Value 저장소에 저장된 객체 데이터는 검색 엔진으로 인덱싱되어 풍부한 쿼리 기능을 제공한다.\n\n이 구조에서 온톨로지는 기술적으로 레이블이 있는 속성 그래프(Labeled Property Graph, LPG) 모델로 구현된다. 객체는 '노드(Node)'가 되고, 연결은 '간선(Edge)'이 되며, 이는 확장성이 뛰어난 Key-Value 저장소와 검색 인덱스의 조합 위에 효율적으로 구축될 수 있다.\n\n\n온톨로지는 고객의 기존 MongoDB나 PostgreSQL을 대체하지 않는다. 대신 JDBC, ODBC와 같은 표준 커넥터를 통해 이들 시스템에 연결하고, 데이터를 가져와 온톨로지 모델로 '활성화'한다. 예를 들어, PostgreSQL의 여러 테이블을 조인하여 하나의 '제품' 객체를 생성하거나, MongoDB의 'customers' 컬렉션을 '고객' 객체로 매핑할 수 있다.\n\nSQL 질의문 예시\n\n\n온톨로지의 활용 - AI 에이전트와 애플리케이션\n완전히 활성화된 온톨로지는 AI 에이전트와 인간 운영자가 상호작용하는 기반이 된다(인간-AI 팀 개념 구현). AI 에이전트는 온톨로지라는 잘 구조화된 지식 그래프를 탐색하며 복잡한 추론을 수행한다. 예를 들어, \"배송 지연 위험이 있는 제품은 무엇인가?\"라는 질문에, 에이전트는 '제품'에서 '공급업체', '위험 점수'로 그래프 관계를 탐색하며 다각적인 답변을 생성할 수 있다.\n\n\n팔란티어의 인간-AI 팀 개념도\n\n\n\n개발자는 파이썬 OSDK(Ontology SDK) 등을 사용하여 온톨로지와 상호작용하는 애플리케이션을 구축한다. client.ontology.objects.Shipment.where(status=\"Delayed\").all()과 같은 코드는 SQL 쿼리보다 훨씬 직관적이며, 비즈니스 용어로 로직을 작성할 수 있게 해준다. 또한, 온톨로지에 정의된 '액션(Action)'을 호출하는 것은 단순한 데이터베이스 업데이트가 아니라, 플랫폼의 모든 거버넌스, 보안, 감사 추적이 적용되는 통제된 트랜잭션을 실행하는 것이다.\n\n\n팔란티어 앱 개발 방법 예시\n\n\n\n팔란티어 플랫폼 기반 앱 개발 예시\n개발자가 Palantir Foundry의 온톨로지 SDK(OSDK)를 사용하여 실제 운영 애플리케이션을 어떻게 구축하는지 살펴보는 것은 플랫폼의 가치를 이해하는 데 중요하다. 이 섹션에서는 가상의 물류 애플리케이션 시나리오를 통해 Python OSDK의 실제 코딩 예시를 제시한다.\n\n물류 회사는 매일 수천 건의 화물을 처리한다. '화물(Shipment)'과 '운송 차량(Vehicle)'이라는 두 가지 핵심 객체 유형이 온톨로지에 정의되어 있다고 가정하자. 물론, 이 온톨로지 객체 인스턴스들은 파서 파이프라인을 통해 데이터베이스에 구축된 상태이다. 팔란티어는 고객 데이터베이스에 온톨로지를 구축하기 위해 개발 컨설팅을 서비스한다. \n\n\n이 예제에서는 이 과정이 끝나고, 온톨로지 모델을 통해 접근할 수 있는 '화물' 객체에는 shipmentId, status (예: '운송 중', '지연', '배송 완료'), destination과 같은 속성이 있다. '운송 차량' 객체에는 vehicleId, currentLocation 속성이 있으며, 각 '화물'은 특정 '운송 차량'에 할당되어 온톨로지 상에서 연결(Link)되어 있다. 온톨로지를 여기서는 데이터베이스가 아닌 추상 레이어(미들웨어)라 가정해야 한다. 다음은 팔란티어 온톨로지 기반으로 정의된 사용자 모델이다.\n\n사용자 온톨로지 모델 구조(UML)\n우리의 목표는 '지연' 상태인 모든 화물을 식별하고, 운영자가 상태를 '조사 중'으로 변경할 수 있는 간단한 스크립트를 작성하는 것이다.\nFoundry 플랫폼은 개발자가 온톨로지와 직접 상호작용할 수 있는 언어별 SDK를 제공한다.37 Python OSDK는 객체, 속성, 액션을 마치 일반적인 Python 클래스와 메서드처럼 다룰 수 있게 해준다.\n\n\nimport os\nfrom <YOUR_PACKAGE_NAME> import FoundryClient\nfrom <YOUR_PACKAGE_NAME>.core.api import UserTokenAuth\n\n# 1. Foundry 클라이언트 초기화\ntry:\n    auth = UserTokenAuth(\n        hostname=os.environ,\n        token=os.environ\n    )\n    client = FoundryClient(auth=auth, hostname=os.environ)\nexcept KeyError:\n    print(\"오류: FOUNDRY_HOSTNAME 및 FOUNDRY_TOKEN 환경 변수를 설정.\")\n    exit()\n\n# 2. 온톨로지 객체 쿼리: 지연된 화물 검색\n#    OSDK는 온톨로지의 각 객체 유형(예: Shipment)에 대한 접근자를 제공\n#    'where' 절을 사용하여 특정 속성 값(status == \"Delayed\")을 기준으로 객체를 필터링\nprint(\"\\n'지연' 상태인 화물을 검색...\")\ndelayed_shipments = client.ontology.objects.Shipment.where(status=\"Delayed\").all()\n\nif not delayed_shipments:\n    print(\"지연된 화물이 없음.\")\nelse:\n    print(f\"총 {len(delayed_shipments)}개의 지연된 화물을 찾음\")\n\n    # 3. 객체 속성 접근 및 연결된 객체 탐색\n    #    검색된 각 화물 객체에 대해 속성(shipmentId, destination 등)에 직접 접근\n    #    온톨로지 연결을 통해 'assignedVehicle'과 같은 연결된 객체를 로드\n    for shipment in delayed_shipments:\n        print(f\"\\n- 화물 ID: {shipment.shipmentId}\")\n        print(f\"  목적지: {shipment.destination}\")\n        print(f\"  현재 상태: {shipment.status}\")\n\n        # 연결된 운송 차량 정보 로드\n        try:\n            vehicle = shipment.assignedVehicle.get()\n            print(f\"  할당된 차량 ID: {vehicle.vehicleId}\")\n            print(f\"  차량 현재 위치: {vehicle.currentLocation}\")\n        except Exception as e:\n            print(f\"  할당된 차량 정보를 가져오는 데 실패: {e}\")\n\n\n    # 4. 온톨로지 액션(Action) 실행\n    #    온톨로지의 동역학적 계층은 'update_shipment_status'와 같은 액션을 정의\n    target_shipment = delayed_shipments\n    print(f\"\\n화물 {target_shipment.shipmentId}의 상태를 '조사 중'으로 업데이트...\")\n\n    try:\n        # 'update_shipment_status'는 온톨로지에 미리 정의된 액션의 API 이름이라고 가정\n        target_shipment.update_shipment_status(new_status=\"Investigation\")\n        print(\"상태 업데이트 액션이 성공적으로 실행.\")\n\n        # 변경 사항 확인\n        updated_shipment = client.ontology.objects.Shipment.get(target_shipment.shipmentId)\n        print(f\"화물 {updated_shipment.shipmentId}의 새로운 상태: {updated_shipment.status}\")\n\n    except Exception as e:\n        print(f\"액션 실행 중 오류가 발생: {e}\")\n\n위 코드는 Palantir 플랫폼의 핵심 철학을 보여준다. 개발자는 기본 데이터베이스의 스키마나 조인(join) 로직에 대해 알 필요가 없다. 대신, 비즈니스 용어(Shipment, Vehicle, status)로 정의된 잘 구조화된 온톨로지 API와 상호작용한다. \n\n\nclient.ontology.objects.Shipment.where(...)와 같은 코드는 SQL 쿼리보다 훨씬 직관적이며, 애플리케이션 로직과 기본 데이터 저장소를 분리(decouple)시킨다. 액션(Action)을 호출하는 것은 단순한 UPDATE 문이 아니라, 플랫폼의 거버넌스와 보안 모델을 통과하는 감사 가능한 트랜잭션을 실행하는 것이다. 이러한 접근 방식은 개발 속도를 크게 향상시키고 유지보수 비용을 절감하며, 복잡한 기업 환경에서도 일관성 있고 안전한 데이터 조작을 보장한다.\n\n\n\n결론\n팔란티어 플랫폼 아키텍처를 해부한 결과, 강력함은 독점적인 데이터베이스 기술이 아닌 추상화에 있다. 팔란티어는 쿠버네티스, 스파크와 같은 검증된 오픈소스 기술을 기반으로, 고객이 이미 보유한 다양한 데이터베이스 위에 '온톨로지'라는 일관되고 의미 있는 비즈니스 언어 계층을 구축한다.\n\n팔란티어의 개방형 데이터셋 연결 구조 예시\n\n\n이 아키텍처는 기업이 기존 데이터 투자의 가치를 극대화하고, 데이터와 운영 애플리케이션을 분리하여 미래 변화에 민첩하게 대응할 수 있도록 만든다. \n\n\n레퍼런스\n\nPlatform overview • Architecture • Palantir\nOntology SDK • Overview • Palantir\npalantir/palantir-python-sdk: Palantir Python SDK\nGetting started • API Reference • Palantir\nOverview • Ontology • Palantir\nGet Ontology Full Metadata • API Reference • Palantir\nObject and link types • Object types • Overview • Palantir\nSearch Objects • API Reference • Palantir\nExecute Sql Query • API Reference • Palantir\nWhy create an Ontology? • Palantir\nOntologies • Overview • Palantir\nOntologies • Migrating between ontologies • Palantir\nGetting started • Cross-Organization collaboration • Palantir\nRun Palantir Foundry and Artificial Intelligence Platform on OCI\n\n부록: 카산드라(Cassandra)의 아키텍처적 장점 및 온톨로지 모델 구현\n1. 개요\n이 글은 카산드라의 쿼리 언어(CQL)와 전통적인 SQL의 관계를 설명한다. 이어서, 개발자들이 특정 시나리오에서 관계형 데이터베이스 대신 카산드라를 선택하는 핵심적인 아키텍처적 장점인 수평적 확장성, 고가용성, 쓰기 성능을 설명한다.\n\n카산드라 깃허브: apache/cassandra: Apache Cassandra\n엘라스틱서치 깃허브: elastic/elasticsearch: Free and Open Source, Distributed, RESTful Search Engine\n\n\n참고로, 엘라스틱서치(Elasticsearch)는 루씬(Lucene)이라는 검색 라이브러리를 기반으로 만든 오픈소스 검색 및 분석 엔진이다. 엘라스틱서치는 저장된 데이터를 찾고 분석하는 데 특화되어 있다.\n\n\n\n2. 카산드라와 SQL의 관계\n카산드라가 \"그냥 SQL이 지원되는 데이터베이스\"라는 인식은 반은 맞고 반은 틀린 이야기이다.\n카산드라는 CQL (Cassandra Query Language)을 사용한다. SELECT, INSERT, UPDATE, CREATE TABLE 등 그 문법이 SQL과 매우 유사하여, 기존 관계형 데이터베이스(RDBMS)에 익숙한 개발자가 쉽게 배울 수 있다는 장점이 있다. 이는 의도적으로 설계된 부분이다.\n겉모습은 비슷하지만, 내부 동작 원리와 데이터 모델링 철학은 완전히 다르다. 카산드라는 관계형 데이터베이스가 아니다. 가장 큰 차이점은 다음과 같다.\n\n카산드라는 여러 테이블을 연결하는 JOIN 연산을 지원하지 않는다. 이는 분산 환경에서 JOIN이 유발하는 막대한 성능 저하를 원천적으로 차단하기 위함이다.\n외래 키(Foreign Key)와 같은 관계 무결성을 데이터베이스 차원에서 보장하지 않는다.\nRDBMS가 데이터의 관계를 정규화하여 모델링하는 반면, 카산드라는 애플리케이션이 사용할 쿼리(조회 방식)를 먼저 설계하고 그에 맞춰 테이블을 비정규화(denormalization)하여 구성한다.\n결론적으로, CQL은 SQL의 편리한 문법을 차용한, 분산 Key-Value 데이터 저장소에 최적화된 전혀 다른 언어이다.\n\n3. 개발자가 카산드라를 선택하는 이유\n개발자들은 RDBMS가 해결하기 어려운 특정 문제들을 풀기 위해 카산드라를 선택한다.\n\n가. 분산 아키텍처와 수평적 확장성 (Horizontal Scalability)\n이것이 카산드라를 사용하는 가장 큰 이유이다. 카산드라는 여러 서버(노드)를 묶어 하나의 거대한 데이터베이스처럼 사용하는 'Shared-Nothing' 분산 아키텍처를 기반으로 한다.\n\n수평적 확장: 데이터가 늘어나거나 트래픽이 증가할 때, 고가의 단일 서버 성능을 높이는 '수직적 확장'이 아니라, 저렴한 일반 서버를 클러스터에 계속 추가하는 '수평적 확장'이 가능하다. 이론적으로 서버를 추가하는 만큼 성능과 용량이 선형적으로 증가한다.\n대규모 데이터 처리: 수십억, 수백억 개의 행을 가진 페타바이트(PB)급 데이터를 처리하는 데 최적화되어 있다.\n\n나. 고가용성 및 장애 허용 (High Availability & Fault Tolerance)\n카산드라 클러스터에는 마스터(Master) 노드처럼 특별한 역할을 하는 노드가 없어 단일 장애점(SPOF, Single Point of Failure)이 존재하지 않는다.\n\n데이터 복제: 데이터는 클러스터 내 여러 노드에 자동으로 복제되어 저장된다.\n무중단 서비스: 특정 노드에 장애가 발생하더라도, 복제된 데이터를 가진 다른 노드가 즉시 요청을 처리하여 서비스 중단 없이 운영이 가능하다. 이는 24시간 365일 무중단이 필수적인 서비스에 결정적인 장점이다.\n다. 압도적인 쓰기 성능\n카산드라는 LSM-Tree (Log-Structured Merge-Tree) 라는 자료 구조를 사용하여 데이터를 저장한다. 이는 디스크에 데이터를 순차적으로 추가(Append-Only)하는 방식으로, 기존 RDBMS의 B-Tree 방식보다 쓰기 작업에 훨씬 유리하다.\n\n활용 사례: 사물 인터넷(IoT) 센서 데이터, 서비스 로그, 메시징 데이터처럼 끊임없이 대량으로 쏟아지는 데이터를 지연 없이 저장해야 하는 시스템에 최적이다.\n\n4. 실제 구현 사례 - 온톨로지 모델의 객체 저장소\n앞서 구현한 온톨로지 모델은 카산드라의 장점을 활용한 전형적인 데이터 아키텍처로 적용 가능하다.\n\n가. 아키텍처 장점\n이 시스템은 두 가지 데이터베이스를 조합하여 각자의 장점을 극대화한다.\n\n객체 저장소 (카산드라): 모든 객체의 원본 데이터를 저장하는 'Source of Truth' 역할을 한다.\n검색 인덱스 (엘라스틱서치): 카산드라에 저장된 데이터를 복사하여, 복잡한 검색 및 집계 기능을 제공한다.\n나. 카산드라의 역할\n온톨로지 모델의 객체 저장소로 카산드라를 선택할 때 좋은 이유는 다음과 같다.\n\nKey-Value 최적화: 온톨로지 객체는 고유 ID를 Key로, 속성 데이터를 Value로 갖는다. 이는 object_id를 파티션 키로 사용하는 카산드라의 데이터 모델과 완벽하게 부합하며, ID 기반 조회 시 최고의 성능을 보장한다.\n확장성: 수억, 수십억 개의 온톨로지 객체가 생성되더라도, 단순히 카산드라 클러스터에 노드를 추가하는 것만으로 시스템을 수평적으로 확장할 수 있다.\n가용성: 온톨로지 데이터는 기업의 핵심 자산이다. 카산드라의 무중단 특성은 일부 노드에 장애가 발생해도 객체 데이터의 유실 없이 안정적으로 서비스를 유지할 수 있도록 보장한다.\n다. 구현 코드\n다음은 카산드라와 엘라스틱서치를 사용하여 온톨로지 모델을 구현한 파이썬 코드이다. 이 코드는 위에서 설명한 아키텍처 원리를 추측해 구현해 본 것이다.\n\n\nimport uuid\nimport json\nimport time\nfrom cassandra.cluster import Cluster\nfrom cassandra.query import SimpleStatement\nfrom elasticsearch import Elasticsearch\n\n# 1. 데이터베이스 연결 설정\ndef setup_cassandra(contact_points=['127.0.0.1'], port=9042):\n    cluster = Cluster(contact_points, port=port)\n    session = cluster.connect()\n    \n    # 키스페이스 생성\n    session.execute(\"\"\"\n    CREATE KEYSPACE IF NOT EXISTS ontology\n    WITH replication = { 'class': 'SimpleStrategy', 'replication_factor': '1' }\n    \"\"\")\n    session.set_keyspace('ontology')\n\n    # 객체 저장을 위한 테이블 생성 (JSON 문자열로 속성 저장)\n    session.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS objects (\n        object_id TEXT PRIMARY KEY,\n        properties TEXT\n    )\n    \"\"\")\n    print(\"카산드라 설정 완료: 'ontology' 키스페이스 및 'objects' 테이블 준비됨.\")\n    return cluster, session\n\ndef setup_elasticsearch(hosts=[{'host': 'localhost', 'port': 9200, 'scheme': 'http'}]):\n    es_client = Elasticsearch(hosts=hosts)\n    if not es_client.ping():\n        raise ValueError(\"엘라스틱서치 연결에 실패.\")\n    print(\"엘라스틱서치 연결 성공.\")\n    return es_client\n\n# 2. 온톨로지 클래스 구현 \nclass Ontology:\n    def __init__(self, cassandra_session, es_client, es_index_name='ontology_index'):\n        self.session = cassandra_session\n        self.es = es_client\n        self.es_index = es_index_name\n        \n        if not self.es.indices.exists(index=self.es_index):\n            self.es.indices.create(index=self.es_index)\n            print(f\"엘라스틱서치 인덱스 '{self.es_index}' 생성됨.\")\n\n    def add_object(self, object_type, properties):\n        object_id = f\"{object_type}-{uuid.uuid4().hex[:8]}\"\n        full_properties = {\"object_type\": object_type, properties}\n        \n        query = SimpleStatement(\"INSERT INTO objects (object_id, properties) VALUES (%s, %s)\")\n        self.session.execute(query, (object_id, json.dumps(full_properties)))\n        \n        self.es.index(index=self.es_index, id=object_id, document=full_properties)\n        \n        print(f\"객체 추가됨: {object_id} (카산드라 저장, ES 인덱싱 완료)\")\n        return object_id\n\n    def get_object(self, object_id):\n        query = \"SELECT properties FROM objects WHERE object_id = %s\"\n        row = self.session.execute(query, (object_id,)).one()\n        if row:\n            return json.loads(row.properties)\n        return None\n\n    def search(self, property_key, property_value):\n        query = { \"match\": { f\"{property_key}.keyword\" if isinstance(property_value, str) else property_key: property_value } }\n        response = self.es.search(index=self.es_index, query=query)\n        hits = response['hits']['hits']\n        print(f\"\\nES 검색 실행 ('{property_key}:{property_value}')... {len(hits)}개 결과 찾음.\")\n        return [hit['_source'] for hit in hits]\n\n    def add_link(self, source_object_id, link_type, target_object_id):\n        source_object = self.get_object(source_object_id)\n        if not source_object: return\n\n        if \"_links\" not in source_object: source_object[\"_links\"] = {}\n        if link_type not in source_object[\"_links\"]: source_object[\"_links\"][link_type] = []\n        source_object[\"_links\"][link_type].append(target_object_id)\n        \n        query = SimpleStatement(\"INSERT INTO objects (object_id, properties) VALUES (%s, %s)\")\n        self.session.execute(query, (source_object_id, json.dumps(source_object)))\n        self.es.index(index=self.es_index, id=source_object_id, document=source_object)\n\n        print(f\"링크 추가 및 업데이트됨: {source_object_id} --({link_type})--> {target_object_id}\")\n\n5. 결론\n카산드라는 SQL과 유사한 CQL을 제공하여 개발자 친화적이지만, 그 본질은 대규모 분산 환경을 위해 태어난 NoSQL 데이터베이스이다. JOIN이나 참조 무결성을 포기하는 대신 수평적 확장성, 고가용성, 뛰어난 쓰기 성능이라는 명확한 장점을 얻었다.\n\n참고로, 오픈소스인 칸산드라 개발자는 아비나쉬 라크쉬만 (Avinash Lakshman), 프라샨트 말릭 (Prashant Malik)이다. 페이스북의 '받은 편지함 검색(Inbox Search)' 기능의 대규모 데이터 처리 요구사항을 충족시키기 위해 내부적으로 개발되었다. 아마존(Amazon)의 DynamoDB와 구글(Google)의 Bigtable 아키텍처에서 영감을 받아 설계되었다. 2008년 오픈소스로 공개된 후, 아파치 재단(ASF)의 최상위 프로젝트로 승격되어 전 세계적으로 널리 사용되는 분산 NoSQL 데이터베이스로 성장했다.\n\n\n팔란티어는 단일 개발자가 아닌, 각기 다른 전문성을 가진 공동 창업자들의 협업을 통해 탄생했다.\n피터 틸 (Peter Thiel)은 페이팔(PayPal)의 사기 방지 시스템 경험을 바탕으로 초기 비전을 제시한 핵심 창업자이다. 스티븐 코언 (Stephen Cohen)은 팔란티어 플랫폼의 초기 프로토타입을 직접 코딩한 핵심 엔지니어이다. 스탠퍼드 대학교 컴퓨터 과학 석사 출신으로, 그의 객체지향 프로그래밍(OOP) 배경이 온톨로지(Ontology) 아키텍처의 근간이 되었다. 네이선 게팅스 (Nathan Gettings)는 초기 엔지니어링 및 알고리즘 개발에 기여한 컴퓨터 과학자이다. \n\n\n플랫폼의 핵심인 온톨로지 개념은 창업자 그룹, 특히 스티븐 코언의 깊은 객체지향 프로그래밍(OOP) 이해도에서 비롯되었다. 이는 클래스(Class), 객체(Object), 관계(Link)로 현실을 모델링하는 OOP의 핵심 사상과 정확히 일치한다.\n\n온톨로지 구현 사례에서 보았듯이, 카산드라는 대규모 객체의 원본 데이터를 안정적으로 저장하고, 엘라스틱서치와 같은 검색 엔진과 결합하여 복잡한 조회 요구사항을 충족시키는 'Polyglot Persistence' 아키텍처의 핵심 구성 요소로 사용될 수 있다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://daddynkidsmakers.blogspot.com/2025/10/blog-post_11.html",
    "pubDate": "2025-10-11T11:48:00.000Z",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 9,
    "imageUrl": "",
    "title": "TCP vs UDP – latency 차이",
    "description": "강의 자료를 만들면서 ‘이미 연결이 되어있고 재전송이 일어나지 않는다는 전제 하에 tcp와 udp의 latency차이가 없다’라는 내용을 적다가 혹시 몰라서 ai한테 이 내용에 대해 물어봤다. chatgpt, copilot – ‘거의 차이가 없다’ 라고 대답gemini – ‘[명백]하게 udp가 빠르다’ 라고 대답 ai가 코드를 짜서 돌려봤겠냐, 넷상에 퍼진 얘기들 조합해서 답을 해주니 이 모양이지. 시퀀스를 맞춰보고 슬라이딩 윈도우를 조절하는 … More TCP vs UDP – latency 차이",
    "reviews": [],
    "syllabus": [],
    "link": "https://megayuchi.com/2025/10/07/tcp-vs-udp-latency-%ec%b0%a8%ec%9d%b4/",
    "pubDate": "Tue, 07 Oct 2025 01:59:44 +0000",
    "creator": "megayuchi",
    "categories": [
      "Development",
      "Network",
      "socket",
      "Win32",
      "winsock"
    ]
  },
  {
    "id": 10,
    "imageUrl": "",
    "title": "CLion Nova Will Become the Default Engine for All Users in v2025.3 – Here’s What You Need to Know",
    "description": "CLion Nova became the default language engine for new users starting with v2024.2. Since then, we’ve delivered the features users wanted most and addressed key bugs. We’ve also received very positive feedback from people and organizations who have tried the new engine and compared it with the legacy one, CLion Classic. All of this has […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/clion/2025/10/nova-default-for-all/",
    "pubDate": "Mon, 06 Oct 2025 17:41:20 +0000",
    "creator": "Oleg Zinovyev",
    "categories": [
      "news",
      "clionnova"
    ]
  },
  {
    "id": 11,
    "imageUrl": "",
    "title": "미국 코스트코에 파는 월병에 발암물질이 있다고 경고문이 적혀있다고 합니다.",
    "description": "신세계 였나 거기서도 월병에 돈넣은 뇌물 주는 장면이 있었는데\n먹어보고 싶었는데 이젠 먹을 수가 없게되었군요\n \n개미도 죽고\n개는 도망가고\n \n영상: https://youtu.be/engVha2lRIs?t=963\n\n\n\n \n16분 에 나옵니다.\n이미 중국에서 그 경고문이 붙었고\n미국에도 같은걸 파니까 확인하러 같는데 역시 있었다고 합니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1425",
    "pubDate": "Sat, 11 Oct 2025 20:19:28 +0900",
    "creator": "SIDNFT",
    "categories": [
      "유튜브",
      "중국",
      "중국음식"
    ]
  },
  {
    "id": 12,
    "imageUrl": "",
    "title": "298일차 - 유니티 할로윈 영상 이벤트 / 토스 게임 공모전 / 삼성 XR 기기 출시예정",
    "description": "영상: https://www.youtube.com/watch?v=vxV4aW-qgCY&t=3s\n \n \n\n\n\n유니티 할로윈 이벤트 \n링크 https://unitysquare.co.kr/event/communityevent/view?id=100?utm_source=eloqua&utm_medium=newsletter&utm_campaign=kr_newsletter_2509 \n\n \nSPOOKY UNITY CHALLENGE\n \nunitysquare.co.kr\n\n \n \n \n토스 HTML5 첼린지 이벤트\n링크 https://toss.im/apps-in-toss/game-challenge/neptune \n\n \n토스 게임 공모전 - HTML5 게임 챌린지 with 넵튠\n총 상금 규모 7,000만원! 장르 불문 HTML5 기반 창작 게임이면 누구나 지원할 수 있어요. 앱인토스 파트너십을 통한 수익화 기회, 놓치지 마세요.\ntoss.im\n\n \n삼성 프로젝트 무한 XR 기기 발매\n10월 22일에 출시예정\n가격은 200만원  후반대",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1420",
    "pubDate": "Thu, 9 Oct 2025 19:08:45 +0900",
    "creator": "SIDNFT",
    "categories": [
      "유튜브",
      "삼성전자",
      "생존영상",
      "유니티",
      "유튜브",
      "토스"
    ]
  },
  {
    "id": 13,
    "imageUrl": "",
    "title": "반복의 기계",
    "description": "올해 나는 엘리트 운동선수들의 팟캐스트를 꽤 많이 들었다. 인간의 육체적, 정신적 한계를 극복하고 세계 최고의 운동선수가 된 사람들의 이야기를 들으면 들을수록 엘리트 운동선수와 창업가 간엔 공통점이 너무나 많다는 생각을 계속하게 된다. 가장 대표적인 공통점은 내가 자주 이야기하는 ‘극강의 바퀴벌레력’이다. 그중에서도 생존력과 회복력이 바퀴벌레, 창업가, 그리고 엘리트 운동선수가 태어날 때부터 보유하고 있는 천성, 또는 성장하면서 남들보다(...)",
    "reviews": [],
    "syllabus": [],
    "link": "https://www.thestartupbible.com/2025/10/machines-of-iteration.html",
    "pubDate": "Sun, 12 Oct 2025 21:26:00 +0000",
    "creator": "Kihong Bae",
    "categories": [
      "Uncategorized",
      "discipline",
      "FoundersAtWork",
      "inspiring",
      "principle",
      "sports",
      "Strong",
      "vc"
    ]
  },
  {
    "id": 14,
    "imageUrl": "",
    "title": "커피한잔 서버 장례식",
    "description": "며칠 전 아침, 누워서 핸드폰을 보고 있는데 알림이 막 날아왔습니다. 서버들이 동작하지 않는다고.\n운영하는 서비스들부터 살려 놓고는 다시 컴퓨터의 전원을 눌러봅니다.\n허허…\n사람이 죽은 것만큼 슬픈 것은 아니었지만, 기분이 이상했습니다.\n2019년부터 만 7년을 하루도 빠짐없이 열심히 일해줬던 컴퓨터.\n70쌍의 커플이 결혼하고, 수십 명의 아이가 태어났습니다.\n색칠 지도나 초등 받아쓰기도 이 컴퓨터에서 태어나서 자랐습니다.\n100만 원도 안 주고 샀던 컴퓨터가 돈도 참 많이 벌어다 줬습니다.\n가족들끼리 시간을 내서 장례식이라도 치러주기로 했습니다. (웃음)\n\n2023년 1월에 침수되어서 잠시 죽었다가 일주일 뒤 기적처럼 살아나 2년 넘게 더 일해주고 떠나네요.\n너와 함께 지내며 많이 배웠다. 고마워.\n\n\n함께 읽으면 좋은 글:\n커피한잔 서버 장애 썰\n서버 비용을 아끼던 사람들",
    "reviews": [],
    "syllabus": [],
    "link": "https://jeho.page/essay/2025/10/13/server-funeral.html",
    "pubDate": "2025-10-12T16:23:00.000Z",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 15,
    "imageUrl": "",
    "title": "2025-10 양자컴퓨터 정리 / 아이온큐 IONQ / 리게티 RGTI / 디웨이브 QBTS",
    "description": "아이온큐 IONQ \n단기 목표 64 큐비트\n \n리게티 RGTI\n2030 년까지 1,000 큐비\n \n디웨이브 컴텀 QBTS\n현재 4,100 개\n미래 100,000  큐비트\n \n결론\n당장봐선 디웨이브 퀀텀이 가장 우수합니다.\n셋중 하나는 세계 1위가 될 것이라고 하네요\n무조건 큐비트 높은게 최고 입니다.\n \n \n교융상도 하나 보시죠\n영상: https://www.youtube.com/watch?v=irEaqRDe7Uk\n\n\n\n \n주기적으로 정리해보겠습니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1419",
    "pubDate": "Thu, 9 Oct 2025 18:51:29 +0900",
    "creator": "SIDNFT",
    "categories": [
      "투자",
      "IONQ",
      "QBTS",
      "rgti",
      "양자컴퓨터"
    ]
  }
]