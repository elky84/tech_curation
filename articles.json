[
  {
    "id": 1,
    "imageUrl": "",
    "title": "Vlad Mihalcea와의 인연",
    "description": "유튜브나 블로그를 하다 보면 예상치 못한 인연들이 생긴다.\n지금까지 10년 가까운 시간을 블로그를 하면서 큰 동력이 된 사건이기도 하다.\n \n운이 좋게도 2014년부터 다녔던 회사는 Hibernate를 사용하는 회사였고, 그 당시 iBatis, MyBatis를 쓰는 것이 당연한 상황에서 Hibernate를 실무에서 사용해볼 수 있었다.\n다만, 처음 사용해보는 기술이니 이걸 더 잘 쓰기 위해서 공부를 하고 싶은데 공부할 수 있는 컨텐츠가 없었다.\n한국어로 된 컨텐츠의 대부분은 iBatis, MyBatis였기 때문이다.\n다행히 기선님이 번역해주신 개빈 킹의 하이버네이트 완벽가이드가 있었지만 나 같은 초보 개발자에겐 너무나 어렵게 느껴져 한줄 한줄 밑줄 그어가며 이해하려고 노력했다.\n영한님의 Java ORM에 대한 DevOn 발표 자료도 발견하게 되고 이후엔 영한님의 책 까지 보면서 Java ORM에 대해 훨씬 쉽게 다가갈 수 있었고 실무를 하는데 있어서 충분히 많은 지식을 쌓을 수 있었다.\n이후에도 계속 JPA, Hibernate를 실무에서 계속 사용할 수 있었는데, 구글링 할때마다 항상 만나는 블로그와 스택오버플로우의 답변 유저가 있었다.\n그게 바로 Vlad Mihalcea였다.\n나중에 알고 보니 그는 자바 챔피언이자 Hibernate Top Committer 였다는 것에 \"역시...\" 라는 생각을 했다.\n당시에는 \"와 역시 해외는 어마어마한 개발자들이 많구나. 영어 공부 진짜 열심히 해야겠다\" 라는 생각을 하면서 열심히 그의 글을 탐닉했다.\n새로운 글이 올라오면 항상 챙겨보고 그게 진짜 맞는지 성능 테스트를 진행해보고 효과를 확인 한뒤에는 회사에 적용하는 등 그의 지식을 어떻게든 내 것으로 다 흡수하고 싶었다.\n그의 책 High-Performance Java Persistence는 사무실 책상 위에 항상 펼쳐져 있었다.\n그렇게 몇년의 경력이 쌓이던 중,\n2018년 갑자기 블로그의 트래픽이 폭발적으로 늘어나는 일이 있었다.\n어디서 이렇게 유입된 건지 찾아보다가 Hibernate 공식 커뮤니티 뉴스레터 2018년 10호에서 내가 작성한 \"Spring Boot Data JPA 2.0 에서 id Auto_increment 문제 해결\"을 소개한 것을 발견했다.\n전세계 Java 개발자들이 구독하고 있는 Hibernate 뉴스레터에서 언급된 것이다.\n그 뉴스레터는 내가 매일 방문하던 Vlad Mihalcea가 작성한 것이기에 믿기지 않는 순간이였다.\n\n\n\n이때의 기억이 강렬해서 \"와 블로그 진짜 오래오래 해야겠다\" 라는 다짐을 했었다.\n그리고 10년 넘게 블로그를 운영하게 되었다.\n그 날 이후로는 기술적인 글 외에도, Vlad Mihalcea 라는 개발자에 대해서도 관심을 가지기 시작했다.\n그의 기술적인 노하우 뿐만 아니라,\n'이 사람은 도대체 어떤 커리어를 밟아왔을까?'\n'어떻게 자바 챔피언이 되었을까?'\n'어떻게 이렇게 한 분야에서 세계적인 전문가가 되었을까?' 등등.\nHow to become a Java Champion\n책 외에 또 배울 수 있는 것들이 없을까 싶어 그의 온라인 스토어에서 판매하는 온라인 강의들도 찾아서 들었다.\nJava Persistence 에서의 성능 개선 노하우나 Java 환경에서의 SQL 성능 개선 등 자바 개발자 뿐만 아니라 ORM을 사용하는 개발자로서 필요한 대부분의 성능 개선 노하우를 얻을 수 있었다.\nORM과 SQL 양 쪽에 맞는 가장 적절한 성능 튜닝 사례들을 배울 수 있었고, 이때 배운 지식들은 수십억건의 데이터들 사이에서도 복잡한 도메인들을 처리하는데 큰 힘이 되었다.\n다만, 강의를 수강하는게 수월하지는 않았다.\n영어로만 강의가 제공되어서 하나의 강의를 수강하는데 하나하나를 번역해서 보는데 너무 많은 힘이 들었고\n결제 오류가 빈번해서 결제하기가 쉽지 않았고\n강의를 수강하는데 있어서의 편의 기능이 많이 부족했다. (모바일 플레이어, 자막 등등)\n그래도 좋았다.\n이것마저 없으면 그의 양질의 컨텐츠를 볼 수 있는 방법이 없는데, 이렇게라도 볼 수 있으니 말이다.\n이렇게 쌓인 노하우는 이후에 전 직장 첫번째 컨퍼런스에서 아낌없이 쏟아낼 수 있었다.\n[우아콘2020] 수십억건에서 QUERYDSL 사용하기\n이 세션은 (갓)영한님의 세션 다음으로 가장 높은 조회수가 나와서 많은 개발자분들이 좋아해주셨다.\n그동안의 공부와 경험이 전혀 잘못되지 않았다는 것을 느끼게 해주었다.\n이런 경험으로 성장을 해왔기에,\n현재 회사로 이직하고 나서 우리팀 백엔드 개발자분들에게 Vlad의 강의를 너무 소개해주고 싶었다.\n꼭 JPA 뿐만 아니라 모든 ORM과 SQL을 사용하는 개발자들에게 필수적인 내용을 담고 있기 때문이다.\n우리 같이 Node.js가 주력인 개발팀에는 언어나 프레임워크에 상관없이 이런 강의가 대단히 필요하다.\n하지만, 위에서 언급한 \"언어의 장벽이나 결제, 학습 편의성\" 등을 생각하니 \"우리 팀 분들에게도 나처럼 힘들게 공부하시라\" 라고 이야기하기 어려웠다.\n어떻게든 우리팀에 이 지식들을 가장 편하게 전달하고 싶었다.\n어떡하는게 좋을까....?\n그래서 Vlad Mihalcea에게 연락을 드렸다.\n당신의 강의를 한국어로, 일본어로, 베트남어로 듣고 싶다고.\nVlad는 너무나 쿨하게, 너무나 멋지게 이 협업을 받아들여 주셨다.\n그리고 드디어!\nVlad Mihalcea의 공식 강의 2개가 인프런에 오픈되었다.\n  High-Performance Java Persistence\n  High-Performance SQL\n  이 강의들은 한국어, 일본어, 베트남어, 영어로 자막 및 더빙이 제공됩니다.\n즉, 아시아권 개발자 누구나 언어 장벽 없이 수강하실 수 있도록 준비되어 있습니다.\n더욱 감사한 것은 오픈 기간 동안40% 할인까지도 동의해주셨다.\nVlad Mihalcea 님의 오픈 이벤트\n\"실무에서 성능과 구조 모두를 고려해야 하는 상황에서 무엇을 기준으로 선택할 것인가\" 를 알려주는 강의를 이제 우리 팀원들에게도 알려줄 수 있게 되어서 너무나 기뻤다.\n우리 팀 외에도 특히 다음과 같은 분들께 추천드리고 싶다:\nJPA, Hibernate 등을 사용하지만 내부 구조를 분석하고 근본적인 이해를 높이고 싶거나\n실무 환경의 Java Data Access 계층에서 발생하는 성능 문제를 해결하는 방법을 배우고 싶거나\nORM 을 적극적으로 쓰는 환경에서의 SQL 성능 개선 방법을 배우고 싶거나\n이런 분들이라면 이번 Vlad의 강의를 적극 추천하고 싶다.\n전세계 Java 개발자들이 Vlad의 컨텐츠를 좋아하고 강의를 듣는 이유가 무엇인지 잘 알 수 있다.\n지금 Java 개발을 시작하는 분들은 나처럼 영어 문장 하나 하나를 직접 번역해가며, 여러 해외카드들을 교체해가며 결제하는 등의 불편함 없이 배울 수 있게 되었다는 것이 훨씬 기쁘다.\nVlad 외에도 세상엔 너무나 훌륭한 개발자분들과 그들의 강의들이 있다.\n이 강의들을 모두 다 언어와 결제, 학습의 제약 없이 듣는 것을 꿈꾸고 있다.\n그리고 출간을 준비하고 있는 High-Performance Java Persistence 2판도 인프런에서 만나볼 수 있게 되기를 기대한다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://jojoldu.tistory.com/825",
    "pubDate": "Thu, 17 Apr 2025 11:23:28 +0900",
    "creator": "향로 (기억보단 기록을)",
    "categories": [
      "생각정리",
      "hibernate",
      "high-performance java persistence",
      "high-performance sql",
      "java champion",
      "JPA",
      "Vlad Mihalcea"
    ]
  },
  {
    "id": 2,
    "imageUrl": "",
    "title": "오래된 노트북 재활용하는 7가지 실용적인 방법",
    "description": "그냥 버리기엔 아까운 오래된 노트북, 이렇게 활용해보세요! 미디어 서버부터 디지털 액자까지 실용적인 재활용 방법 7가지를 소개합니다. 버리지 말고 새 생명을 불어넣어 보세요!\n\n\n \n요즘 기술이 너무 빨리 발전해서 3-4년만 지나도 노트북이 구식이 되는 느낌 있으시죠? 저도 얼마 전에 새 노트북으로 교체하면서 5년 된 구형 노트북을 어떻게 처리할지 한참 고민했어요. 그냥 버리자니 아직 작동도 잘 되고 뭔가 아깝다는 생각이 들더라고요. 혹시 여러분도 비슷한 고민 하고 계신가요?\n \n솔직히 말해서 요즘 전자기기는 너무 쉽게 버려지는 것 같아요. 환경 문제도 심각하고 자원 낭비도 크죠. 그래서 제가 직접 찾아보고 시도해본 오래된 노트북 재활용 방법들을 공유해드리려고 합니다. 생각보다 정말 쓸모있는 용도가 많더라고요!\n \n1. 홈 미디어 서버로 변신시키기  \n제가 가장 먼저 시도해본 방법인데요, 구형 노트북을 미디어 서버로 활용하는 거예요. 영화, 음악, 사진 같은 미디어 파일을 한 곳에 모아두고 집 안 어디서든 접근할 수 있게 만드는 거죠.\n \nPlex나 Kodi 같은 무료 미디어 서버 소프트웨어를 설치하면 금방 세팅할 수 있어요. 저는 Plex를 선택했는데, 직관적인 인터페이스가 마음에 들었거든요. 설치 후에는 TV, 스마트폰, 태블릿 등 다양한 기기에서 콘텐츠를 스트리밍할 수 있어요.\n\"근데 노트북 성능이 너무 안 좋으면 어떡하지?\" 걱정할 필요 없어요. 미디어 서버는 최신 게임이나 고사양 작업을 하는 게 아니라서 좀 오래된 노트북으로도 충분히 잘 돌아가요. 저도 2015년식 노트북으로 4K 영상까지 무리 없이 스트리밍하고 있어요.\n \n2. NAS(네트워크 스토리지)로 활용하기  \n파일 저장과 공유에 초점을 맞추고 싶다면 NAS로 활용하는 것도 좋은 방법이에요. 가정이나 소규모 사무실에서 모든 중요 문서와 파일을 한곳에 모아두고 네트워크로 접근할 수 있게 해주죠.\n \nFreeNAS 같은 오픈소스 OS를 설치하면 전문 NAS 장비처럼 사용할 수 있어요. 물론 노트북에 하드 드라이브 용량이 부족하다면 외장 하드를 연결해서 확장할 수도 있고요.\n \n이렇게 구성해두면 백업 시스템으로도 완벽하게 활용할 수 있어요. 중요한 자료들이 클라우드에만 의존하지 않고 내 집에서 안전하게 보관되니까 개인정보 보호 측면에서도 좋더라고요.\n \n3. 홈 오토메이션 허브 만들기  \n스마트홈에 관심 있으신 분들이라면 오래된 노트북을 홈 오토메이션 허브로 변신시켜보는 건 어떨까요? 이게 진짜 신기한 게, 스마트 조명, 온도계, 보안 카메라 같은 IoT 기기들을 한 곳에서 제어할 수 있는 중앙 시스템을 만들 수 있어요.\n \nHome Assistant나 OpenHAB 같은 오픈소스 플랫폼을 설치하면 금방 세팅할 수 있어요. 저는 Home Assistant를 써봤는데, 처음엔 살짝 어려웠지만 일단 설정해두니 정말 편리하더라고요.\n \n예를 들어, 퇴근 시간에 맞춰서 집의 온도를 자동으로 조절하고, 현관문이 열리면 자동으로 불이 켜지고, 밤에는 보안 모드로 전환되는 식으로 자동화를 설정해뒀어요. 상용 스마트홈 시스템을 사는 것보다 훨씬 저렴하고 커스터마이징도 마음대로 할 수 있어서 좋았습니다.\n \n4. 가정용 보안 시스템으로 활용하기  \n요즘 보안에 대한 관심이 높아지면서 CCTV나 보안 카메라를 설치하는 가정이 많은데요, 생각해보니 웹캠이 달린 노트북이 이미 카메라 역할을 할 수 있잖아요?\n \niSpy나 ZoneMinder 같은 무료 보안 소프트웨어를 설치하면 노트북을 통해 집안을 모니터링할 수 있어요. 움직임이 감지되면 알림을 보내거나 영상을 녹화하는 기능도 있고요.\n \n제가 작년에 여행 갔을 때 시험 삼아 써봤는데, 스마트폰으로 집 안 상황을 실시간으로 확인할 수 있어서 정말 마음이 놓이더라고요. 혹시 반려동물이 있으신 분들은 집에 혼자 있는 반려동물을 체크하는 용도로도 좋을 것 같아요!\n \n5. 디지털 액자로 변신시키기  ️\n좀 더 가벼운 용도로는 디지털 액자가 있어요. 노트북 화면이 TV보다는 작지만 일반 액자보다는 크니까 가족 사진이나 좋아하는 작품을 전시하기에 딱 좋은 크기죠.\n \n윈도우 기본 슬라이드쇼 기능을 사용해도 되고, 좀 더 다양한 기능을 원한다면 PhotoSync나 Screenly 같은 앱을 설치해도 좋아요. 노트북을 거실이나 주방에 놓아두고 추억의 사진들이 슬라이드쇼로 넘어가게 하면 인테리어 효과도 있어요.\n \n특히 부모님께 선물로 드리면 정말 좋아하실 것 같아요. 제 엄마는 제가 이렇게 세팅해드렸더니 손주들 사진을 계속 볼 수 있어서 너무 좋아하셨어요. 가끔 구글 포토와 연동해두면 자동으로 새 사진도 추가되니까 편리하더라고요.\n \n6. 학습용 컴퓨터로 재탄생  \n가정에 어린 자녀가 있다면, 오래된 노트북을 아이들 전용 학습 컴퓨터로 만들어주는 것도 좋은 방법이에요. 최신 게임은 돌아가지 않을 수 있지만, 인터넷 검색이나 문서 작업, 교육용 앱을 사용하는 데는 전혀 문제가 없거든요.\n \nLinux 기반의 가벼운 OS(예: Lubuntu, Linux Mint)를 설치하면 성능이 더 좋아질 수 있어요. 그리고 유해 콘텐츠 차단 프로그램을 설치해서 안전한 인터넷 환경을 만들어 줄 수도 있고요.\n \n요즘은 코딩 교육이 중요해지면서 Scratch나 Python 같은 프로그래밍 언어 학습 환경을 구축해주는 것도 좋은 아이디어예요. 아이들이 컴퓨터 사용법과 함께 디지털 리터러시를 기를 수 있는 좋은 기회가 될 수 있어요.\n \n7. 리눅스로 새 생명 불어넣기  \n마지막으로, 가장 기본적이면서도 효과적인 방법은 가벼운 리눅스 OS를 설치해서 노트북에 새 생명을 불어넣는 거예요. 윈도우보다 훨씬 적은 시스템 자원으로 돌아가는 리눅스 배포판이 많거든요.\n \nXubuntu, Lubuntu, Linux Lite 같은 가벼운 배포판은 오래된 하드웨어에서도 놀랍도록 빠르게 작동해요. 저도 7년 된 노트북에 Xubuntu를 설치했더니 속도가 확 빨라져서 깜짝 놀랐어요. 인터넷 서핑, 문서 작업, 간단한 그래픽 작업 정도는 전혀 문제없이 할 수 있더라고요.\n \n무엇보다 리눅스는 무료이고 바이러스에 대한 걱정도 적어서 제2의 컴퓨터로 쓰기에 정말 좋아요. 처음에는 좀 낯설 수 있지만, 기본적인 사용법만 익히면 생각보다 어렵지 않아요.\n\n\n마무리\n자, 이렇게 오래된 노트북을 재활용할 수 있는 7가지 방법을 소개해드렸는데요. 어떤가요? 생각보다 활용도가 높죠? 버리기 전에 이런 방법들을 한번 시도해보시면 어떨까요?\n저는 개인적으로 미디어 서버와 가끔 보안 카메라로 번갈아가며 사용하고 있는데, 정말 만족스러워요. 안 쓰는 물건에 새 생명을 불어넣는다는 느낌도 좋고, 환경 보호에도 조금이나마 기여한다는 생각이 들어서 뿌듯하더라고요.\n여러분은 어떤 방법이 가장 끌리시나요? 혹시 다른 재활용 방법을 알고 계시다면 댓글로 공유해주세요! 서로의 아이디어를 나누면 더 좋은 방법들이 나올 것 같아요.  \nFAQ\nQ: 노트북이 너무 느려서 재활용이 가능할까요?\nA: 네, 가능합니다. 가벼운 리눅스 OS를 설치하거나 단일 목적(미디어 서버, 디지털 액자 등)으로 활용하면 오래된 노트북도 충분히 사용할 수 있어요.\nQ: 배터리가 거의 방전되는 노트북도 활용 가능한가요?\nA: 전원에 연결해 사용하는 용도(서버, 보안 카메라 등)로는 배터리 상태와 무관하게 활용 가능합니다.\nQ: 리눅스 설치가 어렵지 않을까요?\nA: 요즘 리눅스는 사용자 친화적으로 많이 개선되었습니다. Ubuntu나 Mint 같은 배포판은 설치 과정이 윈도우와 비슷할 정도로 쉬워요.\nQ: 미디어 서버 구축 시 저장 공간이 부족하다면?\nA: 외장 하드드라이브를 연결하여 저장 공간을 확장할 수 있습니다. USB 3.0 포트가 있다면 더 빠른 속도로 사용 가능해요.\nQ: 오래된 노트북을 재활용하는 것이 환경에 얼마나 도움이 될까요?\nA: 전자 폐기물 감소와 자원 절약에 큰 도움이 됩니다. 노트북 한 대를 제조하는 데 많은 자원과 에너지가 소비되므로, 수명을 연장하는 것은 환경 보호에 직접적인 기여가 됩니다.\n \n\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"노트북이 너무 느려서 재활용이 가능할까요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"네, 가능합니다. 가벼운 리눅스 OS를 설치하거나 단일 목적(미디어 서버, 디지털 액자 등)으로 활용하면 오래된 노트북도 충분히 사용할 수 있어요.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"배터리가 거의 방전되는 노트북도 활용 가능한가요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"전원에 연결해 사용하는 용도(서버, 보안 카메라 등)로는 배터리 상태와 무관하게 활용 가능합니다.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"리눅스 설치가 어렵지 않을까요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"요즘 리눅스는 사용자 친화적으로 많이 개선되었습니다. Ubuntu나 Mint 같은 배포판은 설치 과정이 윈도우와 비슷할 정도로 쉬워요.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"미디어 서버 구축 시 저장 공간이 부족하다면?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"외장 하드드라이브를 연결하여 저장 공간을 확장할 수 있습니다. USB 3.0 포트가 있다면 더 빠른 속도로 사용 가능해요.\"\n    }\n  }, {\n    \"@type\": \"Question\",\n    \"name\": \"오래된 노트북을 재활용하는 것이 환경에 얼마나 도움이 될까요?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"전자 폐기물 감소와 자원 절약에 큰 도움이 됩니다. 노트북 한 대를 제조하는 데 많은 자원과 에너지가 소비되므로, 수명을 연장하는 것은 환경 보호에 직접적인 기여가 됩니다.\"\n    }\n  }]\n}",
    "reviews": [],
    "syllabus": [],
    "link": "http://muzbox.tistory.com/483572",
    "pubDate": "Mon, 21 Apr 2025 07:03:28 +0900",
    "creator": "어떤오후의 프리웨어 이야기",
    "categories": [
      "윈도우 사용팁/하드웨어",
      "NAS 구축",
      "가정용 보안 시스템",
      "노트북 재활용",
      "디지털 액자",
      "리눅스 설치",
      "미디어 서버 구축",
      "오래된 노트북 활용",
      "전자기기 재활용",
      "학습용 컴퓨터",
      "홈 오토메이션"
    ]
  },
  {
    "id": 3,
    "imageUrl": "",
    "title": "IntelliJ Scala Plugin 2025.1 Is Out!",
    "description": "Support for new features in Scala 3 Context Bounds and Givens Scala 3.6 introduced a new syntax for context bounds and givens. You can read more about it in SIP-64. In short, before Scala 3.6, it was impossible to name the context bound in the same place where it was defined. The way to do […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/scala/2025/04/16/intellij-scala-plugin-2025-1-is-out/",
    "pubDate": "Wed, 16 Apr 2025 13:05:20 +0000",
    "creator": "Maciej Gorywoda",
    "categories": [
      "news",
      "releases",
      "scala",
      "scala-programming",
      "intellij-idea"
    ]
  },
  {
    "id": 4,
    "imageUrl": "",
    "title": "유니티 애셋 / 살이 출렁이는 연출 /",
    "description": "영상: https://www.youtube.com/watch?v=VDyPjhugZSM\n\n\n\n \n \n홍보영상: https://www.youtube.com/watch?v=_mSPXq_2saU\n\n\n\n \n보잉 같은건가 싶기도 하고 ...\n아무튼 출렁임",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1273",
    "pubDate": "Fri, 18 Apr 2025 15:03:36 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/유니티 에셋 리뷰"
    ]
  },
  {
    "id": 5,
    "imageUrl": "",
    "title": "돈 버는 습관",
    "description": "얼마 전에 우리의 오래된 투자사의 이사회 미팅에 참석했다. 아주 힘든 사업을 하고 있는데, 10년 전 창업할 땐, 창업가들도 이렇게 힘든 사업인 줄 몰랐고, 투자자들도 이렇게 힘든 사업인 줄 몰랐다. 그동안 실수도 많이 했고, 돈도 많이 까먹으면서 개고생했는데, 이제 회사가 어느 정도 안정적인 운영 방법을 찾았고, 그동안 마이너스 나는 사업을 하다가 작년부터 손익분기점을 넘으면서 흑자를 만들고(...)",
    "reviews": [],
    "syllabus": [],
    "link": "https://www.thestartupbible.com/2025/04/profit-making-as-a-habit.html",
    "pubDate": "Wed, 16 Apr 2025 21:26:00 +0000",
    "creator": "Kihong Bae",
    "categories": [
      "Uncategorized",
      "FoundersAtWork",
      "hustle",
      "inspiring",
      "sports",
      "Strong"
    ]
  },
  {
    "id": 6,
    "imageUrl": "",
    "title": "Big News! JetBrains Qodana’s Code Quality Plugin Is Now Available for Visual Studio",
    "description": "It’s no secret that Qodana is a team tool that JetBrains designed to integrate seamlessly with its suite of IDEs, but every team and tech stack is different. One common question remains: “What about other members of our team who still use VS Code or Visual Studio?” To help with this problem, we decided to […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/qodana/2025/04/visual-studio-plugin/",
    "pubDate": "Wed, 16 Apr 2025 15:24:15 +0000",
    "creator": "Kerry Beetge",
    "categories": [
      "plugin-highlights",
      "plugins",
      "qodana",
      "release",
      "visual-studio"
    ]
  },
  {
    "id": 7,
    "imageUrl": "",
    "title": "Pure Virtual C++ 2025: Full Schedule",
    "description": "Pure Virtual C++ is our free, one-day, virtual conference for the whole C++ community. This year, it is running on the 30th April. We’re pleased to announce the schedule of live talks: 14:00 UTC: Welcome to v1.0 of the meta::[[verse]]! with Inbal Levi 14:30 UTC: Proxy: Next Generation Polymorphism with Mingxin Wang 15:00 UTC: Making […]\nThe post Pure Virtual C++ 2025: Full Schedule appeared first on C++ Team Blog.",
    "reviews": [],
    "syllabus": [],
    "link": "https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2025-full-schedule/",
    "pubDate": "Tue, 15 Apr 2025 12:15:38 +0000",
    "creator": "Sy Brand",
    "categories": [
      "C++"
    ]
  },
  {
    "id": 8,
    "imageUrl": "",
    "title": "OpenAI 코딩 멀티 에이전트 Codex 오픈소스 도구 사용법",
    "description": "이 글은 OpenAI가 개발한 코딩 멀티 에이전트 Codex 사용법을 간략히 소개한다. \n\n\n현재 시점에서 14시간 전에 OpenAI o3, o4, codex 가 공개되었다. 모두 멀티 AI 에이전트 기능을 충실히 구현한 영상을 데모가 업로드되었고, 특히, 자동화 코딩을 지원하는 codex(코덱스) 가 로컬 컴퓨터에서 실행 가능한 형태로 공개된 점이 인상적이었다. \n\nOpenAI o3, o4, codex 공개 영상\n\n\n코덱스 코드 및 도구는 Github에 공개되었다.\n\ncodex: Lightweight coding agent that runs in your terminal\n\n\n\n코덱스 설치 및 환경설정\n터미널에서 다음을 실행해 설치 및 환경 설정을 한다.\ngit clone https://github.com/openai/codex.git\ncd codex\nnpm install -g @openai/codex\n\n\n\n\n설치 시 npm error code SELF_SIGNED_CERT_IN_CHAIN 에러 발생하면 다음 명령 실행 후 패키지 재설치한다.\n\nnpm config set strict-ssl false -g\n\n\n오픈AI Key를 설정한다.\n\nexport OPENAI_API_KEY=\"your-api-key-here\"\n\n\n\n실행\n터미널에서 코덱스를 실행한다. \ncodex \n\n\n프롬프트를 직접 입력해도 된다.  \ncodex \"explain this codebase to me\"\n\n\n앱을 개발해보자. \ncodex --approval-mode full-auto \"create the fanciest todo-list app\"\n\n\n그럼 todo list app을 codex가 개발하는 것을 확인할 수 있다. 이외에 다음과 같은 프롬프트를 입력해보자. \n\n\n\"create the ascii rendering web viewer using webcam\"\n\"create 3D tetris using three.js\"\n...\n\n\n마무리\n점차 AI 에이전트가 우리가 사용하는 개인 기기(노트북, 스마트폰 등)에 침투하고 있다. MCP는 그 시작인 것이고, Codex는 AI OS 위치로 맵핑하고자 한다. 올해 더 큰 경쟁과 발전이 있으리라 생각된다.\n\n\n레퍼런스\n\nLightweight coding agent that runs in your terminal\nCLI OpenAI Tool Like Claude Code\nOpenAI Codex CLI. Is a Lightweight Coding AI Agent",
    "reviews": [],
    "syllabus": [],
    "link": "http://daddynkidsmakers.blogspot.com/2025/04/openai-codex.html",
    "pubDate": "2025-04-17T07:04:00.000Z",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 9,
    "imageUrl": "",
    "title": "토스, 전자문서 발급으로 종이 2억 2천만 장 절감",
    "description": "사용자 편의성과 환경 보호 동시 실현",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.toss.im/article/tosssavetheplanet",
    "pubDate": "Mon, 21 Apr 2025 23:00:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 10,
    "imageUrl": "",
    "title": "Taint Analysis: Exploring Hidden Dangers in Your Team’s Code",
    "description": "Join us for an engaging roundtable discussion where our panel of developers will share their firsthand insights on the latest Taint Analysis from JetBrains. Discover how critical checks can improve codebase security and be easily implemented in your code review process. Session abstract Whether you’re new to JetBrains or looking to deepen your understanding of […]",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.jetbrains.com/qodana/2025/04/taint-analysis-exploring-hidden-dangers-in-your-team-s-code/",
    "pubDate": "Mon, 21 Apr 2025 20:22:19 +0000",
    "creator": "Kerry Beetge",
    "categories": [
      "livestream",
      "livestreams",
      "security",
      "taint-analysis"
    ]
  },
  {
    "id": 11,
    "imageUrl": "",
    "title": "Toss Compares Auto Insurance Quotes with Insurer-Matched Rates",
    "description": "Toss being the first in the industry to launch it",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.toss.im/article/automobile__",
    "pubDate": "Thu, 17 Apr 2025 22:36:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 12,
    "imageUrl": "",
    "title": "토스인컴, '5월 종소세 신고' 앞두고 '추징 안심보상제' 실시",
    "description": "‘추징 안심보상제’와 ‘종소세 미리보기’ 서비스 출시",
    "reviews": [],
    "syllabus": [],
    "link": "https://blog.toss.im/article/tossincomeservices",
    "pubDate": "Mon, 21 Apr 2025 01:00:00 GMT",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 13,
    "imageUrl": "",
    "title": "단지 권한 기능을 추가해달라고 했을 뿐인데(feat. 인증 기능 개선)",
    "description": "안녕하세요. 스포카 백엔드팀 프로그래머 남경호입니다.\n개발자라면 누구나 오랫동안 미뤄두었던 과제가 하나쯤 있을 것입니다. 업무의 우선순위가 낮거나 긴급한 과제들에 밀려 지속적으로 백로그에 쌓여 있던 작업 말이죠. 최근 저희팀에서 왜 오랜 시간 미뤄두었던 인증 방식 개선 작업을 진행하게 되었는지, 그 과정에서 얻은 여러 경험을 여러분께 공유하고자 합니다.\n배경\n스포카 블로그를 꾸준히 보신 분이라면, 서버 언어 전환 이야기 글에서 JWT 관련 문제를 언급하며 향후 개선할 예정이라고 소개했던 내용을 기억하실 겁니다.\n\n약 3년이 흐른 지금, 드디어 저희가 인증 방식 개선을 진행하게 된 가장 큰 이유는 바로 키친보드 매장 앱에 권한관리 기능이 추가되었기 때문입니다.\n\n키친보드 매장 앱은 식자재 주문부터 거래대금 결제까지 다양한 기능을 제공합니다. 이 과정에서 사장님은 직원이 매장의 월 거래 내역 등 민감한 정보를 조회하지 못하도록 권한을 제어할 필요가 생겼는데요. 기존 JWT 인증은 무 상태(stateless) 특성상 권한 변경 시 즉각적으로 클라이언트의 인증 상태를 관리할 수 없다는 한계가 있었습니다.\n그래서 저희는 권한 기능을 추가하기에 앞서 인증 방식을 먼저 개선하기로 하였습니다.\n인증 방식 개선 방법\nRefresh Token 도입\n앞서 이야기했듯이, JWT 기반의 인증 방식은 서버가 사용자의 상태를 저장하지 않습니다. 덕분에 서버의 확장성이 높고 서버 부하를 줄일 수 있다는 장점이 있지만, 한번 발급된 토큰을 서버에서 직접 제어할 수 없다는 단점이 있습니다.\n이러한 특성은 보안 문제로 연결될 수 있는데요. 만약 인증을 통해 발급받은 토큰이 탈취된다면, 서버가 이 토큰을 제어할 수 없으므로 악의적인 사용자는 손쉽게 탈취된 토큰을 이용하여 정상 사용자처럼 서비스를 이용할 수 있게 됩니다. 보통 이러한 보안 위험을 방지하기 위해 Access Token의 만료 시간을 짧게 설정하지만, 이 경우 사용자가 자주 로그인해야 하는 번거로움이 발생하게 됩니다.\n이와 같은 문제를 해결할 수 있는 대표적인 방법의 하나가 바로 Refresh Token 의 도입입니다. Refresh Token은 Access Token과 달리 서버가 상태를 관리하는 토큰으로, Access Token을 갱신하는 데 사용됩니다. 앞서 말씀드린 대로, Access Token의 탈취 위험을 낮추기 위해 Access Token의 만료 시간을 짧게 설정하는 것이 좋은데요. 이때 Refresh Token을 활용하면 사용자가 Access Token의 만료 시점마다 다시 로그인하지 않아도 편리하게 새로운 Access Token을 발급받을 수 있습니다.\n다음 그림에서 Access Token과 Refresh Token의 인증 과정을 자세히 확인할 수 있습니다.\n\n사용자가 로그인을 요청하면 서버는 Access Token과 Refresh Token을 발급합니다.\n사용자는 발급받은 유효한 Access Token을 이용해 API를 호출하고, 서버는 요청된 데이터를 정상적으로 응답합니다.\n사용자가 만료된 Access Token을 가지고 API 요청을 하면 서버는 401 인증 에러를 반환합니다. 이때 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받고, 갱신된 Access Token으로 API를 재요청하여 정상적으로 데이터를 받을 수 있습니다.\n하지만 만약 사용자의 Refresh Token까지 만료된 상태라면, 서버는 최종적으로 401 인증 에러를 반환하여 사용자의 다시 로그인을 요구합니다.\n위 과정을 통해 일반적으로 Access Token의 만료 시간을 짧게 설정하여 Access Token의 탈취 위험을 최소화하고, Refresh Token을 통해 사용자 편의성 또한 유지할 수 있습니다.\n아래 그림을 통해 Access Token의 탈취로 인한 공격 시나리오로 Access Token의 만료시간이 짧으면 짧을수록 보안 위험도가 감소하게 됩니다.\n\n이처럼 Refresh Token을 적절히 도입하고 관리하면 토큰 탈취로 인한 보안 위험을 효과적으로 감소시킬 뿐만 아니라 사용자가 매번 로그인해야 하는 문제도 해결할 수 있으므로 사용성도 함께 챙길 수 있게 됩니다.\nRefresh Token Rotation\n한편, Access Token에 대한 탈취 위험은 Refresh Token도 동일한 것 아닌가? 라는 질문을 할 수 있을 것 같습니다. 맞습니다. Refresh Token이 탈취당하면 Access Token을 갱신할 수 있고 갱신된 Access Token을 통해 악의적 사용자는 손쉽게 탈취한 사용자인 척 서비스를 이용할 수 있게 됩니다.\n이러한 문제를 해결하기 위해 우리는 Refresh Token Rotation 을 도입하기로 합니다. Refresh Token Rotation은 아래와 같이 Refresh Token을 이용해 Access Token을 갱신할 때 Refresh Token도 함께 갱신하여 Refresh Token 탈취 시 발생할 수 있는 위험을 회피합니다.\n\n이슈\n클라이언트의 네트워크 이슈\n앞서 저희는 Refresh Token Rotation을 이용하여 Refresh Token 탈취에 대한 위험성을 회피하고자 하였습니다. 이렇게 하면 Refresh Token을 이용하여 Access Token을 갱신 요청할 때 요청한 Refresh Token도 새롭게 발급되어 더 이상 Refresh Token을 사용할 수 없게 되는데요. 보안 수준은 강화되었지만, 클라이언트 개발자분들이 한가지 우려 점을 제기해 주셨습니다.\n모바일 기기 특성상 지하실이나 엘리베이터안과같이 네트워크가 원활하지 않은 곳에서 사용할 가능성이 존재하는데요. 이때 아래 그림과 같이 첫 번째 요청한 Refresh Token을 재요청하는 경우가 발생할 수 있습니다. 하지만 Refresh Token을 매번 갱신하기 때문에 동일한 Refresh Token으로 여러번 Access Token을 갱신요청하게 된다면 두번째 요청부터는  인증 에러가 발생하게 됩니다.\n\n그래서 저희는 Token Family 방식 을 사용하여 요청 시마다 기존 Refresh Token을 지우지 않고 과거 토큰을 저장해 두었다가 첫 번째 요청으로 새롭게 발급된 토큰 또는 모종의 이유로 인해 갱신하지 못한 기존 토큰으로 토큰 갱신 요청을 할 수 있도록 구현하여 Refresh Token을 재사용할 수 있도록 하였습니다.\n\n이로써 클라이언트는 네트워크 이슈가 발생해도 Refresh Token을 갱신할 수 있게 되었습니다.\n\n인증 토큰의 하위 호환\n한편, 저희는 JWT를 다루는 라이브러리로 JJWT 를 사용하고 있습니다. 앞서 JWT는 상태를 가지지 않기 때문에 사용자가 사용하는 Access Token을 서버에서 제어할 수 없다고 말씀드렸었는데요. 그래서 Access Token의 만료 시간을 두어 새롭게 Access Token을 발급받도록 하여 우회적으로 제어할 수 있습니다. Access Token을 만료시키는 또 다른 방법은, 해당 토큰을 생성할 때 사용된 암호키를 변경하는 것입니다. 저희는 그래서 클라이언트에서 사용하는 Access Token을 만료시키고 새롭게 변경된 권한을 사용하는 Access Token으로 사용하도록 하기 위해 암호키를 바꾸기로 하였습니다. 다만 여기서 발생하는 문제가 바로 앱의 업데이트 타이밍이었습니다.\n개발자라면 다들 잘 아시겠지만, 서버와 앱은 동일한 시점에 개발이 완료되더라도 배포되는 시점이 다를 수 있습니다. 서버는 배포하는 즉시 배포가 되지만 앱은 심사 과정이 필요하고 배포가 되더라도 앱스토어에 배포된 버전이 전파되기까지 1일 이상 소요될 수 있습니다. 그러다 보니 Access Token을 변경하기 위해 키를 변경하게 되면 서버가 배포된 이후부터 앱이 업데이트되기 전까지 사용자가 서비스를 이용할 수 없다는 문제가 생길 수 있습니다. 그래서 저희는 과거 버전의 앱에서도 새롭게 배포된 서버의 인증을 문제없이 사용할 수 있도록 방법을 모색해야 했습니다.\nJJWT 버전 변경\n한편, 저희는 비밀키를 바꾸는 김에, 과거에 사용하던 서명 알고리즘(HS256)에 비해 보안성이 강화된 서명 알고리즘(PS256)을 변경하기로 합니다. 그러다 보니 JJWT라이브러리 버전을 업그레이드해야 했는데요. Gradle에 아래처럼 동일한 라이브러리를 서로 다른 버전으로 사용하는 경우 패키지 충돌이 발생하여 신규 버전에서 제공하는 함수를 사용할 수 없게 됩니다.\n\n// 구버전\nimplementation(\"io.jsonwebtoken:jjwt:0.9.1\")\n\n// 신규버전\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\n\n이러한 문제를 해결하기 위해 저희는 Jitpack 을 사용하기로 합니다. JitPack은 GitHub에 호스팅된 라이브러리를 쉽게 빌드하고 배포할 수 있게 해주는 Maven/Gradle 용 리포지터리 서비스입니다. GitHub 저장소를 바탕으로 라이브러리를 빌드하므로, 별도의 중앙 저장소(예: Maven Central) 등록 과정을 거치지 않아도 된다는 장점이 있습니다. 그리고 오픈소스 저장소에, 한에 무료로 사용할 수 있다는 점도 장점입니다.\n저희는 JJWT 라이브러리를 fork하여 Spoqa용 JJWT Github 저장소 를 생성하였습니다. 그런 다음 충돌 패키지 충돌이 발생하지 않도록 패키지명을 변경해 주었습니다.\n\n그런 다음 Release를 생성해 주면, 아래와 같이 Jitpack에서 조회할 수 있게 됩니다.\n\n마지막으로 아래와 같이 Gradle에 의존성을 추가해주면, 패키지명이 변경된 JJWT라이브러리를 사용할 수 있게 됩니다.\n\nimplementation(\"com.github.spoqa:jjwt:1.0.2\")\nimplementation(\"javax.xml.bind:jaxb-api:2.3.1\")\n\nimplementation(\"io.jsonwebtoken:jjwt-api:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-impl:0.12.6\")\nruntimeOnly(\"io.jsonwebtoken:jjwt-jackson:0.12.6\")\n\n\nComposite 패턴 vs TokenManager\n저희는 Jitpack으로 생성한 과거버전의 JJWT를 의존하는 구현체를 아래와 같이 LegacyJwtProcessor로 변경하고 신규 버전을 사용하는 JwtProcessor를 새롭게 생성하였습니다. 그런 다음 아래와 같이 인증 로직에 과거 버전의 Access Token과 신규 버전의 Access Token을 모두 수용할 수 있도록 구현하였습니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val jwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal =\n            try {\n                jwtProcessor.getPrincipal(authentication.principal.toString())\n            } catch (e: AuthenticationException) {\n                legacyJwtProcessor.getPrincipal(authentication.principal.toString())\n            }\n\n        return JwtUserAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == JwtPreAuthenticationToken::class.java\n    }\n}\n\n\n이렇게 구현하면 앱이 배포되기 전에 서버가 먼저 배포되어도 기존 버전을 사용하는 사용자가 정상적으로 로그인을 유지할 수 있게 됩니다.\n한편, 인증 로직을 구현하는 곳 말고도 LegacyJwtProcessor를 사용하는 곳이 다수 존재하였는데요. 그러다 보니 새롭게 만들어진 JwtProcessor로 전환하는 것을 누락할 가능성이 존재하였습니다. 다행히 기능 테스트가 있어 놓친 구현을 바로잡을 순 있었지만, 코드의 응집성 측면에서는 좋은 코드는 아니라 생각하였습니다.\n그래서 Composite 패턴을 사용해서 아래와 같이 구현해 볼지 생각을 하였습니다.\n\ninterface JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String\n    fun getPrincipal(token: String): UserPrincipal\n}\n\nclass CompositeJwtProcessor(\n    private val newJwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: JwtProcessor,\n): JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n}\n\nclass NewJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\nclass legacyJwtProcessor: JwtProcessor {\n    fun generateToken(principal: UserPrincipal): String {\n        // 생략...\n    }\n    fun getPrincipal(token: String): UserPrincipal {\n        // 생략...\n    }\n}\n\n\nCompositeJwtProcessor를 이용하면 아래와 같이 JwtAuthenticationProvider는 더 이상 legacyJwtProcessor를 알지 않아도 되고 추후 legacyJwtProcessor가 제거되어도 영향범위는 CompositeJwtProcessor로 한정되기 때문에 응집도 높은 코드를 유지할 수 있게 됩니다.\n\n@Component\nclass JwtAuthenticationProvider(\n    private val compositeJwtProcessor: JwtProcessor,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = compositeJwtProcessor.getPrincipal(authentication.principal.toString())\n\n        return JwtUserAuthenticationToken(principal)\n    }\n    \n    // 생략...\n}\n\n\n다른 방법으로는 TokenManager라는 상위 수준의 클래스를 만들어 응집도를 높이는 방법도 생각해 보았습니다.\n\n@Service\nclass TokenManager(\n    private val jwtProcessor: JwtProcessor,\n    private val legacyJwtProcessor: LegacyJwtProcessor,\n    private val refreshTokenService: RefreshTokenService,\n) {\n    fun getPrincipal(token: String): UserPrincipal {\n        return try {\n            jwtProcessor.getPrincipal(token)\n        } catch (e: AuthenticationException) {\n            legacyJwtProcessor.getPrincipal(token)\n        }\n    }\n\n    fun generateAccessToken(userPrincipal: UserPrincipal): String {\n        // 생략...\n    }\n\n    fun generateRefreshToken(entity: RefreshToken): String {\n        // 생략...\n    }\n\n    fun replaceRefreshToken(principal: RefreshTokenUserPrincipal): String {\n        // 생략...\n    }\n}\n\n\n이렇게 하면 Token을 Composite 패턴을 사용한 것과 같이 하위호환을 지키는 코드와 함께 토큰과 관련된 다른 기능들도 해당 클래스로 모을 수 있어 응집도를 상당히 높일 수 있게 됩니다.\n어떤 방식이 더 나은 방식이라고 말씀드리긴 어려울 것 같습니다. 다만, 저희는 LegacyJwtProcessor는 앱 배포 이후에 제거될 클래스이므로 불필요하게 Composite 패턴을 사용하기보다 TokenManager를 생성하여 코드 응집도를 높이는 방법으로 결정하게 되었습니다.\nSpring Security - PreAuthorize\n저희는 인증과 인가를 위해 Spring Security를 사용하고 있습니다. JWT를 통해 인증된 사용자는 UserPrincipal이라는 인증된 사용자로 변환되고 UserPrinciapl이 가진 authorities를 통해 권한 처리를 하고 있습니다.\n\n@Component\nclass AccessTokenAuthenticationProvider(\n    private val tokenManager: TokenManager,\n) : AuthenticationProvider {\n    override fun authenticate(authentication: Authentication): Authentication? {\n        if (!supports(authentication::class.java)) return null\n\n        val principal = tokenManager.getPrincipal(authentication.principal.toString())\n        return AccessTokenAuthenticationToken(principal)\n    }\n\n    override fun supports(authentication: Class<*>): Boolean {\n        return authentication == AccessTokenPreAuthenticationToken::class.java\n    }\n}\n\nclass AccessTokenAuthenticationToken(\n    private val principal: UserPrincipal,\n) : AbstractAuthenticationToken(principal.authorities) {\n    init {\n        super.setAuthenticated(true)\n    }\n\n    override fun getPrincipal() = principal\n\n    override fun getCredentials() = null\n}\n\n\n사용자는 아래와 같이 @Secured를 통해 권한을 검증받고 API를 호출할 수 있습니다.\n\n@DgsMutation\n@Secured(STORE_ADMIN, STORE_MANAGER, VENDOR)\nfun createOrderSheet(\n    @InputArgument input: CreateOrderSheetInput,\n): CreateOrderSheet {\n    // 생략...\n}\n\n\n@Secured는 단순한 권한 Role 기반 접근을 제어하기에 적절합니다. 이전까지 키친보드는 관리자, 매장 사용자, 유통사 사용자로 명확하게 Role이 나뉘어져 있었기 때문에 @Secured는 요구사항을 충분히 충족하면서 단순하게 구현할 방법이었습니다.\n하지만 새로운 요구사항이 추가되면서 매장 사용자는 매장 관리자, 매장 직원으로 권한이 분리되게 되었는데요. 이에 따라 매장 사용자 모두 접근을 할 수 있는 API에는 아래와 같이 @Secured(STORE_ADMIN, STORE_MANAGER) 표현해야 하는 불편함이 있게 됩니다. 거기다 만약 STORE_INTERN이 추가된다면 매장 사용자 권한을 가져야 하는 API를 모두 찾아서 바꿔줘야 하니 상당히 번거로운 작업이 될 것이고 자칫 권한 변경을 누락할 수 있는 위험성 또한 내포하고 있습니다.\n이와 같은 문제를 해소하기 위해 Spring Security에서는 @PreAuthorize를 이용하여 유연하게 권한을 체크하는 기능을 제공합니다. 그래서 저희는 아래와 같이 매장 사용자 여부를 확인하는 서비스 함수를 만들어 SpEL 을 이용해 권한을 체크하도록 함으로써 권한을 일일이 나열하지 않고 새로운 권한이 생기더라도 유연하게 대처할 수 있도록 하였습니다.\n\n@PostMapping(\"/replace-store\")\n@PreAuthorize(\"@authorizationExpressionHelper.isManager()\")\nfun replaceStore(@RequestBody request: ReplaceStoreRequest): ReplaceStoreResponse {\n    // 생략...\n}\n\n@Service\nclass AuthorizationExpressionHelper {\n    fun isManager(): Boolean {\n        return PrincipalProvider.userPrincipal.isManager\n    }\n}\n\n\n마무리\n지금까지 저희가 권한 기능을 추가하기 위해 인증 로직을 어떻게 개선하였고 개선하면서 겪었던 이슈들을 공유해 보았습니다. 단순히 권한을 추가해 달라는 요구사항에서 시작되었지만, 그동안 우리가 가지고 있던 기술 부채도 해결함과 동시에 기술적인 여러 고민을 할 수 있어서 개인적으로 배운 게 많은 프로젝트였습니다.\n모쪼록 인증 기능 구현에 관심이 있으시거나 예정인 분들께 도움이 되었으면 합니다.\n긴 글 읽어주셔서 감사합니다.",
    "reviews": [],
    "syllabus": [],
    "link": "https://spoqa.github.io/2025/04/18/improve-auth.html",
    "pubDate": "2025-04-18T00:00:00.000Z",
    "creator": "Unknown",
    "categories": []
  },
  {
    "id": 14,
    "imageUrl": "",
    "title": "유니티 픽셀라이저 / 도트로 보이게 만들자",
    "description": "영상: https://youtu.be/q4epArkvVnE?t=1034\n\n\n\n12분에 나옵니다.\n \n애셋 링크: bing.com/ck/a?!&&p=75737a337e71df6ed009a8ed37376a2d33afc7c860ba34cee95c9fb3c24d295aJmltdHM9MTc0NTAyMDgwMA&ptn=3&ver=2&hsh=4&fclid=103bf7f7-14f0-64e7-025e-e4ca15636503&psq=unity+asset+store+pro+pixelizer&u=a1aHR0cHM6Ly9hc3NldHN0b3JlLnVuaXR5LmNvbS9wYWNrYWdlcy92Zngvc2hhZGVycy9mdWxsc2NyZWVuLWNhbWVyYS1lZmZlY3RzL3Byb3BpeGVsaXplci1yZWFsdGltZS0zZC1waXhlbC1hcnQtMTc3ODc3Izp-OnRleHQ9QWRkJTIwZGVwdGglMjB0byUyMHlvdXIlMjBwcm9qZWN0JTIwd2l0aCUyMFByb1BpeGVsaXplciUyMC0sbW9yZSUyMFZGWCUyMG9wdGlvbnMlMjBvbiUyMHRoZSUyMFVuaXR5JTIwQXNzZXQlMjBTdG9yZS4&ntb=1\n\n \nunity asset store pro pixelizer - Bing\nBing은 지능적인 검색 기능은 사용자가 원하는 정보를 빠르게 검색하고 보상을 제공합니다.\nwww.bing.com\n\n \n애셋 홍보영상: ProPixelizer for Unity\n\n\n\n \n나중에 써보도록 하자",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1277",
    "pubDate": "Sun, 20 Apr 2025 15:48:46 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/유니티 에셋 리뷰",
      "유니티"
    ]
  },
  {
    "id": 15,
    "imageUrl": "",
    "title": "게임 광고 300만원 태운 개발자 스토리 / 바코 BACO",
    "description": "영상: https://www.youtube.com/watch?v=oIWW0aJHGaQ\n\n\n\n \n제 이야기는 아니고 영상 이야기\n \n중요한것은 \n광고를 태워야해서 홍보페이지를 만들어야합니다.\n미리미리 영상을 잘 준비해둬야한다는 뜻입니다.\n광고를 하든 안하든 멋진 연출이이 나오도록 만들어야겠습니다.",
    "reviews": [],
    "syllabus": [],
    "link": "http://serverdown.tistory.com/1270",
    "pubDate": "Thu, 17 Apr 2025 16:20:25 +0900",
    "creator": "SIDNFT",
    "categories": [
      "프로그래밍/개발메모"
    ]
  }
]